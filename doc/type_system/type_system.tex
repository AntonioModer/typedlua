\documentclass[12pt]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\title{Typed Lua Type System}

\author{Andr√© Murbach Maidl}

\begin{document}

\maketitle

\section{Syntax}

\begin{align*}
T ::= \; & integer\\
& string\\
& true\\
& false\\
& Any\\
& Number\\
& String\\
& Boolean\\
& Nil\\
& Object\\
& T_1 \rightarrow T_2\\
& T_1 \cup T_2\\
& T_1 \cap T_2\\
& \{ T_1:U_1, ..., T_n:U_n, brand \}\\
& X\\
& \mu X.T\\
V ::= \; & T*\\
& T \times V\\
& ()
\end{align*}

\section{Subtyping}

The subtyping relation ($<:$) should be reflexive (\ref{reflexive})
and transitive (\ref{transitive}).

\begin{align}
\label{reflexive}
S \; <: \; S
\end{align}
\begin{align}
\label{transitive}
\frac{S \; <: \; U \;\;\; U\;  <: \; T}{S \; <: \; T}
\end{align}

\subsection{Constants}

\[
integer <: Number \; (\textit{S-INT})
\]

\[
string <: String \; (\textit{S-LIT})
\]

\[
true <: Boolean \; (\textit{S-TRUE})
\]

\[
false <: Boolean \; (\textit{S-FALSE})
\]

\subsection{Object (Top)}

\[
T <: Object \; (\textit{S-OBJ})
\]

\subsection{Functions}

\[
\frac{T_{1} <: S_{1} \;\;\; S_{2} <: T_{2}}
     {S_{1} \rightarrow S_{2} \; <: \; T_{1} \rightarrow T_{2}} \; (\textit{S-FUNC})
\]

\subsection{Tables}

\[
\{T_{i}:U_{i} \; ^{i \in 1..n+m}\} \;
<: \;
\{T_{i}:U_{i} \; ^{i \in 1..n}\} \; (\textit{S-TAB1})
\]

\[
\frac{\{T_{i}:S_{i} \; ^{i \in 1..n}\} \;
       \textbf{is a permutation of} \;
       \{V_{j}:U_{j} \; ^{j \in 1..n}\}}
     {\{T_{i}:S_{i} \; ^{i \in 1..n}\}
       <:
       \{V_{j}:U_{j} \; ^{j \in 1..n}\}} \; (\textit{S-TAB2})
\]

\subsection{Union}

\[
T_{1} <: T_{1} \cup T_{2} \; (\textit{S-UNION1})
\]

\[
T_{2} <: T_{1} \cup T_{2} \; (\textit{S-UNION2})
\]

\[
\frac{S_{1} <: T\;\;\; S_{2} <: T}
     {S_{1} \cup S_{2} <: T} \; (\textit{S-UNION3})
\]

\subsection{Intersection}

\[
T_{1} \cap T_{2} <: T_{1} \; (\textit{S-INTER1})
\]

\[
T_{1} \cap T_{2} <: T_{2} \; (\textit{S-INTER2})
\]

\[
\frac{S <: T_{1} \;\;\; S <: T_{2}}
     {S <: T_{1} \cap T_{2}} \; (\textit{S-INTER3})
\]

\subsection{Product}

\[
\frac{T_{1} <: T_{2} \;\;\; V_{1} <: V_{2}}
     {T_{1} \times V_{1} \; <: \; T_{2} \times V_{2}} \; (\textit{S-PROD1})
\]

\subsection{Vararg (...)}

\[
\frac{T_{1}* \; <: \; T_{2}*}
     {T_{1} \; <: \; T_{2}} \; (\textit{S-VARARG1})
\]

\[
T* \; <: \; T \cup Nil \times {T*} \; (\textit{S-VARARG2})
\]

\subsection{Recursive Types}

\[
\frac{S <: T[X \mapsto Y]}
     {\mu Y.S <: \mu X.T} \; (\textit{S-REC})
\]

\subsection{Trash}

\begin{align*}
V ::= \; & Void\\
& T\\
& T*\\
& T \times V
\end{align*}

\[
Void <: Nil \; (\textit{S-VOID1})
\]

\[
Void <: T_{1} \times Void (\textit{S-VOID2)}
\]

\[
\frac{Void <: T \;\;\; Void <: V}
     {Void <: T \times V} \; (\textit{S-VOID3})
\]

\[
\frac{T_{1} <: T_{2} \;\;\; V_{1} <: V_{2}}
     {T_{1} \times V_{1} <: T_{2} \times V_{2}} \; (\textit{S-PROD1})
\]

\[
\frac{S_{1} <: T_{1} \;\;\; S_{2} \times Void <: Void}
     {S_{1} \times S_{2} \times Void <: T_{1} \times Void} \; (\textit{S-PROD2})
\]

\section{Typing Rules}

\subsection{Syntax}

\begin{align*}
e ::= \; & nil\\
| & \; false\\
| & \; true\\
| & \; {...}\\
| & \; n\\
| & \; s\\
| & \; v\\
| & \; func \; b\\
| & \; \{fl\}\\
| & \; id(e,el)\\
| & \; e(el)\\
| & \; e + e\\
| & \; e - e\\
| & \; e \times e\\
| & \; e \div e\\
| & \; e \bmod e\\
| & \; e \otimes e\\
| & \; e \oplus e\\
| & \; e \not= e\\
| & \; e = e\\
| & \; e < e\\
| & \; e \le e\\
| & \; e > e\\
| & \; e \ge e\\
| & \; e \land e\\
| & \; e \lor e\\
| & \; \lnot \; e\\
| & \; - e\\
| & \; \# \; e\\
\end{align*}

\subsection{Expressions}

\[
nil : Nil \; (\textit{T-NIL})
\]

\[
false : Boolean \; (\textit{T-FALSE})
\]

\[
true : Boolean \; (\textit{T-TRUE})
\]

\[
{...} : Any \; (\textit{T-VARARG})
\]

\[
n : Number \; (\textit{T-NUMBER})
\]

\[
s : String \; (\textit{T-STRING})
\]

\[
func \; b : Any \; (\textit{T-ANONFUNC})
\]

\[
\{fl\} : Any \; (\textit{T-TABLECONST})
\]

\[
id(e,el) : Any \; (\textit{T-METHCALL})
\]

\[
e(el) : Any \; (\textit{T-FUNCCALL})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} + e_{2} : Number} \; (\textit{T-ADD})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} - e_{2} : Number} \; (\textit{T-SUB})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} \times e_{2} : Number} \; (\textit{T-MUL})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} \div e_{2} : Number} \; (\textit{T-DIV})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} \bmod e_{2} : Number} \; (\textit{T-MOD})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} \otimes e_{2} : Number} \; (\textit{T-POW})
\]

\[
\frac{e_{1}:String \;\;\; e_{2}:String}
     {e_{1} \oplus e_{2} : String} \; (\textit{T-CONCAT})
\]

\[
\frac{e_{1}:T \;\;\; e_{2}:T}
     {e_{1} \not= e_{2} : Boolean} \; (\textit{T-NE})
\]

\[
\frac{e_{1}:T \;\;\; e_{2}:T}
     {e_{1} = e_{2} : Boolean} \; (\textit{T-EQ})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} < e_{2} : Boolean} \; (\textit{T-LT1})
\]

\[
\frac{e_{1}:String \;\;\; e_{2}:String}
     {e_{1} < e_{2} : Boolean} \; (\textit{T-LT2})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} \le e_{2} : Boolean} \; (\textit{T-LE1})
\]

\[
\frac{e_{1}:String \;\;\; e_{2}:String}
     {e_{1} \le e_{2} : Boolean} \; (\textit{T-LE2})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} > e_{2} : Boolean} \; (\textit{T-GT1})
\]

\[
\frac{e_{1}:String \;\;\; e_{2}:String}
     {e_{1} > e_{2} : Boolean} \; (\textit{T-GT2})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} \ge e_{2} : Boolean} \; (\textit{T-GE1})
\]

\[
\frac{e_{1}:String \;\;\; e_{2}:String}
     {e_{1} \ge e_{2} : Boolean} \; (\textit{T-GE2})
\]

\[
\frac{e_{1}:T_{1} \;\;\; e_{2}:T_{2}}
     {e_{1} \land e_{2} : T_{1} \cup T_{2}} \; (\textit{T-AND})
\]

\[
\frac{e_{1}:T_{1} \;\;\; e_{2}:T_{2}}
     {e_{1} \lor e_{2} : T_{1} \cup T_{2}} \; (\textit{T-OR})
\]

\[
\frac{e : T}
     {\lnot \; e : Boolean} \; (\textit{T-NOT})
\]

\[
\frac{e : Number}
     {- \; e : Number} \; (\textit{T-MINUS})
\]

\[
\frac{e : String}
     {\# \; e : Number} \; (\textit{T-LEN})
\]

\end{document}
