\documentclass[12pt]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\title{Typed Lua Type System}

\author{Andr√© Murbach Maidl}

\begin{document}

\maketitle

\section{Type Language}

\begin{align*}
T ::= \; & constant \; | \; base \; | \; T \rightarrow T \; | \; T \cup T \; 
 | \; S\\
S ::= \; & {T*} \; | \; T \times S \; | \; Void\\
constant ::= \; & \textbf{nil} \; | \; \textbf{false} \; | \; \textbf{true} \;
 | \; {<}integer{>} \; | \; {<}double{>} \; | \; {<}string{>}\\
base ::= \; & Any \; | \; Boolean \; | \; Number \; | \; String\\
\end{align*}

\section{Subtyping}

The subtyping relation ($<:$) should be reflexive (\ref{reflexive})
and transitive (\ref{transitive}).

\begin{align}
\label{reflexive}
S \; <: \; S
\end{align}
\begin{align}
\label{transitive}
\frac{S \; <: \; U \;\;\; U\;  <: \; T}{S \; <: \; T}
\end{align}

\subsection{Constants}

\[
{<}integer{>} <: Number \; (\textit{S-INTEGER})
\]

\[
{<}double{>} <: Number \; (\textit{S-DOUBLE})
\]

\[
{<}string{>} <: String \; (\textit{S-STRING})
\]

\[
\textbf{false} <: Boolean \; (\textit{S-FALSE})
\]

\[
\textbf{true} <: Boolean \; (\textit{S-TRUE})
\]

\subsection{Functions}

\[
\frac{T_{1} <: S_{1} \;\;\; S_{2} <: T_{2}}
     {S_{1} \rightarrow S_{2} \; <: \; T_{1} \rightarrow T_{2}} \;
(\textit{S-FUNC})
\]

\subsection{Union}

\[
T_{1} <: T_{1} \cup T_{2} \; (\textit{S-UNION1})
\]

\[
T_{2} <: T_{1} \cup T_{2} \; (\textit{S-UNION2})
\]

\[
\frac{S_{1} <: T\;\;\; S_{2} <: T}
     {S_{1} \cup S_{2} <: T} \; (\textit{S-UNION3})
\]

%\subsection{Object (Top)}
%
%\[
%T <: Object \; (\textit{S-OBJ})
%\]

\section{Typing Rules}

\subsection{Abstract Syntax}

\begin{align*}
v ::= \; & id \; | \; e[e]\\
funcname ::= \; & \textbf{function} \; \overline{id} \;
| \; \textbf{method} \; \overline{id}\\
funcboby ::= \; & () \; s \; | \; ({...}) \; s \;
| \; (\overline{id}) \; s \; | \; (\overline{id},{...}) \; s\\
s ::= \; & \overline{s} \;
| \; \textbf{if-else} \; e \; s \; s \;
| \; \textbf{while} \; e \; s \;
| \; \textbf{repeat} \; s \; e \; | \\
& \textbf{fornum} \; id \; e \; e \; e \; s \; 
| \; \textbf{forgen} \; \overline{id} \; \overline{e} \; s \; | \\
& \textbf{func} \; funcname \; funcbody \; | \\
& \textbf{localfunc} \; id \; funcbody \;
| \; \textbf{label} \; id\ \; | \; \textbf{goto} \; id \; | \\
& \textbf{break} \;
| \; \textbf{assign} \; \overline{v} \; \overline{e} \;
| \; \textbf{localvar} \; \overline{id} \; \overline{e} \;
| \; \textbf{ret} \; \overline{e} \; | \; e\\
e ::= \; & \textbf{nil} \; | \; \textbf{false} \; | \; \textbf{true} \;
| \; {...} \; | \; n \; | \; w \; | \; v \; | \\
& \textbf{func} \; funcbody \;
| \; \{(\overline{e},\overline{(e,e)})\} \;
| \; id(e,\overline{e}) \; | \; e(\overline{e}) \; | \\
& e + e \; | \; e \; {..} \; e \; | \; e == e \; | \; e < e \;
| \; e \; \textbf{and} \; e \; | \; e \; \textbf{or} \; e \; | \\
& \textbf{not} \; e \; | - e \; | \; \# \; e
\end{align*}

\subsection{Expressions}

\[
\textbf{nil} : \textbf{nil} \; (\textit{T-NIL})
\]

\[
\textbf{false} : \textbf{false} \; (\textit{T-FALSE})
\]

\[
\textbf{true} : \textbf{true} \; (\textit{T-TRUE})
\]

\[
{...} : {Any*} \; (\textit{T-VARARG})
\]

\[
n : n \; (\textit{T-NUMBER})
\]

\[
w : w \; (\textit{T-STRING})
\]

\[
\frac{():Void \;\;\; s:T}
     {\textbf{func} \; () \; s : Void \rightarrow T} \;
     (\textit{T-AFUNC1})
\]

\[
\frac{(...):{Any*} \;\;\; s:T}
     {\textbf{func} \; (...) \; s : {Any*} \rightarrow T} \;
     (\textit{T-AFUNC2})
\]

\[
\frac{(\overline{id}):T_{1} \;\;\; s:T_{2}}
     {\textbf{func} \; (\overline{id}) \; s : T_{1} \rightarrow T_{2}} \;
     (\textit{T-AFUNC3})
\]

\[
\frac{(\overline{id},...):T_{1} \times {Any*} \;\;\; s:T_{2}}
     {\textbf{func} \; (\overline{id},...) \; s :
       T_{1} \times {Any*} \rightarrow T_{2}} \;
     (\textit{T-AFUNC4})
\]

\[
\{(\overline{e},\overline{(e,e)})\} : Any \; (\textit{T-TABLECONST})
\]

\[
id(e,\overline{e}) : Any \; (\textit{T-METHCALL})
\]

\[
e(\overline{e}) : Any \; (\textit{T-FUNCCALL})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} + e_{2} : Number} \; (\textit{T-ARITH1})
\]

\[
\frac{e_{1}:Any}
     {e_{1} + e_{2} : Any} \; (\textit{T-ARITH2})
\]

\[
\frac{e_{2}:Any}
     {e_{1} + e_{2} : Any} \; (\textit{T-ARITH3})
\]

\[
\frac{e_{1}:String \;\;\; e_{2}:String}
     {e_{1} \; {..} \; e_{2} : String} \; (\textit{T-CONCAT1})
\]

\[
\frac{e_{1}:Any}
     {e_{1} \; {..} \; e_{2} : Any} \; (\textit{T-CONCAT2})
\]

\[
\frac{e_{2}:Any}
     {e_{1} \; {..} \; e_{2} : Any} \; (\textit{T-CONCAT3})
\]

\[
\frac{e_{1}:T_{1} \;\;\; e_{2}:T_{2}}
     {e_{1} == e_{2} : Boolean} \; (\textit{T-EQUAL})
\]

\[
\frac{e_{1}:Number \;\;\; e_{2}:Number}
     {e_{1} < e_{2} : Boolean} \; (\textit{T-ORDER1})
\]

\[
\frac{e_{1}:String \;\;\; e_{2}:String}
     {e_{1} < e_{2} : Boolean} \; (\textit{T-ORDER2})
\]

\[
\frac{e_{1}:Any}
     {e_{1} < e_{2} : Boolean} \; (\textit{T-ORDER3})
\]

\[
\frac{e_{2}:Any}
     {e_{1} < e_{2} : Boolean} \; (\textit{T-ORDER4})
\]

\[
\frac{e_{1}:T_{1} \;\;\; e_{2}:T_{2}}
     {e_{1} \; \textbf{and} \; e_{2} : T_{1} \cup T_{2}} \; (\textit{T-AND})
\]

\[
\frac{e_{1}:T_{1} \;\;\; e_{2}:T_{2}}
     {e_{1} \; \textbf{or} \; e_{2} : T_{1} \cup T_{2}} \; (\textit{T-OR})
\]

\[
\frac{e:T}
     {\textbf{not} \; e : Boolean} \; (\textit{T-NOT})
\]

\[
\frac{e:Number}
     {- \; e : Number} \; (\textit{T-MINUS1})
\]

\[
\frac{e:Any}
     {- \; e : Any} \; (\textit{T-MINUS2})
\]

\[
\frac{e : String}
     {\# \; e : Number} \; (\textit{T-LEN1})
\]

\[
\frac{e : Any}
     {\# \; e : Any} \; (\textit{T-LEN2})
\]

\end{document}
