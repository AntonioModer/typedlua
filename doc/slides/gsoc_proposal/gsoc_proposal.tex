\documentclass{beamer}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{beamerthemesplit}

\begin{document}

\title{Typed Lua}
\subtitle{Google Summer of Code Proposal}
\author{Andr√© Murbach Maidl}
\institute[PUC-Rio]{LabLua\\PUC-Rio}
\date{}

\frame{\titlepage}

\section{Static Typing versus Dynamic Typing}
\begin{frame}
\frametitle{Static Typing versus Dynamic Typing}
\begin{itemize}
\item Static Typing
\begin{itemize}
\item Better documentation
\item Error detection at compile time
\item More efficient program execution
\end{itemize}
\item Dynamic Typing
\begin{itemize}
\item Faster adaptation to changing requirements
\item Quicker development
\end{itemize}
\end{itemize}
\end{frame}

\subsection{Multiple languages to build large softwares}
\begin{frame}
\frametitle{Multiple languages to build large softwares}
\begin{itemize}
\item Prototype using a dynamically typed language
\item Rewrite it in a statically typed language
\end{itemize}
\end{frame}

\section{Gradual Typing}
\begin{frame}
\frametitle{Gradual Typing}
\begin{itemize}
\item The choice between static and dynamic typing in the same language
\item Use type annotations where static typing is needed
\item Avoid type annotations where dynamic typing is sufficient
\end{itemize}
\end{frame}

\subsection{The levels of Gradual Typing}
\begin{frame}
\frametitle{The levels of Gradual Typing}
\begin{itemize}
\item The programmer can gradually migrate to static typing
\item Specially in module boundaries
\begin{enumerate}
\item The programmer write modules that use only dynamic typing.
\item The programmer creates an interface to type a module that
is written using only dynamic typing. This module is not
type checked, but their code that use this module is.
\item The programmer write modules that use only static typing.
\end{enumerate}
\end{itemize}
\end{frame}

\subsection{Gradual Typing and Dynamically Typed Languages}
\begin{frame}
\frametitle{Gradual Typing and Dynamically Typed Languages}
\begin{itemize}
\item Dart and TypeScript
\begin{itemize}
\item New languages derived from JavaScript
\item Both target JavaScript
\item Both are designed with a gradual type system
\end{itemize}
\item Typed Racket and core.typed
\begin{itemize}
\item Gradual typing extensions to Racket and Clojure
\end{itemize}
\item Perl 6
\begin{itemize}
\item Not compatible with Perl 5
\end{itemize}
\item Python
\begin{itemize}
\item gradual (package)
\item Runtime type checking semantics of gradual typing
\item Works only on Python 3
\end{itemize}
\end{itemize}
\end{frame}

\section{Typed Lua}
\begin{frame}
\frametitle{Typed Lua}
\begin{itemize}
\item A proposal to design a gradual type system for Lua
\begin{itemize}
\item Should be simple enough to preserve existing Lua idioms
\end{itemize}
\item A superset of Lua
\begin{itemize}
\item Type annotations
\item Compile-time type checking
\item Classes
\item Interfaces
\item Modules
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Typed Lua}
\begin{itemize}
\item Lua versus modules and OO programming
\begin{itemize}
\item It is possible to split Lua code into modules
\item It is possible to write OO code in Lua
\item Lua does not set policies on how these features should behave
\item Probably due to its use as an embedded and extension language
\end{itemize}
\item Typed Lua intended use is as an application language
\item So the policies for modules and OO programming should be
part of the language
\item The gradual type system helps to enforce these policies
\end{itemize}
\end{frame}

\subsection{Related Work}
\begin{frame}
\frametitle{Related Work}
\begin{itemize}
\item Some Lua projects implement parts of what is being proposed
\item None implement type checking along with OO programming
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{LuaInspect}
\begin{itemize}
\item A tool that performs code analysis
\item For instance, flagging undeclared identifiers
\item It does not try to analyze OO code
\item It does not perform type checking
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{MetaLua and MoonScript}
\begin{itemize}
\item Both support some sort of OO programming
\item Both do not perform type checking
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Tidal Lock}
\begin{itemize}
\item A prototype of a gradual type system for Lua
\item It is not typing the common OO idioms used by Lua programmers
\end{itemize}
\end{frame}

\subsection{Some Statistics}
\begin{frame}
\frametitle{Some Statistics}
\begin{itemize}
\item Data from LuaRocks repository as of June 10th
\item LuaRocks repository contains 2950 .lua files
\item \textbf{luac} (version 5.2.2) compiles 2864 of the 2950 files
\item We have 2069 files when we ignore files that are generated by
MoonScript and documentation and test subdirectories
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Function declaration}
\begin{itemize}
\item 18864 functions are being declared
\begin{itemize}
\item 4127 (21.9\%) are actually methods
\item 1586 (8.4\%) use \textbf{type} to inspect the tags of the arguments
\item 771 (4.1\%) return \textbf{nil} plus something else
\item 119 (0.6\%) return \textbf{false} plus something else
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Metatables}
\begin{itemize}
\item 18864 functions are being declared
\begin{itemize}
\item 549 (2.9\%) use \textbf{setmetatable}
\item 175 (0.9\%) use \textbf{getmetatable}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Table constructor}
\begin{itemize}
\item The table constructor is being used 19049 times
\begin{itemize}
\item 4571 (24.00\%) times is the empty construct
\item 14475 (75.99\%) times is a constructor with only static keys
\item 3 (0.01\%) times is a constructor with only dynamic keys
\item There is no constructor with static and dynamic keys
\end{itemize}
\end{itemize}
\end{frame}

\end{document}
