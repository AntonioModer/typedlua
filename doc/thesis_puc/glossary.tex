Should we include Strongtalk, Dart, TypeScript, etc?
\begin{description}
\item[abstract syntax] TO DO.
\item[application language] TO DO.
\item[arity mismatch] TO DO.
\item[assertion] TO DO.
\item[associative array] TO DO.
\item[axiom] TO DO.
\item[blame annotation] TO DO.
\item[blame calculus] TO DO.
\item[bottom type] TO DO.
\item[brand] TO DO.
\item[bug] TO DO.
\item[coercion] TO DO.
\item[concrete syntax] TO DO.
\item[consistency] TO DO.
\item[consistent-subtyping] TO DO.
\item[contract] TO DO.
\item[contravariant] TO DO.
\item[covariant] TO DO.
\item[deduction system] TO DO.
\item[dependent type] TO DO.
\item[deployment] TO DO.
\item[depth subtyping] TO DO.
\item[downcast] TO DO.
\item[dynamic type] TO DO.
\item[dynamic typing] TO DO.
\item[dynamically typed language] TO DO.
\item[effect system] TO DO.
\item[first-class function] TO DO.
\item[first-level type] TO DO.
\item[flow typing] TO DO.
\item[format string] TO DO.
\item[free assigned variable] TO DO.
\item[global type inference] TO DO.
\item[gradual type system] TO DO.
\item[gradual typing] TO DO.
\item[higher-order function] TO DO.
\item[hybrid type checking] TO DO.
\item[immutable field] TO DO.
\item[imperative language] TO DO.
\item[inheritance] TO DO.
\item[invariant] TO DO.
\item[lambda calculus] TO DO.
\item[lexical scope] TO DO.
\item[local type inference] TO DO.
\item[metaprogramming] TO DO.
\item[metatable] TO DO.
\item[mutable field] TO DO.
\item[nilable] TO DO.
\item[nominal type system] TO DO.
\item[objetc-oriented language] TO DO.
\item[occurence typing] TO DO.
\item[operator overloading] TO DO.
\item[optional type system] TO DO.
\item[optional typing] TO DO.
\item[overloading] TO DO.
\item[parametric polymorphism] TO DO.
\item[partial auxiliary function] TO DO.
\item[pattern matching] TO DO.
\item[polymorphism] TO DO.
\item[projection environment] TO DO.
\item[projection type] TO DO.
\item[prototype object] TO DO.
\item[quasi-static type system] TO DO.
\item[receiver] TO DO.
\item[referenced variable] TO DO.
\item[refinement type] TO DO.
\item[reflection] TO DO.
\item[run-time check] TO DO.
\item[scope] TO DO.
\item[script] TO DO.
\item[scripting language] TO DO.
\item[second-level type] TO DO.
\item[self] TO DO.
\item[self-like delegation] TO DO.
\item[simpy typed lambda calculus] TO DO.
\item[single inheritance] TO DO.
\item[soft typing] TO DO.
\item[sound] TO DO.
\item[static analysis] TO DO.
\item[static typing] TO DO.
\item[statically typed language] TO DO.
\item[structural type system] TO DO.
\item[subtype] TO DO.
\item[subtyping] TO DO.
\item[supertype] TO DO.
\item[table constructor] TO DO.
\item[table refinement] TO DO.
\item[top type] TO DO.
\item[type] TO DO.
\item[type alias] TO DO.
\item[type annotation] TO DO.
\item[type cast] TO DO.
\item[type checker] TO DO.
\item[type checking] TO DO.
\item[type environment] TO DO.
\item[type error] TO DO.
\item[type inference] TO DO.
\item[type parameter] TO DO.
\item[type predicates] TO DO.
\item[type refinement] TO DO.
\item[type safety] TO DO.
\item[type system] TO DO.
\item[type tag] TO DO.
\item[typed lambda calculus] TO DO.
\item[typing relation] TO DO.
\item[unsound] TO DO.
\item[untyped lambda calculus] TO DO.
\item[upcast] TO DO.
\item[userdata] TO DO.
\item[vararg expression] TO DO.
\item[variadic function] TO DO.
\item[variance] TO DO.
\item[width subtyping] TO DO.
\end{description}
