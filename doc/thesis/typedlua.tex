Typed Lua is an optional type system for Lua, and its main goal is to
allow programmers to combine static and dynamic typing in Lua.
In practice, Typed Lua extends the syntax of Lua to introduce
optional type annotations.
In addition, Typed Lua performs local type inference \citep{pierce2000lti}
to detect more precise types for unannotated expressions.
Even though the compiler warns the programmer about type errors,
it always removes the type annotations to generate Lua code that
runs in unmodified Lua implementations.

An important feature of Typed Lua is its backwards compatibility with Lua,
that is, unannotated Typed Lua code is valid Lua code.
For this reason, the syntactic extensions introduced by Typed Lua
include new keywords that are not reserved words.
Appendix \ref{app:syntax} presents the complete syntax of Typed Lua
in extended BNF.

Another important feature of Typed Lua is its interface between
statically and dynamically typed modules.
This means that the programmer can enjoy some of the benefits of
static types even without converting existing Lua modules to Typed Lua,
as a dynamically typed module can export a statically typed interface,
and statically typed users of the module have their use of the module
checked by the compiler.

We use the consistent-subtyping relation of gradual typing
\citep{siek2007objects,siek2013mutable} to formalize Typed Lua,
though it does not insert run-time checks in the gradual typing style.
In gradual typing, run-time checks inspect the interaction between
dynamically typed and statically typed code to guarantee that dynamically
typed code does not violate statically typed code during run-time.
A good reason for not inserting run-time checks at this moment is that they
can decrease run-time performance \citep{allende2013cis}, and we believe that
a careful evaluation of run-time checks should be done before inserting them
on the type system.

Unlike Dart \citep{dart} and TypeScript \citep{typescript},
we are designing Typed Lua aiming soundness to make it possible to switch
Typed Lua from optional typing to gradual typing in the future,
as a sound type system is a prerequisite to make Typed Lua insert
run-time checks after static type checking.

In this chapter we use some examples of Typed Lua code to show how
they relate to Lua.
This examples shall give an informal overview of our optional type system.
We use typing rules to present the formalization of our optional type system
in Chapter \ref{chap:system}.
It worth mentioning that we used our implementation to produce and
test all the examples that we present along this section.

\section{Optional type annotations}
\label{sec:optann}

Lua values can have one of eight tags:
\emph{nil}, \emph{boolean}, \emph{number}, \emph{string},
\emph{function}, \emph{table}, \emph{userdata}, and \emph{thread}.
Typed Lua includes types for the first six.
Typed Lua also includes a syntactical extension that programmers can use
to define the types of \emph{userdata}, and uses it to define the type \emph{thread}. 
In this section, we present the Typed Lua types that may appear on annotations.
We explain all Typed Lua types and syntactical extensions along this chapter.

\begin{figure}[!ht]
\textbf{Types}\\
\dstart
\begin{align*}
\textit{type} & ::= \; \textit{primarytype} \; [\texttt{`?'}]\\
\textit{primarytype} & ::= \; \textit{literaltype} \; | \;
  \textit{basetype} \; | \;
  \textbf{nil} \; | \;
  \textbf{value} \; | \;
  \textbf{any} \; | \;
  \textbf{self} \; | \;
  \textit{Name}\\
& | \; \textit{functiontype} \; | \;
  \textit{tabletype} \; | \;
  \textit{primarytype} \; \texttt{`|'} \; \textit{primarytype}\\
\textit{literaltype} & ::= \; \textbf{false} \; | \;
  \textbf{true} \; | \;
  \textit{Int} \; | \;
  \textit{Float} \; | \;
  \textit{String}\\
\textit{basetype} & ::= \; \textbf{boolean} \; | \;
  \textbf{integer} \; | \;
  \textbf{number} \; | \;
  \textbf{string}\\
\textit{functiontype} & ::= \; \textit{tupletype} \; \texttt{`->'} \; \textit{rettupletype}\\
\textit{methodtype} & ::= \; \textit{tupletype} \; \texttt{`=>'} \; \textit{rettupletype}\\
\textit{tabletype} & ::= \; \texttt{`\{'} \; [\textit{tabletypebody}] \; \texttt{`\}'}\\
\textit{tupletype} & ::= \; \texttt{`('} \; [typelist] \; \texttt{`)'}\\
\textit{typelist} & ::= \; \textit{type} \; \{\texttt{`,'} \; \textit{type}\} \; [\texttt{`*'}]\\
\textit{rettupletype} & ::= \; \textit{unionlist} \; [\texttt{`?'}]\\
\textit{unionlist} & ::= \; \textit{tupletype} \; | \;
  \textit{unionlist} \; \texttt{`|'} \; \textit{unionlist}\\
\textit{tabletypebody} & ::= \; \textit{type} \; | \; \textit{fieldtypelist}\\
\textit{fieldtypelist} & ::= \; [\textbf{const}] \; \textit{fieldtype} \; \{\texttt{`,'} \; [\textbf{const}] \; \textit{fieldtype}\}\\ 
\textit{fieldtype} & ::= \; \textit{keytype} \; \texttt{`:'} \; \textit{type}\\
\textit{keytype} & ::= \; \textit{literaltype} \; | \;
  \textit{basetype} \; | \;
  \textbf{value} \; | \;
  \textbf{any}\\
\textit{rettype} & ::= \; \textit{type} \; | \; \textit{rettupletype}
\end{align*}
\dend
\caption{The concrete syntax of Typed Lua types}
\label{fig:types}
\end{figure}

Figure \ref{fig:types} presents the concrete syntax of the
Typed Lua types in extended BNF.
We classify Typed Lua types into two categories:
\emph{first-level types} and \emph{second-level types}.
First-level types consist of \emph{type} and represent Lua values,
while second-level types consist of either \emph{tupletype} or
\emph{rettype} and represent the type of expression lists,
multiple assignments, and function applications.
First-level types include literal types, base types, the type \texttt{nil},
the top type \texttt{value}, the dynamic type \texttt{any},
the self type \texttt{self}, named types, function types, table types,
and union types.
Second-level types include the type void \texttt{()},
vararg types, tuple types, and union of tuple types.

Typed Lua uses subtyping to order types.
Any first-level type is a subtype of \texttt{value}.
The rest of the subtyping relationship is standard:
union types are supertypes of their parts,
\texttt{boolean}, \texttt{integer}, \texttt{number}, and \texttt{string}
are supertypes of their respective literal types,
\texttt{integer} is subtype of \texttt{number},
function types are related by contravariance on the input
and covariance on the output, table types have width subtyping,
with depth subtyping on \texttt{const} fields, tuple and vararg types
are covariant.

Typed Lua uses consistent-subtyping to check the interaction among the
dynamic type \texttt{any} and other types.
The dynamic type \texttt{any} is a subtype of \texttt{value}, but neither
a supertype nor a subtype of any other type.
Our consistent-subtyping relationship follows the standards defined
by the gradual typing of objects \citep{siek2007objects,siek2013mutable}.
In practice, we can pass a value of the dynamic type anytime we want
a value of some other type, and can pass any value where a
value of the dynamic type is expected, but the compiler tracks these
operations, and the programmer can choose to be warned about them.

Typed Lua allows optional type annotations in variable and function
declarations.
Whenever it is possible to use local type inference, the compiler
assigns a more specific type to an unannotated declaration.
When it is not possible to use local type inference, the compiler
assigns the type \texttt{any} to an unannotated declaration.
For instance, in function declarations, the compiler does not infer
a more specific type to unannotated input parameters, because,
in this case, global type inference often is undecidable in a
language with subtyping and overloading \citep{wells1999typability}.

In the following example, we use type annotations in a function
declaration, and we do not use type annotations in a declaration of a
local variable:
\begin{verbatim}
    local function factorial (n:integer):integer
      if n == 0 then
        return 1
      else
        return n * factorial(n - 1)
      end
    end
    local x = 5
    print(factorial(x))
\end{verbatim}

Even though we did not add type annotations in the declaration of
the local variable \texttt{x}, the compiler uses local type inference to
assign the type \texttt{integer} to \texttt{x}, and this example compiles
without any errors.
The compiler does not use the literal type \texttt{5},
instead of the base type \texttt{integer}, because this would prevent
programmers from assigning other integer values to the variable
\texttt{x}.
The inference that we implement in Typed Lua is quite simple, as it
uses only the type of the local expression.

Typed Lua allows programmers to combine statically typed code with
dynamically typed code, as we show in the following example:
\begin{verbatim}
    local function absolute (n:integer):integer
      if n < 0 then
        return -n
      else
        return n
      end
    end

    local function distance (x, y)
      return abs(x - y)
    end
\end{verbatim}

The function \texttt{distance} receives two parameters of type \texttt{any}
and returns a value of type \texttt{integer}.
The compiler assigns the dynamic type \texttt{any} to the input
parameters of \texttt{distance} because they do not have type annotations,
and the compiler does not use global type inference, as we mentioned
previously.
Even though we did not annotated the return type of \texttt{distance},
the compiler is able to infer its return type because it is local
and not recursive.

In this example, Typed Lua cannot guarantee that \texttt{distance} is never
going to call \texttt{absolute} with a parameter that is not an integer number,
because in the semantics of Lua the minus operator can result in a
value that is not an integer number.
More precisely, we can call \texttt{absolute} inside \texttt{distance}
because the expression \texttt{x - y} has type \texttt{any},
and it is consistent with type \texttt{integer}.
Still, the dynamic type \texttt{any} may be hiding a value of a type
that is not an integer, making the dynamically typed code crash the
statically typed code.
This is a typical example where run-time checks would ensure safety
between the interaction of dynamically typed and statically typed code.

\section{Functions}
\label{sec:func}

Lua has first-class functions, but they have some peculiarities.
First, the number of arguments of a function call does
not need to match the arity of the function declaration, as Lua silently
drops extra arguments after evaluating them, or uses \texttt{nil} to
replace missing arguments.
Second, functions can return any number of values,
and this number of returned values may not be statically known.
Third, Lua has multiple assignment, and the semantics
of argument passing is the same of the multiple assignment
(or vice-versa), that is, calling a function is like doing a
multiple assignment where the left hand side is the parameter list
and the right hand side is the argument list.

Typed Lua uses second-level types to encode function types,
and to preserve these peculiarities.
We call them second-level because these types do not correspond
to actual Lua values and we cannot use them to type variables or
parameters.
They are just an artifact of the interaction between the type system
and the semantics of Lua.

As we can see in Figure \ref{fig:types}, second-level types consist
of either \emph{tupletype} or \emph{rettupletype}.
A second-level type is the type void \texttt{()},
a tuple of first-level types optionally ending in a variadic type,
or a union of these tuples.
A variadic type \texttt{t*} is a generator for a sequence of values
of the union type \texttt{t|nil}.
Union of tuples may appear only on the return type of functions,
and together with \emph{projection types} play an important role
in functions that are overloaded on the return type.
We will explain union types and projection types in more detail
in the next section.

To match the semantics of Lua function calls, the \emph{default} operation
mode of Typed Lua adds a variadic tail to the parts of a function
type whenever the programmer does not specify one.
In the previous examples, the type of both \texttt{factorial} and
\texttt{absolute} is \texttt{(integer, value*) -> (integer, nil*)},
and the type of \texttt{distance} is \texttt{(any, any, value*) -> (integer, nil*)}.
If we call \texttt{absolute} with extra arguments, Typed Lua silently ignores
them, as the type signature lets \texttt{absolute} receive any number of
extra arguments.
If we call \texttt{absolute} with fewer arguments, Typed Lua uses \texttt{nil} to
replace the missing arguments and in the case of \texttt{absolute} generates
an error, as \texttt{nil} is neither a subtype of \texttt{integer} nor consistent
with \texttt{integer}.

Typed Lua also provides a \emph{strict} operation mode, and programmers can
use this mode if they want to catch arity mismatch of function calls.
In the strict mode, Typed Lua does not add a variadic tail to the
parts of a function type unless the programmer explicitly declares one.
In the previous examples, the type of both \texttt{factorial} and
\texttt{absolute} is \texttt{(integer) -> (integer)},
and the type of \texttt{distance} is \texttt{(any, any) -> (integer)}.
If we call \texttt{absolute} with either extra or missing arguments,
Typed Lua generates errors about arity mismatch.

A variadic type can only appear in the tail position of a tuple,
because Lua takes only the first value of any expression that appears
in an expression list that is not in tail position.
The following example shows the interaction between multiple returns
and expression lists:
\begin{verbatim}
    local function multiple ()
      return 2, "foo"
    end
    local function sum (x:integer, y:integer)
      return x + y
    end
    local x, y, z = multiple(), multiple()
    print(sum(multiple(), multiple()))
\end{verbatim}

In the default mode, the type of \texttt{multiple} is
\texttt{(value*) -> (integer, string, nil*)},
and the type of \texttt{sum} is \texttt{(integer, integer, value*) -> (integer, nil*)}.
In the right hand side of the multiple assignment, only the first
value produced by the first call to multiple gets used,
so the type of the right hand side is
\texttt{(integer, integer, string, nil*)},
and the type assigned to \texttt{x}, \texttt{y}, and \texttt{z}
are respectively \texttt{integer}, \texttt{integer}, and \texttt{string}.
The same tuple is assigned to the call to \texttt{sum} and it
compiles without errors, as the first two components of the tuple
are consistent with the types of the parameters, and the other
components are consistent with \texttt{value}.

In the strict mode, the type of \texttt{multiple} is \texttt{() -> (integer, string)},
and the type of \texttt{sum} is \texttt{(integer, integer) -> (integer)}.
Like in the default mode, only the first value produced by the
first call to multiple gets used in the right hand side of the
multiple assignment;
and the type of the right hand side is also
\texttt{(integer, integer, string, nil*)},
because the strict mode affects only the type of function declarations
and multiple assignments that appear in function calls.
Unlike in the default mode, the type of the call to \texttt{sum} is
\texttt{(integer, integer, string)}, and does not include the
variadic tail to catch arity mismatch.
Thus, this example compiles with error because the call to \texttt{sum}
passes an unexpected extra argument of type \texttt{string}.

\section{Unions}
\label{sec:unions}

Typed Lua includes union types to encode three common Lua idioms:
the use of optional values, the overloading based on the tags of
input parameters, and the overloading on the return type of functions.

Optional values are unions of some type \texttt{t} and \texttt{nil},
and Typed Lua includes the syntactic sugar \texttt{t?} to represent
them because they appear quite often.
The concrete syntax \texttt{t?} is syntactic sugar for \texttt{t|nil}.
Optional values can appear when a function has optional parameters
and when the program reads a value from an array or a map.
The following example shows a function that has an optional parameter:
\begin{verbatim}
    local function message (name:string, greeting:string?)
      local greeting = greeting or "Hello "
      return greeting .. name
    end

    print(message("Typed Lua"))         -- Typed Lua
    print(message("Typed Lua", "Hi "))  -- Hi Typed Lua
\end{verbatim}

Although the parameter \texttt{greeting} is optional, and has type
\texttt{string|nil}, the concatenation does not generate a type error
because we used the short-circuiting \texttt{or} operator to declare a
new variable \texttt{greeting} that is guaranteed to have type \texttt{string}. 
In Lua, only the values \texttt{nil} and \texttt{false} represent a
false condition, so programmers often use the \texttt{or} operator as a
common idiom to assign a default value to an optional parameter. 
Typed Lua uses a typing rule to encode this idiom: 
if the left hand side of \texttt{or} has type \texttt{t|nil} and
the right hand side has type \texttt{t} then the \texttt{or} expression has
type \texttt{t}.

In fact, we do not need to declare a new variable \texttt{greeting} that
shadows the optional parameter:
\begin{verbatim}
    local function message (name:string, greeting:string?)
      greeting = greeting or "Hello "
      return greeting .. name
    end
\end{verbatim}

Typed Lua allows the assignment \texttt{x = x or e} to refine
the type of \texttt{x} from \texttt{t|nil} to \texttt{t}
if it matches the following restrictions: 
the type of \texttt{e} is a subtype of \texttt{t},
and the variable \texttt{x} is local to the current function
and it is not being assigned in another function.
The refinement only affects the type of \texttt{x} in the remainder
of the current scope.
In the case of \texttt{greeting}, the assignment refines its type
from \texttt{string|nil} to \texttt{string}. 

Lua programmers often overload the input parameters of functions,
and use the \texttt{type} function to inspect the tag of the
input parameters to take different actions depending on what
those tags are.
The simplest case overloads on just a single parameter:
\begin{verbatim}
    local function overload (s1:string, s2:string|integer)
      if type(s2) == "string" then
        return s1 .. s2
      else
        -- string.rep : (string, integer, string) -> (string)
        return string.rep(s1, s2)
      end
    end
\end{verbatim}

Typed Lua has a small set of \texttt{type} predicates that allows
programmers to constrain the type of a local variable inside a condition.
This example uses the \texttt{type(x) == "string"} predicate that
constrains the type of \texttt{x} from \texttt{t|string} to
\texttt{string} when the predicate is true and \texttt{t} otherwise.
This is a simplified form of \emph{flow typing} \citep{guha2011tlc,tobin-hochstadt2010ltu}.
As with \texttt{or}, the variable must be local to the function
and it is not being assigned in another function.

The \texttt{type} predicates can only discriminate based on tags,
so they are limited on the kinds of unions that they can discriminate.
For instance, the predicates can discriminate a union that combines
a table type with a base type, or a table type with a function type,
or two base types, but they cannot discriminate a union that combines
two different table types, or two different function types.

Lua programmers also overload the return type of functions,
usually for signaling the occurrence of errors.
In this idiom, a function returns its normal set of return values
when it successfully finished its execution,
and usually returns \texttt{nil} as the first value plus an
error message or other data that describes the error
when something failed during its execution.
Next, we show an example:
\begin{verbatim}
    local function idiv (dividend:integer, divisor:integer):
          (integer, integer)|(nil, string)
      if divisor == 0 then
        return nil, "division by zero"
      else
        local r = dividend % divisor
        local q = (dividend - r) / divisor
        return q, r
      end 
    end
\end{verbatim}

Typed Lua also includes a syntactic sugar for this idiom:
we can annotate the return type of \texttt{idiv} with
\texttt{(integer, integer)?} to denote the same union.
The parentheses are always necessary in this case, because
\texttt{t?} is syntactic sugar for \texttt{t|nil},
while \texttt{(t)?} is syntactic sugar for \texttt{(t)|(nil, string)}.

A typical client of this function would use it as follows:
\begin{verbatim}
    local q, r = idiv(a, b)
    if q then
      print(a == b * q + r)
    else
      print("ERROR: " .. r)
    end
\end{verbatim}

When Typed Lua finds a union of tuples in the right hand side of
a declaration, it stores this union in a special type environment
with a fresh name and assigns \emph{projection types} to the
variables that appear unannotated in the left hand side of the declaration.
In our example, Typed Lua assigns the union of tuples
\texttt{(integer, integer, nil*)|(nil, string, nil*)} to a type variable $X$.
Thus, variable \texttt{q} gets the type $X_{1}$
that is equivalent to the type \texttt{integer|nil},
and variable \texttt{r} gets the type $X_{2}$
that is equivalent to the type \texttt{integer|string}.

Projection types do not appear in the subtyping and consistent-subtyping
relations because Typed Lua actually replaces them with the union of the
corresponding component of each tuple.
If a variable with a projection type appears in a \texttt{type} predicate,
it discriminates against all tuples in the union.
In our example, $X$ is \texttt{(integer, integer, nil*)|(nil, string, nil*)}
outside of the \texttt{if} statement,
but \texttt{(integer, integer, nil*)} inside the \texttt{then} block,
and \texttt{(nil, string, nil*)} inside the \texttt{else} block.
Thus, variable \texttt{q} has type \texttt{integer} and variable \texttt{r} also
has type \texttt{integer} inside the \texttt{then} block;
and variable \texttt{q} has type \texttt{nil} while variable \texttt{r}
has type \texttt{string} inside the \texttt{else} block.

We could also have used \texttt{type(q) == "number"} or
even \texttt{type(r) == "number"} as the predicate of our example,
as both predicates would produce the same result.
However, the form that appears in our example is much more succinct and idiomatic.

Typed Lua does not allow assignments to variables that hold a projection type,
unless the union has been discriminated down to a single value.
Unrestricted assignment to these variables would be unsound,
as it could break the dependency relation among the types in each tuple
that is part of the union.

The overloading mechanism of Typed Lua have a limitation:
the return type cannot depend on the input type.
Next, we show an example:
\begin{verbatim}
    local function limitation (x:number|string, y:number|string)
      if type(x) == "number" then
        if type(y) == "number" then
          return x + y
        end
      else
        if type(y) == "string" then
          return x .. y
        end
      end
    end
\end{verbatim}

This example shows that we cannot write a function that is
guaranteed to return a number when we pass two numbers and
guaranteed to return a string when we pass two strings.
Even though we could use intersection types to express the type
of this function as
\texttt{(number, number) -> (number) \string&
(string, string) -> (string)},
and therefore solve this limitation,
intersection types require more sophisticated flow typing to
check whether a function has this type,
and we still need to work on this problem.

\section{Tables and Interfaces}
\label{sec:tables}

Tables are the only mechanism that Lua has to build data structures;
they are associative arrays where any value (except \texttt{nil})
can be used as a key.
Programmers can use tables to represent tuples, arrays (dense or sparse),
records, graphs, modules, objects, etc.
Lua has syntactic sugar for indexing tables as records:
\texttt{t.k} is syntactic sugar for \texttt{t["k"]}, and means that
we are accessing the field \texttt{k} from table \texttt{t}. 
In this section, we show how Typed Lua encodes tables as maps,
arrays, and records.

Table types are the only framework that Typed Lua has to represent
the different uses that a Lua table has.
A table type $\texttt{\{k}{_\texttt{1}}\texttt{:t}_{\texttt{1}}
\texttt{, ..., k}{_\texttt{n}}\texttt{:t}_{\texttt{n}}\texttt{\}}$ represents a map
from values of type $\texttt{k}_{\texttt{i}}$ to values of type
$\texttt{t}_{\texttt{i}}$.

Although Typed Lua has just one framework to represent tables,
it has three different syntaxes for defining the type of a table:
\begin{align}
\label{syn:table1}
\texttt{`\{'} \; \textit{keytype} \; \texttt{`:'} \; \textit{type} \; \texttt{`\}'}\\
\label{syn:table2}
\texttt{`\{'} \; \textit{type} \; \texttt{`\}'}\\
\label{syn:table3}
\texttt{`\{'} \; \textit{literaltype} \; \texttt{`:'} \; \textit{type} \;
\{\texttt{`,'} \; \textit{literaltype} \; \texttt{`:'} \; \textit{type}\} \;
[\texttt{`,'} \; \textit{type}] \; \texttt{`\}'}
\end{align}
The syntax \ref{syn:table1} defines table types for maps:
it is written \texttt{\{k:t\}},
and maps to the table type \texttt{\{k:t|nil\}}.
This table type represents a map that maps values of type
\texttt{k} to values of type \texttt{t|nil},
as Lua returns \texttt{nil} when we use a non-existing key to index a table.
The syntax \ref{syn:table2} defines table types for arrays:
it is written \texttt{\{t\}},
and maps to the table type \texttt{\{integer:t|nil\}}.
This table type is just a syntactic sugar to the definition of a
map that maps values of type \texttt{integer} to values of type \texttt{t|nil}.
The syntax \ref{syn:table3} defines table types for records with an
optional array part: it is written
$\texttt{\{l}{_\texttt{1}}\texttt{:t}_{\texttt{1}}
\texttt{, ..., l}{_\texttt{n}}\texttt{:t}_{\texttt{n}}\texttt{\}}$,
and maps to the same table type.
This table type represents a record that maps the literal types
$\texttt{l}_{\texttt{i}}$\texttt{, ..., }$\texttt{l}_{\texttt{n}}$
to values of types $\texttt{t}_{\texttt{i}}$\texttt{, ..., }$\texttt{t}_{\texttt{n}}$.

Next, we show one example of table type to type a map from strings to integers:
\begin{verbatim}
    local t:{string:integer} = { foo = 1 } 
    local x:integer = t.foo               -- compile-time error
    local y:integer? = t.bar              -- y gets nil
    local z:integer = t["bar"] or 0       -- z gets 0 
\end{verbatim}

The second line of this example gives a type error because we are
attempting to assign a value of type \texttt{integer|nil} to a
variable that accepts only values of type \texttt{integer}.
Although the field \texttt{bar} does not exist in \texttt{t}, the third
line of this example does not give a type error because the
annotated type matches the type of the values that can be stored in
\texttt{t}.
The last line shows that the \texttt{or} idiom is also useful to
give a default value to a missing table field.

Next, we show one example of table type to type an array:
\begin{verbatim}
    local days:{string} = { "Sunday", "Monday", "Tuesday",
                            "Wednesday", "Thursday", "Friday",
                            "Saturday" }
    local x = days[1]                    -- x gets "Sunday"
    local y = days[8]                    -- y gets nil
\end{verbatim}

In this example, the type of both variables \texttt{x} and \texttt{y}
is \texttt{string|nil}.
An inconvenient aspect of making the types of maps and arrays always
include the type \texttt{nil} is to overload the programmers,
as they need to use \texttt{or} or \texttt{if} to narrow the type of
the elements they are accessing. 

When we know that a list has fixed elements, we can leave the
variable declaration unannotated and let local type inference assign
a more specific table type to the variable.
If we remove the annotation in this example, the compiler uses the
syntax of records to infer the following table type to \texttt{days}:
\texttt{\{1:string, 2:string, 3:string, 4:string, 5:string, 6:string, 7:string\}}.

When we use the inferred table type while initializing a table, the
compiler gives an error message when we try to access an index that
is out of bounds.

We can also use the style of the inferred type to define heterogeneous
tuples:
\begin{verbatim}
    local album:{1:string, 2:integer, 3:string} =
      { "Transformer", 1972, "Lou Reed" }
\end{verbatim}

The next example shows how we can annotate a \texttt{map} function
that receives another function as its parameter and uses this
function to alter the elements of a list of numbers, which is
also a parameter of \texttt{map}:
\begin{verbatim}
    local function map (f:(number)->(number), l:{number})
      for i = 1, #l do
        l[i] = f(l[i] or 0)
      end
    end
\end{verbatim}

Next, we show one example of table type to type a record:
\begin{verbatim}
    local person:{"firstname":string, "lastname":string} =
      { firstname = "Lou", lastname = "Reed" } 
\end{verbatim}

Type inference would infer the very same table type that we used to
annotate the variable \texttt{person}.

Typed Lua includes \emph{interfaces} as syntactic sugar to table types
that specify records, as writing table types can be unwieldy when
records get bigger and types of record fields get more complicated.
For instance, we can use the following interface as an alias to the
type of the record we showed in the previous example:
\begin{verbatim}
    local interface Person
      firstname:string
      lastname:string
    end
\end{verbatim}

The declaration of the interface \texttt{Person} is an alias to the
table type \texttt{\{"firstname":string, "lastname":string\}} in the
remainder of the current scope.
Now we can use \texttt{Person} in type declarations:
\begin{verbatim}
    local function byebye (person:Person):string
      return "Goodbye " .. person.firstname ..
             " " .. person.lastname
    end

    local user1 = { firstname = "Lewis",
                    middlename = "Allan",
                    lastname = "Reed" }
    local user2 = { firstname = "Lou" }
    local user3 = { lastname = "Reed",
                    firstname = "Lou" }
    local user4 = { "Lou", "Reed" }

    print(greeter(user1)) -- Goodbye Lewis Reed 
    print(greeter(user2)) -- compile-time error
    print(greeter(user3)) -- Goodbye Lou Reed
    print(greeter(user4)) -- compile-time error
\end{verbatim}

This example shows that our optional type system is structural rather
than nominal, that is, it checks the structure of types instead of
their names, and it uses subtyping and consistent-subtyping for
checking types.

If our record type has optional fields, that is, fields that can be \texttt{nil},
we need to use an explicit type declaration when declaring a
variable of this record type, as we show in the following example:
\begin{verbatim}
    local interface Person
      firstname:string
      middlename:string?
      lastname:string
    end
    local user1:Person = { firstname = "Lewis",
                           middlename = "Allan",
                           lastname = "Reed" }
    local user2:Person = { lastname = "Reed",
                           firstname = "Lou" }
\end{verbatim}

We need an explicit type declaration because neither of the types
that the Typed Lua compiler assigns to the above table constructors
is a subtype of
\texttt{\{"firstname":string, "middlename":string|nil, "lastname":string\}},
the type that \texttt{Person} describes.

We can also use interfaces to define recursive types such as liked lists:

\begin{verbatim}
    local interface Element
      info:integer
      next:Element?
    end
\end{verbatim}

We need to explicitly annotate \texttt{next} being of type
\texttt{Element|nil} because in our type system \texttt{nil}
is not the bottom type, that is, \texttt{nil} is subtype of itself only.
Typed Lua has this behavior because in Lua \texttt{nil} represents
the absence of an useful value.
Thus, making \texttt{nil} the bottom type would severally reduce the amount
of type safety in the system.

Now we can use \texttt{Element} to annotate a function that
inserts an element at the beginning of a list:
\begin{verbatim}
    local function insert (e:Element?, v:integer):Element 
      return { info = v, next = e }
    end
\end{verbatim}

We need an explicit type declaration on the return type because
the Typed Lua compiler cannot infer recursive types, though
it has subtyping rules to check that the inferred return type
matches the annotation.

Now we can write a program that declares a list, inserts some
elements in this list, and then traverses the list printing
each element of the list:
\begin{verbatim}
    local l:Element?

    l = insert(l, 4)
    l = insert(l, 3)
    l = insert(l, 2)
    l = insert(l, 1)

    while l do
      if l then print(l.info) end
      l = l.next                  -- compile-time error
    end
\end{verbatim}

However, this example has one compile-time error because we
are attempting to index the variable \texttt{l},
which can be \texttt{nil}.
Notice that we would have the same compile-time error while
printing the list element if we had not narrowed the type of
\texttt{l}.
To eliminate this compile-time error we have to write a
function that narrows the type of \texttt{l} before using it:
\begin{verbatim}
    local function get_next (l:Element?)
      if l then return l.next else return nil end
    end
\end{verbatim}

Now we can use \texttt{get\string_next} to rewrite the \texttt{while}
from the previous example, thus eliminating the compile-time error:
\begin{verbatim}
    while l do
      if l then print(l.info) end
      l = get_next(l)
    end
\end{verbatim}

Lua programmers often build records incrementally, that is,
they usually declares a local variable with an empty table,
and then use assignment to add fields to this table:
\begin{verbatim}
    local person = {}
    person.firstname = "Lou"
    person.lastname = "Reed"
    print("bye bye " .. person.firstname)  -- bye bye Lou
\end{verbatim}

In this example, we want to refine the type of \texttt{person} as
we build the table:
starting with \texttt{\{\}}, and then refining to \texttt{\{"firstname":string\}},
and finally reaching \texttt{\{"firstname":string, "lastname":string\}}.
This type change is trickier than the one that we introduced for narrowing
union types, as we are not just allowing the programmer to change
the type of the variable \texttt{person}, but we are actually allowing
the programmer to change the type of the value that \texttt{person} points to.
This type change is safe in this example, but it is not in the following one:
\begin{verbatim}
    local person = {}
    local bogus = person
    person.firstname = "Lou"
    person.lastname = "Reed"
    bogus.firstname = true               -- compile-time error
    print("bye bye " .. person.firstname)
\end{verbatim}

In this example, the fifth line is unsound because it allows the
programmer to change the type of the value that is stored in
\texttt{person.firstname}, and makes the last line crash during
run-time.
On the first line, we assign an empty table to \texttt{person}.
On the second line, we assign the type of \texttt{person} to
\texttt{bogus}.
On the third and fourth lines we change the type of \texttt{person}
as we did in the previous example.
On the fifth line we try to change the type of \texttt{bogus}
from \texttt{\{\}} to \texttt{\{"firstname":boolean\}},
but if we allow this type change we also allow changing the value
that is stored in \texttt{person.firstname}, regardless of its type.
Taking the changes individually looks fine, but the truth is that
aliasing makes one of them unsound.

The location of the change also matters, as the next example shows:
\begin{verbatim}
    local person = { lastname = "Reed" }
    local function spoil ()
      person.firstname = nil             -- compile-time error
    end
    person.firstname = "Lou"
    spoil()
    print("bye bye " .. person.firstname)
\end{verbatim}

In this example, the third line is unsound because it allows the
programmer to change the type of \texttt{person} outside of the scope
that it was declared.
The call to \texttt{spoil} erases the field \texttt{firstname} from
\texttt{person}, and makes the last line crash during run-time.

It is also not sound to allow the type of the fields to change,
as the next example shows:
\begin{verbatim}
    local person = { firstname = "Lewis", lastname = "Reed" }
    person.middlename = "Allan"
    person.firstname = 1942              -- compile-time error
    person.lastname = 2013               -- compile-time error
    print("bye bye " .. person.firstname)
\end{verbatim}

In this example, both third and fourth line are unsound because
they are trying to change the type of fields that already exist.

Typed Lua tags a variable that holds a table type as either
\emph{open} or \emph{closed}.
If a variable gets its type from a table constructor then it
is open, otherwise it is always closed.

Typed Lua uses three restrictions to decide whether it is
sound to allow field assignment to change the type of an
open variable or not:
the variable must be local to the current block,
the new type must be a subtype of the old one, and
the variable cannot have been assigned in another function.

We can create aliases to open variables, but they are always closed.
Any mutation on these aliases is not a problem, as the type of
the original reference can only change towards a subtype.
For mutable fields this means that the type of the field cannot
change after it is added to the type of the table.

Table types along with their refinement through field assignment
are the foundation for defining modules and objects in Typed Lua.
In the next section, we show that the refinement of table types
through field assignment is crucial for making Typed Lua
support idiomatic definition of Lua modules.

\section{Modules}
\label{sec:modules}

Lua does not set policies on how programmers should define modules,
but it provides mechanisms for organizing a program in modules.
To load a module, Lua first checks whether the module is already
loaded or not.
When the module is not loaded, Lua executes its source file as a
function, and the value returned by this function is the module.
Thus, Lua modules can be any Lua value.
However, our survey from Section \ref{sec:statistics} confirms that
the convention among Lua programmers is to use tables for defining modules. 
In this case, the fields of the table are the functions and other
values that the module exports.

The simplest way for defining a module in Lua is to declare an
empty table at the begin of the source file,
populate this table with the members that the module should export,
and return this table at the end of the source file. 
The following example shows how Typed Lua handles this case:
\begin{verbatim}
    local mymath = {}
    local RADIANS_PER_DEGREE = 3.14159 / 180.0
    mymath.deg = function (x:number)
      return x / RADIANS_PER_DEGREE
    end
    mymath.rad = function (x:number)
      return x * RADIANS_PER_DEGREE
    end
    mymath.pow = function (x:number, y:number)
      return x ^ y
    end
    return mymath
\end{verbatim}

In this example, Typed Lua uses the refinement of table types to
allow the programmer to incrementally build the type of the
module \texttt{mymath}.
Like in Lua, the variable \texttt{RADIANS\string_PER\string_DEGREE}
is private because we declared it as local to the module. 
The \texttt{return} at the end of the source file gives the
final type of the module \texttt{mymath}:
\begin{verbatim}
    { "deg":(number) -> (number),
      "rad":(number) -> (number),
      "pow":(number, number) -> (number) }
\end{verbatim}

Another way of defining modules in Lua is to declare only locals
in the source file, and return a table constructor that includes
the members that the module should export at the end of the source file.
The following example shows how Typed Lua handles this case:
\begin{verbatim}
    local RADIANS_PER_DEGREE = 3.14159 / 180.0
    local function deg (x:number)
      return x / RADIANS_PER_DEGREE
    end
    local function rad (x:number)
      return x * RADIANS_PER_DEGREE
    end
    local function pow (x:number, y:number)
      return x ^ y
    end
    return {
      deg = deg,
      rad = rad,
      pow = pow,
    }
\end{verbatim}

In this example, the \texttt{return} at the end of the source file
also gives the final type of the module \texttt{mymath}, which is
the same of the previous example.

There is still a third way of defining modules in Lua through the
\texttt{module} function, which has been deprecated.
In this style, the first line of the module calls \texttt{module}.
This function installs a fresh table as the global environment for
the rest of the module, so any assignments to global variables are
field assignments to this table.
The \texttt{module} function also sets an \texttt{\string_M} field
in this table as a circular reference to the table itself,
so the module can end with \texttt{return \string_M},
but this explicit return is not necessary.

Even though this style has been deprecated, our survey from
Section \ref{sec:statistics} indicated that around a third of the
Lua modules that are in LuaRocks still use this style.
Thus, Typed Lua also supports this style:
\begin{verbatim}
    module "mymath"
    local RADIANS_PER_DEGREE = 3.14159 / 180.0
    deg = function (x:number)
      return x / RADIANS_PER_DEGREE
    end
    rad = function (x:number)
      return x * RADIANS_PER_DEGREE
    end
    pow = function (x:number, y:number)
      return x ^ y
    end
\end{verbatim}

In this example, Typed Lua treats accesses to global variables as
field accesses to an open table in the top-level scope,
and at the end of file this open table gives the final type of the
module \texttt{mymath}, which is also the same of the previous two
examples.

After we define the module \texttt{mymath}, regardless of adopted style,
users can use it in the standard way:
\begin{verbatim}
    local m = require "mymath"
    print(m.pow(2, 3))                   -- 8
    print(m.pow(2, "foo"))               -- compile-time error
\end{verbatim}

And now the users of the module \texttt{mymath} have the policies that
Typed Lua provides.
The call to \texttt{require} assigns the type of the module \texttt{mymath}
to \texttt{m}, so Typed Lua can catch misuses of the module.

The way Typed Lua handles modules using table types is also
relevant for supporting object-oriented programming, as we discuss in
the next section.

\section{Object-Oriented Programming}
\label{sec:oop}

Lua provides minimal support for object-oriented programming.
The basic mechanism is the \texttt{:} syntactic sugar for method
calls and method definitions.
The Lua interpreter translates \texttt{obj:method(args)} into
an operation that first evaluates \texttt{obj}, if it is a table
Lua checks if there is field \texttt{method} in this table,
and then calls it with the result of evaluating \texttt{obj} as
the first argument, followed by the result of evaluating the
argument list in the original expression.

Typed Lua uses table types along with the self type to
represent objects, as we show in the following example:
\begin{verbatim}
    local Shape = { x = 0.0, y = 0.0 }
    const function Shape:move (dx:number, dy:number)
      self.x = self.x + dx
      self.y = self.y + dy
    end
\end{verbatim}

This example introduces some features that we must explain
before we show the type of \texttt{Shape}.
In Lua, the \texttt{:} syntactic sugar assigns a function to the
field with a first parameter named \texttt{self}, plus any other
parameters.
Typed Lua does the same, and assigns the type \texttt{self} to the
implicit parameter \texttt{self}.
Typed Lua also adds the \texttt{const} annotation because the
\texttt{const} qualifier is necessary for covariance among object types work.
Under this circumstances, the type of \texttt{Shape} is an object of
the following type:
\begin{verbatim}
    { "x":number, "y":number,
      const "move":(self, number, number) -> () }
\end{verbatim}

While \texttt{:} is syntactic sugar in plain Lua, Typed Lua uses it
to check method calls, binding any occurrence of the type \texttt{self}
in the type of the method to the receiver.
Indexing a method and not immediately calling it with the correct
receiver is a compile-time error:
\begin{verbatim}
    Shape.move(Shape, 10, 10)  -- Shape.x = 10 and Shape.y = 10
    Shape:move(5, 20)          -- Shape.x = 5 and Shape.y = 20
    local p = Shape.move       -- compile-time error
\end{verbatim}

Lua has a mechanism for self-like (or JavaScript-like) delegation of
missing fields in a table.
After the call \texttt{setmetatable(t1, \{ \string_\string_index = t2 \})},
Lua looks up in \texttt{t2} for any missing fields of \texttt{t1}.
Lua programmers often use this mechanism to simulate classes.

Typed Lua combines this mechanism along with interfaces to allow
programmers to define classes in a similar fashion to the definition
of modules, as we show in the following example:
\begin{verbatim}
    interface Shape
      x, y:number
      const new:(number, number) => (self)
      const move:(number, number) => ()
    end
    local Shape = { x = 0.0, y = 0.0 }
    const function Shape:new (x:number, y:number)
      local s = setmetatable({}, { __index = self })
      s.x = x
      s.y = y
      return s
    end
    const function Shape:move (dx:number, dy:number)
      self.x = self.x + dx
      self.y = self.y + dy
    end
    return Shape
\end{verbatim}

In Typed Lua, \texttt{setmetatable} is a strict primitive.
Typed Lua only allows calling \texttt{setmetatable} with
two operands.
The first operand can be any table \texttt{t1}, but the second operand
must be a table of the form \texttt{\{ \string_\string_index = t2 \}},
where \texttt{t2} can be any table.

The reason for being so strict with \texttt{setmetatable} is because
it is the only mechanism that Typed Lua has to create classes
as prototype objects.
In a \texttt{setmetatable} expression, if the type of \texttt{t2}
is a subtype of the type of \texttt{t1}, it changes \texttt{t1} to
have the same type of \texttt{t2}.

In our example, we use \texttt{setmetatable} to define a constructor
\texttt{new} to the class \texttt{Shape}.
The type of \texttt{new} is \texttt{(self, number, number) -> (self)},
because we use \texttt{setmetatable} to declare \texttt{s} having
the same type of \texttt{self}.

In the same example, we also declare the interface \texttt{Shape}.
Notice that we use double arrow instead of single arrow inside the
definition of the interface \texttt{Shape}.
The double arrow is syntactic sugar for defining the type of methods,
as it includes an implicit first parameter of type \texttt{self}.
The interface definition allows us to export the type of the class \texttt{Shape},
which is the same type that is given by the variable \texttt{Shape}:
\begin{verbatim}
    { "x":number, "y":number,
      const "new":(self, number, number) -> (self),
      const "move":(self, number, number) -> () }
\end{verbatim}

In Typed Lua, this style of classes definition allow us to use \texttt{require}
for creating prototype objects that work as classes,
along with a shortcut to the table type of the class.
This allows us to use this shortcut on type annotations,
as we show in the following example:
\begin{verbatim}
    local Shape = require "shape"
    local shape1 = Shape:new(0, 5)
    local shape2:Shape = Shape:new(10, 10)
\end{verbatim}

Typed Lua also uses \texttt{setmetatable} to simulate single inheritance,
as we show in the following example:

\begin{verbatim}
    local Shape = require "shape"
    interface Circle
      x, y, radius:number
      const new:(number, number, value) => (self)
      const move:(number, number) => ()
      const area:() => (number)
    end
    local Circle = setmetatable({}, { __index = Shape })
    Circle.radius = 0.0
    const function Circle:new (x:number, y:number, radius:value)
      local c = setmetatable(Shape:new(x, y), { __index = self })
      c.radius = tonumber(radius) or 0.0
      return c
    end
    const function Circle:area ()
      return math.pi * self.radius * self.radius
    end
    return Circle
\end{verbatim}

A call to \texttt{setmetatable} where \texttt{t1} is a table
constructor assigned to a fresh local variable, and \texttt{t2}
is not \texttt{self} gives this variable an open type.
That is the reason why we can add new methods and override
existing ones in \texttt{Circle}.

In this example, we also call \texttt{setmetatable} to redefine \texttt{new}.
Notice how we can call the constructor of \texttt{Shape} inside
the overridden constructor.
A limitation of this class system is that the overridden constructor
must be a subtype of the original constructor,
so the type of \texttt{radius} has to be quite permissive.

In the same example, we also declare the interface \texttt{Circle},
but with a syntactical overhead to manually include the new and
overridden methods.
The interface \texttt{Circle} exports the following type:
\begin{verbatim}
    { "x":number, "y":number, "radius":number,
      const "new":(self, number, number, value) -> (self),
      const "move":(self, number, number) -> (),
      const "radius":() -> (number) }
\end{verbatim}

This table type is a subtype of the table type exported by the interface \texttt{Shape},
and we can use both shortcuts on type annotations, as we show in the following example:
\begin{verbatim}
    local Circle = require "circle"
    local circle1 = Circle:new(0, 5, 10)
    local circle2:Circle = Circle:new(10, 10, 10)
    local circle3:Shape = circle1
    local circle4:Shape = circle2
    print(circle2:area())                -- 314.15926535898
    print(circle3:area())                -- compile-time error
\end{verbatim}

In all examples, if we erase all type and \texttt{const} annotations,
and type declarations, they become valid Lua code, which run with the
same semantics as Typed Lua code.

The current version of Typed Lua has some limitations regarding
the use of \texttt{setmetatable} that are on plans for future work.
One limitation is that Typed Lua does not have polymorphism,
so programmers cannot hide the calls to \texttt{setmetatable} behind
nicer abstractions, as some Lua libraries do.
Another limitation is that Typed Lua does not support operator overloading,
so programmers cannot use \texttt{setmetatable} to change the behavior
of predefined operations, as some Lua libraries do.

Our classes system also does not support multiple inheritance
and does not offer privacy rules, but these limitations are not
on plans for future work anyway.

\section{Description files}
\label{sec:tld}

The Typed Lua compiler also handles description files.
The programmer can use description files for two purposes:
export a statically typed interface for an existing Lua
module, without converting it to Typed Lua,
or export a statically typed interface for a Lua module
that is written in C.

\begin{figure}[!ht]
\textbf{The complete syntax of description files}\\
\dstart
\begin{align*}
\textit{description} & ::= \; \textit{desclist}\\
\textit{desclist} & ::= \; \textit{descitem} \; \{ \textit{descitem} \}\\
\textit{descitem} & ::= \; \textit{typedid} \; | \;
  \textit{interface} \; | \;
  \textit{userdata}\\
\textit{typedid} & ::= \; \textit{id} \; \texttt{`:'} \; \textit{type}\\ 
\textit{interface} & ::= \; \textbf{interface} \; \textit{typedec}\\
\textit{userdata} & ::= \; \textbf{userdata} \; \textit{typedec}\\
\textit{typedec} & ::= \; \textit{Name} \; { \; \textit{decitem} \; } \; \textbf{end}\\
\textit{decitem} & ::= \; \textit{idlist} \; \texttt{`:'} \; \textit{idtype}\\
\textit{idtype} & ::= \; \textit{type} \; | \; \textit{methodtype}\\
\textit{idlist} & ::= \; \textit{id} \; \{ \; \texttt{`,'} \; \textit{id} \; \}\\
\textit{id} & ::= \; [\textbf{const}] \; \textit{Name}
\end{align*}
\dend
\caption{The concrete syntax of Typed Lua description files}
\label{fig:tldsyntax}
\end{figure}

Figure \ref{fig:tldsyntax} shows the complete syntax of Typed Lua
description files in extended BNF.
A Typed Lua description file defines the table type that represents
a certain module and the type names that are exported
along with this table type.
We can export a type name through the declaration of an interface or
userdata.
As we saw, an interface declaration is just a shortcut to a table type.
An userdata declaration is a shortcut to a table type that includes
a \emph{brand} that is its name.
The Typed Lua compiler uses this brand to combine structural with
nominal type checking, so two different userdata are not subtype
of each other because they do not share the same brand.
The Typed Lua compiler searches for a description file when it cannot
not find the respective Typed Lua file that is the argument of
\texttt{require}.

The following example shows the description file for \texttt{lmd5} \citep{lmd5},
a MD5 digest library for Lua that is written in C:
\begin{verbatim}
    userdata md5_context
      __tostring : (self) -> (string)
      clone : (self) -> (self)
      digest : (self, value) -> (string)
      new : (self) -> (self)
      reset : (self) -> (self)
      update : (self, string*) -> (self)
    end

    __tostring : (md5_context) -> (string)
    clone : (md5_context) -> (md5_context)
    digest : (md5_context|string, value) -> (string)
    new : () -> (md5_context)
    reset : (md5_context) -> (md5_context)
    update : (md5_context, string*) -> (md5_context)
    version : string
\end{verbatim}

This description file exports the type \texttt{md5\string_context}
through the \texttt{userdata} declaration, and the table type
that represents the module.
Now we can use the Typed Lua compiler to check for type errors on
our use of the library:
\begin{verbatim}
    local m = require "md5"
    local x = m.new()
    local y = x:clone()
    local z = m.clone("foo")             -- compile-time error
    print(x:digest() == m.digest(x))
\end{verbatim}

In this example there is a type error because function \texttt{clone}
expects a value of type \texttt{md5\string_context} instead of a value
of type \texttt{string}.

The description files are the mechanism that we used to include the
typing of the Lua standard libraries inside Typed Lua.

