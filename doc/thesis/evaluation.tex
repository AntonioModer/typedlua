
We performed some case studies on existing Lua libraries
to evaluate the design of our type system.
For each library, we used Typed Lua to either rewrite its modules
or to write statically typed interfaces to its modules through
Typed Lua's description files.
In this chapter we present our evaluation results, discuss
some interesting cases, and compare our type system to
related work.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
Lua Standard Libraries 5.2 & 94 & 5 & 34 & 133 & 71\% \\
\hline
Lua Standard Libraries 5.3 & 87 & 6 & 36 & 129 & 67\% \\
\hline
MD5 & 13 & 0 & 0 & 13 & 100\% \\
\hline
LuaSocket & 109 & 1 & 13 & 123 & 89\% \\
\hline
HTTP Digest & 0 & 0 & 1 & 1 & 0\% \\
\hline
Typical & 1 & 0 & 0 & 1 & 100\% \\
\hline
Modulo 11 & 7 & 0 & 2 & 9 & 78\% \\
\hline
Typed Lua Compiler & 144 & 0 & 10 & 154 & 94\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for each case study}
\label{tab:evalbycase}
\end{table}

Table \ref{tab:evalbycase} sumarizes our evaluation results for each
case study that we used Typed Lua for typing their members.
We split the members that we typed into three categories:
\emph{easy}, \emph{poly}, and \emph{hard}.
The \emph{easy} category represents the members that we could give
a precise static type for them.
The \emph{poly} category represents the members that we believe that
parametric polymorphism would help give a precise static type for them,
and we had to rely on the dynamic type to type them because our
type system does not support parametric polymorphism.
The \emph{hard} category represents the members that even parametric
polymorphism would not help give a precise static type for them,
and we also had to rely on the dynamic type to type them;
for instance, this category includes functions that require
intersection types to describe their precise static type.
The last column of the table shows the percentage of members that
are under the \emph{easy} category for each case study.
This percentage is our evaluation of Typed Lua, as it
represents how much static typing we could introduce to each one of
our case studies.

Before comparing our type system to related work, we will discuss
each case study in more detail.
For each case study, we will split the evaluation results according
to the modules that each one of them include.
This shall allow us to better discuss the contributions and limitations
of our type system.

\section{Lua Standard Libraries}

The Lua Standard Libraries \citep{luamanual} were our first case study.
We started to think about how we would type them at the same time that
we started to design our type system, as they could give us some hints
on our type system.
And they did: optional parameters and overloading on the return type
are two Lua features that our type system should handle to allow us
typing some of the functions that the standard libraries provide.

All libraries are separated C modules, and we used Typed Lua's description
files to give a statically typed interface to each module.
The \texttt{debug} module is the only one that we did not include in our
evaluation results, because it provides several functions that violate
basic assumptions about Lua code \citep{luamanual}.
For instance, we can use its function \texttt{setlocal} to change the value
of a local variable that is outside of the scope.
Table \ref{tab:evallsl} sumarizes the evaluation results for the Lua Standard Libraries.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{9}{*}{Lua Standard Libraries}
& base & 9 & 1 & 16 & 26 & 35\% \\
\cline{2-7}
& coroutine & 0 & 0 & 6 & 6 & 0\% \\
\cline{2-7}
& package & 5 & 0 & 3 & 8 & 62\% \\
\cline{2-7}
& string & 14 & 0 & 0 & 14 & 100\% \\
\cline{2-7}
& table & 1 & 4 & 1 & 6 & 17\% \\
\cline{2-7}
& math & 28 & 0 & 1 & 29 & 97\% \\
\cline{2-7}
& bit32 & 12 & 0 & 0 & 12 & 100\% \\
\cline{2-7}
& io & 15 & 0 & 6 & 21 & 71\% \\
\cline{2-7}
& os & 10 & 0 & 1 & 11 & 91\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for Lua Standard Libraries 5.2}
\label{tab:evallsl}
\end{table}

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{9}{*}{Lua Standard Libraries}
& base & 9 & 1 & 16 & 26 & 35\% \\
\cline{2-7}
& coroutine & 1 & 0 & 6 & 7 & 14\% \\
\cline{2-7}
& package & 5 & 0 & 3 & 8 & 62\% \\
\cline{2-7}
& string & 14 & 0 & 2 & 16 & 88\% \\
\cline{2-7}
& utf8 & 6 & 0 & 0 & 6 & 100\% \\
\cline{2-7}
& table & 1 & 5 & 1 & 7 & 14\% \\
\cline{2-7}
& math & 26 & 0 & 1 & 27 & 96\% \\
\cline{2-7}
& io & 15 & 0 & 6 & 21 & 71\% \\
\cline{2-7}
& os & 10 & 0 & 1 & 11 & 91\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for Lua Standard Libraries 5.3}
\label{tab:evallsl53}
\end{table}

We could give precise static types to most of the modules,
but some of them are still hard to type with the current type
system.
Now, we will discuss why some modules are difficult to type,
and what kind of limitations they represent on our type system.

The \texttt{base} module was quite hard to type because it
includes several functions that have dynamic behavior.
For instance, the function \texttt{next} traverses all the
fields of a table, but the order that the indices are
enumerated is not specified.
For this reason, it is also difficult to type the function
\texttt{pairs}.
The functions \texttt{getmetatable},  \texttt{rawget}, and
\texttt{rawset} are also examples of functions that their
behavior depend on the C implementation.

There are also some functions that have a dynamic behavior and
their return type depend on their input type.
For instance, the functions \texttt{assert} and \texttt{select}
can return all the values that they received as their arguments.

We could give a more precise type to \texttt{ipairs} if our
type system had parametric polymorphism, as this function
returns an iterator function that operates over a list of
elements.

Furthermore, the \texttt{base} module also includes two very
special cases: the functions \texttt{tonumber} and \texttt{collectgarbage}.

The function \texttt{tonumber} is a special case because the
type of one input parameter depends on the type of another.
For instance, there are two static types that we can
assign to the function \texttt{tonumber}:
\texttt{(value) -> (number?)} and
\texttt{(string, number) -> (number?)}.
More precisely, the first argument of \texttt{tonumber} can be
a value of any type if it is the only argument, but it must
be a value of type string if there is a second argument,
which must be a value of type number.

The function \texttt{collectgarbage} is a special case because
its return type depends on the value of the first parameter,
which should be a string.
This function can return one number, one boolean, or two numbers
depending on the literal string that was given as its first argument.

We could not type the \texttt{coroutine} module because our
type system does not include the type \emph{thread}.
Lua has one-shot delimited continuations \citep{james2011yield}
in the form of \emph{coroutines} \citep{moura2009rc}, and
effect systems \citep{nielson1999type} are an approach that we
could use to describe control transfers with continuations.
However, for now, coroutines are out of the scope of our type
system, and we use an empty \emph{userdata} declaration
to represent the type \emph{thread}.

We could type most of the members of the \texttt{package} module,
but we could not type the following tables: \texttt{package.loaded},
\texttt{package.preload}, and \texttt{package.loaders}.
The first stores loaded modules, while the others store module \emph{loaders}.
They are difficult to type because their types are dynamic and
depend on the modules a program loads.

We could type all the members of the \texttt{string} module.
Even though we can use the \texttt{string} functions in object-oriented style,
we did not use an \emph{userdata} declaration to handle this feature,
as it would complicate the subtyping rules because the type \texttt{string}
would become a table type instead of a base type.
It was simpler and more starightforward to handle this feature as a
special case in the implementation.
For this reason, we did not include the typing of the \texttt{string} methods
in our evaluation results.

The \texttt{table} module is specially difficult to type because
all of its members require parametric polymorphism.
All the functions of this module either receive or return a list
of elements, and parametric polymorphism would help us to describe
them with a generic type.

However, the lack of parametric polymorphism did not prevent us from
giving a precise type to \texttt{table.concat}, as it operates over lists
where all elements are strings or numbers, and we can use the table type
\texttt{\{string|number\}} to express this type on our type system.

Even if our type system had parametric polymorphism, it would
be difficult to type \texttt{table.insert}, as its type depends on
the calling arity.
We can call \texttt{table.insert} passing two or three parameters.
The first parameter is always a list.
If we call it with two arguments, then the second parameter
is the value to be inserted at the end of the list.
If we call it with three arguments, then the third parameter
is the value to be inserted in the list, and the second
parameter is the position where it should be inserted.
This function also does not follow the semantics of Lua on
discarding extra arguments, and generates a run-time error whenever
we pass more than three arguments, even if the first three arguments
match its signature.

Even though the \texttt{math} module is straightforward to type,
it includes a special case that is hard to type: the function \texttt{math.random}.
This function is difficult to type because its type also depends
on the calling arity.
We can call \texttt{math.random} passing zero, one, or two parameters.
If we pass no parameter, then it returns a random floating point
number between \texttt{0} and \texttt{1}.
If we pass one or two parameters, then all the parameters should be
integers and it returns an integer number.
Another problem with this function is that it also does not follow
the semantics of Lua on discarding extra arguments, and generates
a run-time error whenever we pass more than three arguments.
There is also a problem on its documentation, as it suggests that
the two integers are optional parameters, but, for \texttt{math.random},
optional parameters behave in a different way.
Usually, Lua functions replace optional parameters with a default value
when they are \texttt{nil}, but \texttt{math.random} generates a run-time
error instead.

The \texttt{bit32} module was quite straightforward to type,
as its members are only bitwise operations over numbers.

The \texttt{io} module provides operations for manipulating files,
and these operations can use implicit or explicit file descriptors.
The implicit operations are functions in the \texttt{io} table,
while the explicit operations are methods of a file descriptor.
We used an \emph{userdata} declaration to introduce the type
\texttt{file} for representing the type of a file descriptor
and its methods.
For this reason, we included the typing of the \texttt{file}
methods in our evaluation results.

We could type most of members of the \texttt{io} module,
but we could not precisely type the functions \texttt{io.close},
\texttt{io.read}, and \texttt{io.lines}.
We also could not type the methods \texttt{file:close},
\texttt{file:read}, and \texttt{file:lines}.

The function \texttt{io.close} is difficult to type
because its return type depends on whether the file handle that is
being closed was created with \texttt{popen} or not.
If it was created with \texttt{popen}, then \texttt{io.close}
has type \texttt{(file?) -> (boolean?, string, number)};
otwerwise \texttt{io.close} has type \texttt{(file?) -> (boolean)?}.
The method \texttt{file:close} is difficult to type for the same reason.

The functions \texttt{io.read} and \texttt{io.lines} are difficult
to type because their return types depend on their input types.
The type of \texttt{io.read} can be either \texttt{() -> (string*)}
or \texttt{(string|number*) -> (string|number*)}, and
the type of \texttt{io.lines} can be either \texttt{(string?) -> (string*)}
or \texttt{(string, string|number*) -> (string|number*)}.
Returning \texttt{(string|number*)} is also painful to programmers, as
they need to constrain the value of the return type among three
different types before cocatenating it, for example.
The methods \texttt{file:read} and \texttt{file:lines} are difficult
to type for the same reason.

The function \texttt{os.execute} is the only member of the \texttt{os}
module that we could not give a precise type.
This function is difficult to type because its return type depend on
the input type.
Its type can be either \texttt{() -> (boolean)} or
\texttt{(string) -> (boolean?, string, number)}.

The evaluation results show that our type system should include effect
types, parametric polymorphism, and intersection types, as these
features would help to increase the static typing of the Lua Standard Libraries.
Effect types would allow us to type coroutines.
Parametric polymorphism would allow us to define generic function and table types.
Intersection types would allow us to define function types that have
different return types according to their input types.

\section{MD5}

We chose the MD5 library \citep{lmd5} as a case study because it is
simple and contains just one module.
We needed a simple case study to introduce Typed Lua's description
files and \texttt{userdata} declarations.
These Typed Lua's mechanims allow programmers to give statically typed
interfaces to Lua libraries that are written in C.
Table \ref{tab:evalmd5} sumarizes the evaluation results for MD5.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{1}{*}{MD5}
& md5 & 13 & 0 & 0 & 13 & 100\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for MD5}
\label{tab:evalmd5}
\end{table}

Even tough it was quite straightforward to type the MD5 library,
we found a little difference between its documentation and its static typing.
The documentation suggested that the typing of the function \texttt{update}
should be \texttt{(md5\string_context, string) -> (md5\string_context)},
while a comment in the source code suggested that it should be
\texttt{(md5\string_context, string, string*) -> (md5\string_context)}.
However, while testing it and reading its source code, we noticed that
its actual type is \texttt{(md5\string_context, string*) -> (md5\string_context)},
that is, we can pass zero or more strings to \texttt{update}.

This case study shows that it might be not so obvious to identify which
functions discard extra arguments when we are typing an external library.
In this case study, reading its source code and test script was essential
to confirm the typing of \texttt{update}.

\section{LuaSocket}

LuaSocket \citep{luasocket} is a library that adds network support to Lua,
and it is split into two parts: a core that is written in C and a set of
Lua modules.
The C core provides TCP and UDP support, while the Lua modules provide
support for SMTP, HTTP, and FTP client protocols, MIME encoding,
URL manipulation, and LTN12 filters \citep{nehab2008ltn012}.
We chose LuaSocket as a case study because it is the most popular Lua library.
We used Typed Lua's description files to type both parts.
This is the only case study that we test description files to statically type
a Lua module instead of rewriting it.
Table \ref{tab:evalsocket} sumarizes the evaluation results for LuaSocket.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{7}{*}{LuaSocket}
& socket & 50 & 0 & 10 & 60 & 83\% \\
\cline{2-7}
& ftp & 5 & 0 & 1 & 6 & 83\% \\
\cline{2-7}
& http & 4 & 0 & 1 & 5 & 80\% \\
\cline{2-7}
& smtp & 6 & 0 & 1 & 7 & 86\% \\
\cline{2-7}
& mime & 17 & 0 & 0 & 17 & 100\% \\
\cline{2-7}
& ltn12 & 19 & 1 & 0 & 20 & 95\% \\
\cline{2-7}
& url & 8 & 0 & 0 & 8 & 100\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for LuaSocket}
\label{tab:evalsocket}
\end{table}

We could type most of the members in the \texttt{socket} module,
which is the C core.
However, this module includes some functions such as
\texttt{socket.try}, \texttt{socket.protect}, and \texttt{socket.skip}
that have a dynamic behavior.
This means that the return type of these functions depend on the
type of the values that we use to call them.

We could type most of the members of the modules \texttt{ftp},
\texttt{http}, and \texttt{smtp}, but we could not precisely type
the functions \texttt{ftp.get}, \texttt{http.request}, and
\texttt{smtp.message}.

The function \texttt{ftp.get} downloads data from a given URL,
and it is difficult to type because its return type depend on
the type of its parameters.
Its type is either \texttt{(string) -> (string)?} or
\texttt{(url\string_argument|url\string_path) -> (number)?}.
The types \texttt{url\string_argument} and \texttt{url\string_path}
are table types that describe the URL that should be used to
download data.
Both table types include the same fields, except one:
while the first includes the mandatory field \texttt{argument},
of type \texttt{string}, the latter includes the mandatory field
\texttt{path}, also of type \texttt{string}.

The function \texttt{http.request} downloads data from a given URL,
and it is difficult to type because its return type depend on
the type of its parameters.
Its type is either
\texttt{(string, string?) -> (string, number, \{string : string\}, number)?} or
\texttt{(url\string_request) -> (number, number, \{string : string\}, number)?}.
The type \texttt{url\string_request} is a table type containing
details about the downloading URL.

The function \texttt{smtp.message} creates a function that sends
an SMTP message body, and it is difficult to type because of the
type of the message body, which is recursive and makes harder
its initialization.

The modules \texttt{mime} and \texttt{ltn12} have a strong connection.
The \texttt{mime} module offers low-level and high-level filters
that apply and remove some text encodings.
The low-level filters are written in C, while the high-level filters
use the function \texttt{ltn12.filter.cycle} along with the low level
filters to create standard filters.
Even though we could type all the members of the \texttt{mime} module,
the function \texttt{ltn12.filter.cycle} is the only member of the
\texttt{ltn12} module that we could not give a precise type.
This function is difficult to type because the \texttt{mime} low-level
filters do not have a standard API.

The \texttt{url} module provides functions that manipulate URLs.
It is straightforward to type, although it defines a table type for
parsed URLs that is not precise enough.
This type is problematic because it is a record type where all
fields are optional, and makes any table type that does not include
the optional fields statically type check.

This case study shows that abusing of dynamic typing usually impacts
the users of a module, as they have to keep on checking each return
value before using it to prevent API misuses.

\section{HTTP Digest}

The HTTP Digest library \citep{luahttpdigest} implements client side
HTTP digest authentication for Lua.
We randonly chose this library as a case study to evaluate Typed Lua
for rewriting an existing Lua module.
Table \ref{tab:evalhttpdigest} summarizes the evaluation results for HTTP Digest.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{1}{*}{HTTP Digest}
& http-digest & 0 & 0 & 1 & 1 & 0\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for HTTP Digest}
\label{tab:evalhttpdigest}
\end{table}

It is difficul to type the interface of the \texttt{http-digest} module
because it is an extension to the \texttt{http} module from LuaSocket.
The \texttt{http-digest} module only exports the function
\texttt{http-digest.request}, which extends the function
\texttt{http.request} with MD5 authentication.
Like \texttt{http.request}, the return type of \texttt{http-digest.request}
also depends on the type of its parameters.
Its type is either
\texttt{(string) -> (string, number, \{string : string\})?} or
\texttt{(url\string_request) -> (number, number, \{string : string\})?}.

Even though we could not precisely type the interface that \texttt{http-digest}
exports, we could use only static types to rewrite it, and they pointed a bug
in the code.
The problem was related to the way the library was loading the MD5 library
that should be used. 
This part of the code checks the existence of three different MD5 libraries
in the system, and uses the first one that is available, or generates an
error when none is available.
The code that loads the first option was fine, but the code that loads the
second and third options were trying to access an undefined global variable.

\section{Typical}

Typical \citep{luatypical} is a library that extends the behavior of the
function \texttt{type}. 
We randonly chose this library as a case study to evaluate Typed Lua
for rewriting an existing Lua module.
Table \ref{tab:evaltypical} summarizes the evaluation results for Typical.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{1}{*}{Typical}
& typical & 1 & 0 & 0 & 1 & 100\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for Typical}
\label{tab:evaltypical}
\end{table}

The interface of the \texttt{typical} module is straightforward to type,
as it contains only the function \texttt{typical.type},
which has the same type of the function \texttt{type}: \texttt{(value) -> (string)}.

However, we hit some limitations of our type system to rewrite this module.
First, it uses the function \texttt{getmetatable} to get a table and
checks whether this table has the field \texttt{\string_\string_type} or not.
We could not give a precise type to \texttt{getmetatable}, so we used the dynamic
type \texttt{any} as its return type, and this generates a warning that we could not
remove.
Second, the module returns a metatable that extends \texttt{\string_\string_call}
with \texttt{typical.type}, that is, we can use the module itself as a function,
though it is a table.
Our type system still does not support metatables, so we did not extend our version
of the \texttt{typical} module to support \texttt{\string_\string_call}.
Third, the module uses \texttt{ipairs} to iterate over an array of functions,
but our type system also has limited support to \texttt{ipairs}, and generates
a warning when we try to use the indexed value inside the \texttt{for} body.
We removed this warning using the numeric \texttt{for} to perform the same loop.

\section{Modulo 11}

Modulo 11 \citep{luamod11} is a library that generates and verifies
modulo 11 numbers.
We randonly chose this library as a case study to evaluate Typed Lua
for rewriting an existing Lua module.
Table \ref{tab:evalmod11} summarizes the evaluation results for Typical.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{1}{*}{Modulo 11}
& mod11 & 7 & 0 & 2 & 9 & 78\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for Modulo 11}
\label{tab:evalmod11}
\end{table}

The \texttt{mod11} module was written using an object-oriented idiom that
our type system does not support, and that is the reason why we could not
type all the members of its interface.
More precisely, the original code uses \texttt{setmetatable} to hide
two attributes, which our type system cannot hide.

In addition, it returns a metatable that extends \texttt{\string_\string_call}
with the class constructor.
This allows us to use the module itself to create new instances of a
Modulo 11 number.
However, our type system does not support this feature, and we need to
make explicit calls to the constructor whenever we want to create a
new instance.

Even though we had these two issues to rewrite the \texttt{mod11} module,
we could use only static types to rewrite it, and found some interesting
points.
The code relies a lot on implicit conversions between strings and numbers,
and some parts of the code keep on changing the type of local variables.
These are two practices that may hide bugs.

\section{Typed Lua Compiler}

The Typed Lua compiler is the last case study that we evaluated, and the
Table \ref{tab:evaltlc} summarizes the evaluation results.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{8}{*}{Typed Lua Compiler}
& tlast & 46 & 0 & 1 & 47 & 98\% \\
\cline{2-7}
& tltype & 65 & 0 & 0 & 65 & 100\% \\
\cline{2-7}
& tlst & 26 & 0 & 0 & 26 & 100\% \\
\cline{2-7}
& tllexer & 2 & 0 & 9 & 11 & 18\% \\
\cline{2-7}
& tlparser & 1 & 0 & 0 & 1 & 100\% \\
\cline{2-7}
& tldparser & 1 & 0 & 0 & 1 & 100\% \\
\cline{2-7}
& tlchecker & 2 & 0 & 0 & 2 & 100\% \\
\cline{2-7}
& tlcode & 1 & 0 & 0 & 1 & 100\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for Typed Lua Compiler}
\label{tab:evaltlc}
\end{table}

The \texttt{tlast} module implements the abstract syntax tree that
the compiler uses to perform the type checking.
We could not precisely type just one function because its return
type depend on the type of its input parameter.

The \texttt{tltype} module implements the types introduced by
Typed Lua and the subtyping and consistent-subtyping relationsr;
it was straightforward to type.

The \texttt{tlst} module implements the environment that the
compiler uses during the type checking, and it was also straightforward
to type.

The \texttt{tllexer} module defines common lexical rules for
the Typed Lua parser and the parser of the description files.
This module is hard to type because it exports LPeg \citep{lpeg,ierusalimschy2009lpeg}
patterns, which our type system cannot precisely type because it does
not support operator overloading.

The \texttt{tlparser} and \texttt{tldparser} implement the Typed Lua
parser and the parser of the description files, respectively.
Even though they use LPeg to implement the grammar rules,
they only export a parsing function that uses LPeg to parse a
string and return the corresponding AST.

The \texttt{tlchecker} and \texttt{tlcode} modules are also
straightforward to type.
The first traverses the AST to perform type checking,
while the latter traverses the AST to perform code generation.

Even though we could precisely type the interface of most of
the modules, we had some issues to write mutually recursive
functions that traverses the AST.
In this case we had to rely on the dynamic type to defer the
function declarations.

\section{Related Work}

\begin{itemize}
\item \citep{tidallock}
\item \citep{bonnaire-sergeant2012typed-clojure}
\item \citep{vitousek2014deg}
\item \citep{allende2013gts}
\item \citep{tobin-hochstadt2008ts} 
\item \citep{dart}
\item \citep{typescript}
\item \citep{bierman2014typescript}
\item \citep{politz2012semantics}
\end{itemize}
