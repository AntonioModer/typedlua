
We performed some case studies on existing Lua libraries
to evaluate the design of our type system.
For each library, we used Typed Lua to either rewrite its modules
or to write statically typed interfaces to its modules through
Typed Lua's description files.
In this chapter we present our evaluation results, discuss
some interesting cases, and compare our type system to
related work.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
Lua Standard Libraries & 92 & 4 & 34 & 130 & 71\% \\
\hline
MD5 & 13 & 0 & 0 & 13 & 100\% \\
\hline
Lua Socket & 85 & 22 & 19 & 126 & 67\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for each case study}
\label{tab:evalbycase}
\end{table}

Table \ref{tab:evalbycase} sumarizes our evaluation results for each
case study that we used Typed Lua for typing their members.
We split the members that we typed into three categories:
\emph{easy}, \emph{poly}, and \emph{hard}.
The \emph{easy} category represents the members that we could give
a precise static type for them.
The \emph{poly} category represents the members that we believe that
parametric polymorphism would help give a precise static type for them,
and we had to rely on the dynamic type to type them because our
type system does not support parametric polymorphism.
The \emph{hard} category represents the members that even parametric
polymorphism would not help give a precise static type for them,
and we also had to rely on the dynamic type to type them;
for instance, this category includes functions that require
intersection types to describe their precise static type.
The last column of the table shows the percentage of members that
are under the \emph{easy} category for each case study.
This percentage is our evaluation of Typed Lua, as it
represents how much static typing we could introduce to each one of
our case studies.

Before comparing our type system to related work, we will discuss
each case study in more detail.
For each case study, we will split the evaluation results according
to the modules that each one of them include.
This shall allow us to better discuss the contributions and limitations
of our type system.

\section{Lua Standard Libraries}

The Lua Standard Libraries \citep{luamanual} were our first case study.
We started to think about how we would type them at the same time that
we started to design our type system, as they could give us some hints
on our type system.
And they did: optional parameters and overloading on the return type
are two Lua features that our type system should handle to allow us
typing some of the functions that the standard libraries provide.

All libraries are separated C modules, and we used Typed Lua's description
files to give a statically typed interface to each module.
The \texttt{debug} module is the only one that we did not include in our
evaluation results, because it provides several functions that violate
basic assumptions about Lua code \citep{luamanual}.
For instance, we can use its function \texttt{setlocal} to change the value
of a local variable that is outside of the scope.
Table \ref{tab:evallsl} sumarizes the evaluation results for the Lua Standard Libraries.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{9}{*}{Lua Standard Libraries}
& base & 8 & 0 & 18 & 26 & 31\% \\
\cline{2-7}
& coroutine & 0 & 0 & 6 & 6 & 0\% \\
\cline{2-7}
& package & 5 & 0 & 3 & 8 & 62\% \\
\cline{2-7}
& string & 14 & 0 & 0 & 14 & 100\% \\
\cline{2-7}
& table & 1 & 4 & 1 & 6 & 17\% \\
\cline{2-7}
& math & 28 & 0 & 1 & 29 & 97\% \\
\cline{2-7}
& bit32 & 12 & 0 & 0 & 12 & 100\% \\
\cline{2-7}
& io & 14 & 0 & 4 & 18 & 78\% \\
\cline{2-7}
& os & 10 & 0 & 1 & 11 & 91\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for Lua Standard Libraries}
\label{tab:evallsl}
\end{table}

We could give precise static types to most of the modules,
but some of them are still hard to type with the current type
system.
The only modules that we could type all their members are
\texttt{string} and \texttt{bit32}.
Now we will discuss in more detail the particularities that
we found on each module, and the limitations that we found
on our type system.

The \texttt{base} module was quite hard to type because it
includes several functions that have dynamic behavior.
For instance, the function \texttt{next} traverses all
fields of a table, but the order that the indices are
enumerated is not specified.
The function \texttt{pairs} is also difficult to type, as
our type system cannot garantee that it will no try to
access a field that does not exist.
The functions \texttt{rawget} and \texttt{rawset} are also
examples of functions that their behavior depend on the
C implementation.

There are some functions that have a dynamic behavior and
the return type depend on the input type.
For instance, \texttt{assert} and \texttt{select}.

Moreover, the \texttt{base} module also include some functions
that the type of one input parameter depends on the type of
another.
For instance, there are two static types that we can
assign to the function \texttt{tonumber}:
\texttt{(value) -> (number?)} and
\texttt{(string, number) -> (number?)}.
More precisely, the first argument of \texttt{tostring} can be
a value of any type if it is the only argument, but it must
be a value of type string if there is a second argument,
which must be a value of type number.

We could not type the \texttt{coroutine} module because our
type system does not include the type \emph{thread}.
Lua has one-shot delimited continuations \citep{james2011yield}
in the form of \emph{coroutines} \citep{moura2009rc}, and
effect systems \citep{nielson1999type} are an approach that we
could use to describe control transfers with continuations.
However, for now coroutines are out of the scope of our type
system, and we use an empty \emph{userdata} declaration
to represent the type \emph{thread}.

We could type most the members of the \texttt{package} module,
but we could not type any member that is a table.
More precisely, we could not type the table \texttt{loaded}
that stores loaded modules, and the tables \texttt{preload}
and \texttt{searchers} that store module \emph{loaders}.
They are difficult to type because their type depend on the
modules a program loads.

The \texttt{table} module is specially difficult to type because
all of its members require parametric polymorphism.
All the functions of this module either receive or return a list
of elements, and parametric polymorphism would help us to describe
them with a generic type.

However, the lack of parametric polymorphism did not prevent us from
giving a precise type to \texttt{concat}, as it operates over lists
where all elements are strings or numbers.

Even if our type system had parametric polymorphism, it would
be difficult to type \texttt{insert}, as its type depends on
the calling arity.
We can call \texttt{insert} passing two or three parameters.
The first parameter is always a list.
If we call it with two arguments, then the second parameter
is the value to be inserted in the end of the list.
If we call it with three arguments, then the third parameter
is the value to be inserted in the list, and the second
parameter is the position where it should be inserted.
This function also does not follow the semantics of Lua on
discarding extra arguments.
Lua generates a run-time error whenever we pass more than three
arguments to \texttt{insert}, even if the first three parameters
match its definition.

Even though the \texttt{math} module is straightforward to type,
it includes a special case that is hard to type: the function \texttt{random}.
This function is difficult to type because its type also depends
on the calling arity.
We can call \texttt{random} passing zero, one, or three parameters.
If we pass no parameter, then it returns a float number.
If we pass one or two parameters, then all the parameters should be
integers and it returns an integer number.
Another problem with this function is that it also does not follow
the semantics of Lua on discarding extra arguments, and generates
a run-time error whenever we pass more than three arguments.
There is also a problem on its documentation, as it suggests that
the two integers are optional parameters, but, for \texttt{random},
optional parameters behave in a different way.
Usually, Lua functions replace optional parameters with a default value
when they are \texttt{nil}, but \texttt{random} generates a run-time
error instead.

We could type most members from \texttt{io} module, but we could not
precisely type \texttt{close} and \texttt{lines}.
The function and the method \texttt{close} are difficult to type
because their return type depend whether the file handle that is
being closed was created with \texttt{popen} or not.
If it was created with \texttt{popen}, then \texttt{close}
returns \texttt{(boolean) | (nil, string, number)};
otwerwise \texttt{close} returns \texttt{(boolean) | (nil, string)}.
The function and the method \texttt{lines} are difficult to type
because they number or string depending on the type of the argument.

The function \texttt{execute} is the only member from \texttt{os}
module that we could not give a precise type.
It is difficult to type because its return type depend on the
input type.
Its type can be either \texttt{() -> (boolean)} or
\texttt{(string) -> (boolean?, string, number)}.

To increase the static typing of the Lua Standard Libraries
we need to include effect types, parametric polymorphism,
and intersection types.
The first will allow us to type coroutines, the second will
improve static typing of table types, and the third is
important to describe functions that return different types
according to their input types.

\section{MD5}

The MD5 library \citep{lmd5} is the case study that we used to
introduce Typed Lua's description files.
We chose this case study because it is simple and contains just
one module, being a good example for introducing how we can use
Typed Lua's description files for giving a statically typed
interface to a Lua library that is written in C, and to 
introduce how we can type an \emph{userdata}.
Table \ref{tab:evalmd5} sumarizes the evaluation results for MD5.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{1}{*}{MD5}
& md5 & 13 & 0 & 0 & 13 & 100\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for MD5}
\label{tab:evalmd5}
\end{table}

Even tough the MD5 library is quite simple and it was quite easy to type,
we found a little discrepancy between its documentation and its static
typing.
The documentation suggested that the typing of the function \texttt{update}
should be \texttt{(md5\string_context, string) -> (md5\string_context)},
and a comment in the source code suggested that it should be
should be \texttt{(md5\string_context, string, string*) -> (md5\string_context)}.
However, while testing it and reading its source code, we noticed that
its actual type is \texttt{(md5\string_context, string*) -> (md5\string_context)},
that is, we can pass zero or more strings to \texttt{update}.

This case study shows a connection between documentation and software testing.
Even though type annotations are a good source of documentation, this case
study shows that identifying what functions discard extra parameters can be
not so obvious for someone that is typing an external library.
Reading the source code and the library's test script was essential to confirm
the typing of \texttt{update}.

\section{Lua Socket}

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Case study} & \textbf{Module} & \textbf{easy} & \textbf{poly} & \textbf{hard} & \textbf{Total} & \textbf{\%} \\
\hline
\multirow{7}{*}{Lua Socket}
& socket & 50 & 3 & 7 & 60 & 83\% \\
\cline{2-7}
& ftp & 6 & 1 & 1 & 8 & 75\% \\
\cline{2-7}
& http & 3 & 0 & 2 & 5 & 60\% \\
\cline{2-7}
& ltn12 & 10 & 10 & 0 & 20 & 50\% \\
\cline{2-7}
& mime & 2 & 8 & 7 & 17 & 12\% \\
\cline{2-7}
& smtp & 6 & 0 & 2 & 8 & 75\% \\
\cline{2-7}
& url & 8 & 0 & 0 & 8 & 100\% \\
\hline
\end{tabular}
\end{center}
\caption{Evaluation results for Lua Socket}
\label{tab:evalsocket}
\end{table}

\section{Related Work}
