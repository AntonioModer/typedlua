
In the previous chapter we presented an informal overview of Typed Lua.
We showed that programmers can use Typed Lua to combine static and dynamic
typing in the same code, and it allows them to incrementally migrate from
dynamic to static typing.
This is a benefit to programmers that use dynamically typed languages
to build large applications, as static types detect many bugs
during the development phase, and also provide better documentation.

In this chapter we present the formalization of Typed Lua.
Besides its practical contribution, Typed Lua also has some interesting
contributions on the field of optional type systems for scripting
languages.
Namely, it is a simple type system that covers several Lua idioms
and features, such as the refinement of tables, multiple return values,
and optional parameters.
We will use typing rules to explain how we implemented the features of Typed Lua.

\section{Types}

Our type system uses subtyping \citep{cardelli1984smi,abadi1996to} to order
types and consistent-subtyping \citep{siek2007objects,siek2013mutable}
to allow the interaction between statically and dynamically typed code.
We will explain the subtyping and consistent-subtyping rules along this
section while we introduce each type from our type system.
We will focus the discussion on the definition of subtyping because,
as we mentioned in Chapter \ref{chap:review}, we can combine the
consistency and subtyping relations to achieve consistent-subtyping.
The differences between subtyping and consistent-subtyping are the way
they handle the dynamic type, and the fact that subtyping is transitive,
but consistent-subtyping is not.

\begin{figure}[!ht]
\textbf{Type Language}\\
\dstart
$$
\begin{array}{rlr}
\multicolumn{3}{c}{\textbf{First-level types}}\\
t ::= & \;\; l & \textit{literal types}\\
& | \; b & \textit{base types}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; t \cup t & \textit{disjoint union types}\\
& | \; p \rightarrow r & \textit{function types}\\
& | \; \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed|open|unique} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.t & \textit{recursive types}\\
& | \; \pi_{i} & \textit{projection types}\\
l ::= & \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} & \\
b ::= & \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String & \\
k ::= & \;\; l \; | \; b \; | \; \Any & \textit{key types}\\
v ::= & \;\; t \; | \; \Const \; t & \textit{field types}\\ 
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{\textbf{Second-level types}}\\
s ::= & \;\; t &\\
& | \; t* & \textit{variadic types}\\
& | \; t \times s & \textit{tuple types}\\
p ::= & \;\; \Void \; | \; s & \textit{parameters list type}\\
r ::= & \;\; \Void \; | \; s \; | \; s \sqcup r & \textit{return types}\\
\end{array}
$$
\dend
\caption{The abstract syntax of Typed Lua types}
\label{fig:typelang}
\end{figure}

Figure \ref{fig:typelang} presents the abstract syntax of the
Typed Lua types.
Typed Lua splits types into two categories:
\emph{first-level types} and \emph{second-level types}.
Typed Lua uses first-level types to represent Lua values and
second-level types to represent expression lists, and it also
uses them to type multiple assignments and function applications.
First-level types include literal types, base types, the type $\Nil$,
the top type $\Value$, the dynamic type $\Any$, the type $\Self$,
union types, function types, table types, recursive types, and
projection types.
Second-level types include the type $\Void$, tuples of first-level
types optionally ending in a variadic type, and union of these tuples.

Literal types represent the type of literal values.
They can be the boolean values $\False$ and $\True$,
any integer value, any floating point value, and any string value.
We shall see that literal types are important to represent table types
as records.

Our type system also includes the following base types: $\Boolean$,
$\Integer$, $\Number$, and $\String$.
The base types $\Boolean$ and $\String$ represent the values that
during run-time Lua tags as \texttt{boolean} and \texttt{string},
respectively;
the base types $\Integer$ and $\Number$ represent the values
that during run-time Lua tags as \texttt{number}.
We introduced two different base types to represent Lua numbers
because Lua introduced integers in version 5.3.

The subtyping rules for literal types include a reflexive rule,
and the rules for defining that literal types are subtypes of
their respective base types;
the subtyping rules for base types include a reflexive rule,
and another rule for defining that $\Integer$ is subtype of
$\Number$.
We defined these subtyping rules as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-LITERAL}\\
\senv \vdash l \subtype l
\end{array}
\;
\begin{array}{c}
\mylabel{S-FALSE}\\
\senv \vdash \False \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-TRUE}\\
\senv \vdash \True \subtype \Boolean
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-INT1}\\
\senv \vdash {\it int} \subtype \Integer
\end{array}
\;
\begin{array}{c}
\mylabel{S-INT2}\\
\senv \vdash {\it int} \subtype \Number
\end{array}
\;
\begin{array}{c}
\mylabel{S-FLOAT}\\
\senv \vdash {\it float} \subtype \Number
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-STRING}\\
\senv \vdash {\it string} \subtype \String
\end{array}
\begin{array}{c}
\mylabel{S-BASE}\\
\senv \vdash b \subtype b
\end{array}
\;
\begin{array}{c}
\mylabel{S-NUMBER}\\
\senv \vdash \Integer \subtype \Number
\end{array}
\end{array}
\]

The variable $\senv$ is a set of pairs of recursion variables.
We shall notice that we need this set to record the pairs of valid
recursive types.

We could have omitted the rules \textsc{S-LITERAL}, \textsc{S-BASE},
and \textsc{S-INT2}, because the first two are reflexive and we
could achieve the third one through transitivity.
More precisely, we could have defined subsumption rules that
specify the reflexive and transitive behavior of subtyping,
and use these rules instead of the ones we defined.
For instance, we would not need \textsc{S-INT2} because we could
use the transitive subsumption rule to derive that
\[
\dfrac{\senv \vdash 1 \subtype \Integer \;\;\;
       \senv \vdash \Integer \subtype \Number}
      {\senv \vdash 1 \subtype \Number}
\]

However, we are using the subtyping rules as the template for defining
the consistent-subtyping rules, and consistent-subtyping is not
transitive.
More precisely, we want the subtyping and consistent-subtyping rules
to differ only in the way they handle the dynamic type.
Thus, we define the subtyping rules using an algorithmic
way that is close to the implementation, as this way allows us to use
subtyping to formalize consistent-subtyping.

The type $\Nil$ represents the type of values that during run-time
Lua tags as \texttt{nil}.
It is a separated type because in our type system $\Nil$ is
not the bottom type.
Typed Lua has this behavior because in Lua the tag \texttt{nil}
represents the absence of an useful value.
Thus, making $\Nil$ the bottom type would severally reduce the
amount of type safety in our type system.
The next subtyping rule shows this behavior:
\[
\begin{array}{c}
\mylabel{S-NIL}\\
\senv \vdash \Nil \subtype \Nil
\end{array}
\]

The type $\Value$ is the top type, so any first-level type is
subtype of $\Value$.
We shall see that this type along with variadic types help to
drop extra values on multiple assignments, and function calls,
thus preserving the semantics of Lua in these cases.
Following we show its subtyping rule:
\[
\begin{array}{c}
\mylabel{S-VALUE}\\
\senv \vdash t \subtype \Value
\end{array}
\]

The dynamic type $\Any$ is the type that allows programmers to mix
static and dynamic typing.
The type $\Any$ is neither the bottom nor the top type, but a
separated typed that is subtype only of itself:
\[
\begin{array}{c}
\mylabel{S-ANY}\\
\senv \vdash \Any \subtype \Any
\end{array}
\]

Even though the dynamic type $\Any$ is neutral to subtyping,
it is not to consistent-subtyping:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{C-ANY1}\\
\senv \vdash t \lesssim \Any
\end{array}
\;
\begin{array}{c}
\mylabel{C-ANY2}\\
\senv \vdash \Any \lesssim t
\end{array}
\end{array}
\]

The rules that handle the dynamic type are the only rules that
differ between subtyping and consistent-subtyping.
If we set the type $\Any$ as both bottom and top types of our
subtyping relation, then all programs would type check without errors.
This would happen due to the transitivity of subtyping, that is,
we would be able to down-cast any type to $\Any$ and then up-cast
$\Any$ to any type.
While the rule \textsc{S-ANY} is neutral and makes transitivity
not be a problem, the rules \textsc{C-ANY1} and \textsc{C-ANY2}
are the rules that allow the dynamic type to interact with other
first-level types, and thus allow dynamically typed code coexist
with statically typed code.
Because of these two rules consistent-subtyping cannot be transitive.

Typed Lua uses the type $\Self$ to represent \emph{objects}.
As we mentioned in Chapter \ref{chap:typedlua}, we need the type
$\Self$ to prevent programmers from indexing a method without
calling it with the correct receiver.
The type $\Self$ is only a subtype of itself:
\[
\begin{array}{c}
\mylabel{S-SELF}\\
\senv \vdash \Self \subtype \Self
\end{array}
\]

Union types represent types that can hold a value of several
different, but fixed types.
Next we show the subtyping rules for union types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION1}\\
\dfrac{\senv \vdash t_{1} \subtype t \;\;\;
       \senv \vdash t_{2} \subtype t}
      {\senv \vdash t_{1} \cup t_{2} \subtype t}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION2}\\
\dfrac{\senv \vdash t \subtype t_{1}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION3}\\
\dfrac{\senv \vdash t \subtype t_{2}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\end{array}
\]

The first rule shows that a union type $t_{1} \cup t_{2}$
is subtype of $t$ if both $t_{1}$ and $t_{2}$ are subtypes
of $t$;
and the other rules show that a type $t$ is subtype
of a union type $t_{1} \cup t_{2}$ if $t$ is subtype of
$t_{1}$ or if $t$ is subtype of $t_{2}$.

Union types are disjoint, that is, the types in the union are not
consistent-subtype of any other type in the same union.
For instance, the union type $\Boolean \;\cup\; \Any$ results the
type $\Any$, because $\Boolean \lesssim \Any$;
and the union type $\Number \;\cup\; \Nil \;\cup\; 1$ results the union
type $\Number \;\cup\; \Nil$ because $1 \lesssim \Number$.

\emph{/* Do we need to show how Typed Lua simplifies union types? */}

To introduce function types we first need to introduce
second-level types, as they appear on both sides of function types.
Second-level types are tuples of first-level types
that can optionally end with a variadic type.
Our type system needs second-level types because tuples are
not first-class values in Lua, though they may appear on
argument passing, multiple returns, and multiple assignments.
A variadic type $t*$ is a generator for a sequence of values of
type $t \cup \Nil$, and it represents the type of the vararg
expression.
Next we show their subtyping rules:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VARARG}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1}* \subtype t_{2}*}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE1}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash s_{1} \subtype s_{2}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2} \times s_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-TUPLE2}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \;\;\;
       \senv \vdash t_{1}* \subtype s_{2}}
      {\senv \vdash t_{1}* \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE3}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \cup \Nil \;\;\;
       \senv \vdash s_{1} \subtype t_{2}*}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2}*}
\end{array}
\end{array}
\]

The subtyping rules for variadic and tuple types show that
these types are covariant.
The subtyping rule for variadic types is straightforward:
it shows that a variadic type $t_{1}*$ is subtype of another
variadic type $t_{2}*$ if $t_{1} \cup \Nil$ is subtype of
$t_{2} \cup \Nil$.
The first rule for tuple types shows that a tuple type
$t_{1} \times s_{1}$ is subtype of another tuple type
$t_{2} \times s_{2}$ if $t_{1}$ is subtype of $t_{2}$
and $s_{1}$ is subtype of $s_{2}$.
A tuple type can optionally end with a variadic type, and
the rules \textsc{S-TUPLE2} and \textsc{S-TUPLE3} handle this case.
The rule \textsc{S-TUPLE2} shows that a variadic type is subtype of
a tuple type whenever the type of the value that it generates is
subtype of all the elements of the tuple.
The rule \textsc{S-TUPLE3} shows that a tuple type is subtype of a
variadic type whenever all the elements of the tuple are subtype of
the type of the value that it generates.
We shall see that these subtyping relations along with the
types $\Value$ and $\Nil$ allow our type system to reflect
the semantics of Lua on discarding extra parameters and
replacing missing parameters.

In our type system function types have the form $p \rightarrow r$,
where $p$ is the type of the parameters list and $r$ is the
return type.
The type of the parameters list can be $\Void$ or a tuple type,
while the return type can be $\Void$, a tuple type, or a union of
tuple types.
The type $\Void$ means an empty tuple.
Our type system includes union of tuples on the return type because
in Lua it is common to overload the return type to denote error,
as we mentioned in Section \ref{sec:statistics}.

The type $\Void$ and union of tuple types are also second-level types.
The type $\Void$ is subtype only of itself.
The subtyping rules for union of tuple types are similar to the
subtyping rules for union of first-level types.
Next we show the subtyping rules for these second-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VOID}\\
\senv \vdash \Void \subtype \Void
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-UNION4}\\
\dfrac{\senv \vdash s_{1} \subtype s \;\;\;
       \senv \vdash s_{2} \subtype s}
      {\senv \vdash s_{1} \sqcup s_{2} \subtype s}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION5}\\
\dfrac{\senv \vdash s \subtype s_{1}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION6}\\
\dfrac{\senv \vdash s \subtype s_{2}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\end{array}
\]

The subtyping rule for function types is standard, that is, it is
contravariant on the type of the parameters list and
covariant on the return type:
\[
\begin{array}{c}
\mylabel{S-FUNCTION}\\
\dfrac{\senv \vdash p_{2} \subtype p_{1} \;\;\;
       \senv \vdash r_{1} \subtype r_{2}}
      {\senv \vdash p_{1} \rightarrow r_{1} \subtype p_{2} \rightarrow r_{2}}
\end{array}
\]

Our type system includes table types to represent Lua tables.
The syntactical form of table types is $\{ k_{i}{:}v_{i}, ..., k_{n}{:}v_{n} \}_{tag}$.
When $n = 0$, then $i = 0$ and it represents the type of an empty table.
When $n > 0$, then $i$ varies from 1 to $n$, each $k_{i}$ represents
the type of a table key, and each $v_{i}$ represents the type of the
value that the table key $k_{i}$ maps to.
We restricted the type of keys to literal types, base types, and the dynamic type,
but we can use any first-level type to represent the type of values they map to.
We made this restriction to the type of the keys because the statistics
that we discussed in Section \ref{sec:statistics} showed that most
of the tables are records, lists, and hashes.
The dynamic type is an option when we need a more loosen table type.

We also use the tags \emph{closed}, \emph{open}, and \emph{unique}
to classify table types, though they have only one syntactical form.
The first tag represents the table types that the type annotations,
interface, and userdata declarations describe.
The second tag represents the table types that we can use field assignment
to add new fields to them.
The third tag represents the table types of table constructors.
We have different subtyping rules for table types according to their
tags.
We will discuss these subtyping rules in the next paragraphs to
explain why we needed different tags.

The following subtyping rule shows that \emph{closed} table types
have width subtyping, and depth subtyping on $\Const$ fields;
it resembles the subtyping rule for record types.

\[
\begin{array}{c}
\mylabel{S-TABLE1}\\
\dfrac{\forall i \in 1..n \; \exists j \in 1..m \;\;\;
       \senv \vdash k_{j} \subtype k_{i}' \;\;\;
       \senv \vdash k_{i}' \subtype k_{j} \;\;\;
       \senv \vdash v_{j} \subtype_{c} v_{i}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{closed} \subtype \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}}
\end{array}
\]

The rule \textsc{S-TABLE1} introduced the relation $\subtype_{c}$.
It is just an auxiliary relation that defines the subtyping of the
type of the values stored in table fields.
We needed an auxiliary relation because the subtyping of the type
of the values stored in the table fields change according to the
tag of the table type.
For closed tables, subtyping handles mutable fields invariantly,
and immutable fields covariantly.
The following rules define this behavior.
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD1}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2} \;\;\;
       \senv \vdash v_{2} \subtype v_{1}}
      {\senv \vdash v_{1} \subtype_{c} v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD2}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD3}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\end{array}
\]

There are two limitations on \emph{closed} table types that led us to
introduce \emph{open} and \emph{unique} table types.
First, they do not allow programmers to use the table constructor to
initialize table types that include optional fields.
For instance,
\begin{align*}
\{ & ``firstname":\String, ``lastname":\String \}_{closed} \not \subtype\\
\{ & ``firstname":\String,\\
  &  ``middlename":\String \cup \Nil, ``lastname":\String \}_{closed}
\end{align*}
Second, they do not allow programmers to use the table constructor to
initialize table types that represent hashes.
For instance,
\begin{align*}
\{ & ``x":\Number, ``y":\Number, ``z":\Number \}_{closed} \not \subtype\\
\{ & \String:\Number \cup \Nil\}_{closed}
\end{align*}

We introduced \emph{open} table types to allow the refinement
of table types, and also to allow programmers to omit optional
fields in the initialization of table types.
To do that, we defined a subtyping rule that allow \emph{open}
table types to omit fields when $\Nil$ is subtype of the type of
the value of the omitted key.
The following subtyping rule show this behavior:
\[
\begin{array}{c}
\mylabel{S-TABLE2}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{c} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{open} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open}}
\end{array}
\]

The rule \textsc{S-TABLE2} introduced the relation $\subtype_{o}$.
It is an auxiliary relation that defines the subtyping relation
on optional fields, and we defined it as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD4}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} v}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD5}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} \Const \; v}
\end{array}
\end{array}
\]

Although \emph{open} table types let programmers omit optional fields,
they do not let programmers initialize optional fields that are
mutable, unless they use the same type of the field in the initialization.
For instance,
\begin{align*}
\{ & ``firstname":\String,\\
   & ``middlename":\String, ``lastname":\String \}_{open} \not \subtype \\
\{ & ``firstname":\String, \\
   & ``middlename":\String \cup \Nil, ``lastname":\String \}_{closed}
\end{align*}

We introduced \emph{unique} table types to solve this problem.
We use \emph{unique} table types to denote the type of the
table constructor.
The following subtyping rule allow programmers to use table constructors
to initialize and omit optional fields:
\[
\begin{array}{c}
\mylabel{S-TABLE3}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{u} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{unique} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open|unique}}
\end{array}
\]

The rule \textsc{S-TABLE3} introduced the relation $\subtype_{u}$.
It is an auxiliary relation that makes \emph{unique} table types
have width and depth subtyping on all fields, and we defined it
as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD6}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD7}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD8}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\end{array}
\]

Table types can be ambiguous.
For instance, $\{1:\Number, \Integer:\String\}$ is an ambiguous
table type because the type of the value stored by key $1$ can be
$\Number$ or $\String$, as $1 \subtype 1$ and
$1 \subtype \Integer$.
Table types can get even more ambiguous when we use the dynamic
type in the type of table keys.
For instance, the table type $\{1:\Number, \Integer:\String, \Any:\Boolean\}$
is ambiguous because the type of the value stored by key $1$ can be
$\Number$, or $\String$, or $\Boolean$, as $1 \subtype 1$,
$1 \subtype \Integer$, and $1 \lesssim \Any$.
Moreover, the type of the value stored by a key of type $\Integer$,
which is not the literal type $1$, can be $\Number$ or $\Boolean$,
as $\Integer \subtype \Integer$, and $\Integer \lesssim \Any$.

To avoid ambiguous table types we use the following rule to check
whether a table type is well formed:
\[
\forall i \not\exists j \; i \not= j \wedge k_{i} \lesssim k_{j}
\]

\emph{/* Can we use this well formed rule to allow $k$ to be $t$? */}

Our type system also includes recursive types: $\mu x.t$,
where $t$ is a function or table type with $x$ appearing anywhere
a function or table type could appear.
For instance, $\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed}$
represents the type of single linked list of numbers.

We use the \emph{Amber rule} from the Amber language
\citep{cardelli1986amber} to define the subtyping rule for
recursive types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-ASSUMPTION}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
      {\senv \vdash x_{1} \subtype x_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBER}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-AMBER} needs the rule \textsc{S-ASSUMPTION}
to show that $\mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}$.
The rule \textsc{S-ASSUMPTION} checks if the assumption
$x_{1} \subtype x_{2}$ exists in the set of assumptions $\senv$.
The rule \textsc{S-AMBER} extends the set of assumptions
with the assumption $x_{1} \subtype x_{2}$ to check whether
$t_{1} \subtype t_{2}$ or not.

Our type system does not infer recursive types, so we defined two
extra subtyping rules that handle the cases where they may
appear inside a table or function type:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-AMBERL}\\
\dfrac{\senv \vdash [x \mapsto \mu x.t_{1}]t_{1} \subtype t_{2}}
      {\senv \vdash \mu x.t_{1} \subtype t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBERR}\\
\dfrac{\senv \vdash t_{1} \subtype [x \mapsto \mu x.t_{2}]t_{2}}
      {\senv \vdash t_{1} \subtype \mu x.t_{2}}
\end{array}
\end{array}
\]

For instance, the rule \textsc{S-AMBERR} allows our type system
check whether the type of a table constructor is subtype of
a recursive type or not, as we show in the following example:
\begin{align*}
\{ & ``info":\Number, \\
   & ``next":\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed} \cup \Nil \}_{unique} \subtype \\
& \mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed}
\end{align*}

Our type system also introduces projection types, but they do not
appear on the subtyping and consistent-subtyping rules.
They are just a mechanism that the type system uses for handling
union of tuple types, when they appear on the right-hand side of
the declaration of local variables.
That is the reason why we do not need to define subtyping and
consistent-subtyping rules for them.
We will see projection types in more detail in the next section.

\section{Typing rules}

In this section we use a reduced core of Typed Lua to present the
most interesting typing rules of our type system.
It is also a reduced core of the Lua language with only if and while
control flow statements, without syntactic sugar, with explicit
type annotations, with explicit scope of local variables, and
with explicit declaration of methods.
We use this reduced core because it simplifies the presentation
of our type system.
Appendix \ref{app:rules} presents the full set of typing rules.

\begin{figure}[!ht]
\textbf{Abstract Syntax}\\
\dstart
$$
\begin{array}{rl}
s ::= & \;\; \mathbf{skip} \; | \;
s_{1} \; ; \; s_{2} \; | \;
\vec{l} = el \; | \;
m \; | \;
\mathbf{while} \; e \; \mathbf{do} \; s \; | \;
\mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}\\
& | \; \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s \; | \;
\mathbf{rec} \; n{:}t = f \; \mathbf{in} \; s \; | \;
\mathbf{return} \; el \; | \;
e(el)_{s} \; | \;
e{:}n(el)_{s}\\
e ::= & \;\; \mathbf{nil} \; | \;
c \; | \;
{...}_{e} \; | \;
n_{e} \; | \;
e_{1}[e_{2}] \; | \;
{<}t{>} \; n \; | \;
f \; | \;
\{ \} \; | \;
\{ \; \vec{p} \; \} \; | \;
\{ \; {...}_{m} \; \} \; | \;
\{ \; \vec{p},{...}_{m} \; \}\\
& | \; e_{1} + e_{2} \; | \;
e_{1} \; {..} \; e_{2} \; | \;
e_{1} == e_{2} \; | \;
e_{1} < e_{2} \; | \;
e_{1} \; \mathbf{and} \; e_{2} \; | \;
e_{1} \; \mathbf{or} \; e_{2} \\
& | \; \mathbf{not} \; e \; | \;
- e \; | \;
\# \; e \; | \;
e(el)_{e} \; | \;
e{:}n(el)_{e}\\
l ::= & \;\; n_{l} \; | \;
e_{1}[e_{2}] \; | \;
n[c] \; {<}t{>}\\
c ::= & \;\; \mathbf{false} \; | \;
\mathbf{true} \; | \;
{\it int} \; | \;
{\it float} \; | \;
{\it string}\\
p ::= & \;\; [e_{1}] = e_{2}\\
el ::= & \;\; \mathbf{nothing} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{e}, me\\
me ::= & \;\; e(el)_{m} \; | \;
e{:}n(el)_{m} \; | \;
{...}_{m}\\
m ::= & \;\; \mathbf{fun} \; n_{1}{:}n_{2} \; (){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; ({...}{:}t){:}r \; fb\\
& | \; \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
f ::= & \;\; \mathbf{fun} \; (){:}r \; fb \; | \;
\mathbf{fun} \; ({...}{:}t){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
fb ::= & \;\; s \;;\; \mathbf{return} \; el\\
n ::= & \;\; {\it name}\\
\end{array}
$$
\dend
\caption{Typed Lua abstract syntax}
\label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} presents the abstract syntax of core Typed Lua.
It splits the syntactic categories as follows:
$s$ are statements, $e$ are expressions, $l$ are left-hand values,
$el$ are expression lists, $c$ are literal constants, $p$ are expression pairs,
$me$ are expressions with multiple results, $f$ are function declarations,
$m$ are method declarations, $n$ are variable names,
$t$ are first-level types, and $r$ are second-level types.
The notation $\vec{n{:}t}$ denotes the non-empty list
$n_{1}{:}t_{1}, ..., n_{n}{:}t_{n}$.

Our reduced code also splits function application, method application, and
the vararg expression (${...}$) into different categories.
It uses $e(el)_{s}$ to denote function applications that return no value
because they appear as statements,
$e(el)_{e}$ to denote function applications that return only one value,
and $e(el)_{m}$ to denote function applications that return multiple values.
It uses the same categories for method applications, but only ${...}_{e}$
and ${...}_{m}$, as the vararg expression cannot appear as a statement.

We also included two kinds of type cast in our core language:
the expression ${<}t{>} \;n$ and the left-hand value $n[c] \; {<}t{>}$.
We will show that the first helps allowing safe aliasing between
table types, while the second allows the refinement of table types.
Due to the refinement of table types we also split variable names
into two categories: $n_{e}$ when they appear as expressions and
$n_{l}$ when they appear as left-hand values.

We will present the typing rules as a deduction system for the typing
relations $\env_{1} \vdash s : \env_{2}$ and $\env_{1} \vdash e : t, \env_{2}$. 
We will use the first one for typing statements, and the second one
for typing expressions.
The first relation means that given the type environment $\env_{1}$,
typing the statement $s$ produces the new type environment $\env_{2}$. 
The second relation means that given the type environment $\env_{1}$,
the expression $e$ has type $t$, and produces the new type environment $\env_{2}$.
We need two typing relations because only expressions have types,
though both expressions and statements can modify the environment.
The environment maps variables to types, and we will use $\env_{1}[n \mapsto t]$
for meaning that we extended the environment $\env_{1}$ with the
variable $n$ that maps to type $t$, and this mapping does not affect
the other mappings that existed before.

The most unusual feature of our type system is the refinement of
table types.
The rule \textsc{T-REFINE} allow us to add new keys to \emph{open}
and \emph{unique} table types:
\[
\begin{array}{c}
\mylabel{T-REFINE}\\
\dfrac{\env_{1}(n) = \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n} \}_{open|unique} \;\;\;
       \env_{1} \vdash c:t_{1}, \env_{2} \;\;\;
       \not \exists i \in 1..n \; t_{1} \lesssim k_{i}}
      {\env_{1} \vdash n[c] {<}t{>}:t, \env_{2}[n \mapsto \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, t_{1}{:}t\}_{open|unique}]}
\end{array}
\]

We restricted the refinement of table types to include only literal
keys because its purpose is to make it easier the construction of
table types that represent records.
For instance, 
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{1}{l}{$a[``y"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
uses field assignment to add fields $x$ and $y$ to the local $a$.
After these field assignments $a$ has type
$\{``x":\String, ``y":\Integer\}_{unique}$.

We do not allow the refinement of table types to change the type of
a field that is already present in the table type.
For instance,
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
do not type check, as we are trying to change the type of field
``x" from $\String$ to $\String \cup \Integer$.
More precisely, our type system does not allow the table type to
change towards a type that is not a subtype of the previous type.
In this example,
$\{``x":\String \cup \Integer\}_{unique} \not\subtype \{``x":\String\}_{unique}$.
We have this restriction because this kind of refinement could lead
to fields that have a too general type.

\textit{/* We need to close table types before assigning them to fields. */}
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in} \; a[``x"] \; {<}\{\}_{closed}{>} = \{\}$
\end{tabular}
\end{center}

Lua has multiple assignments, so Typed Lua also has to take this into
consideration while refining table types.
The rule \textsc{T-ASSINGMENT} shows that tuple types make it easy
to use the consistent-subtyping relation to type check multiple assignments:
\[
\begin{array}{c}
\mylabel{T-ASSIGNMENT}\\
\begin{array}{c}
\dfrac{\env_{1} \vdash el:r_{1}, \env_{2} \;\;\;
       \env_{2} \vdash \vec{l}:r_{2}, \env_{3} \;\;\;
       r_{1} \lesssim r_{2}}
      {\env_{1} \vdash \vec{l} = el:\env_{3}}
\end{array}
\end{array}
\]

This rule is so simple because we left the difficult part to the
type checking of expression lists.
The list of left-hand values is also a kind of expression list.
The difficult part is to check whether there is an expression in
the expression list that messes the environment, and the rule
\textsc{T-LHSLIST} captures this intuition:
\[
\begin{array}{c}
\mylabel{T-LHSLIST}\\
\dfrac{\env \vdash l_{k}:t_{k}, \env_{k} \;\;\;
       merge(\env_{1}, ..., \env_{n}) = \env_{m} \;\;\;
       n = |\;\vec{l}\;|}
      {\env \vdash \vec{l}:t_{1} \times ... \times t_{n} \times \Value{*}, \env_{m}}
\end{array}
\]

First, this rule uses the same environment $\env$ to type check each
left-hand side value $l_{k}$, as they can perform different changes
to the environment.
Then, it takes each type $t_{k}$ and builds the tuple type for
the assignment rule.
It places the type $\Value{*}$ in the end to discard extra values.
The rule succeeds if the predicate \emph{merge} can
produce a new environment, which includes all the modifications
of each environment $\env_{k}$.
Intuitively, the predicate \emph{merge} fails when an environment
tries to change the type of a variable towards a type that is not
a subtype of its previous type.

We can also use multiple assignments to refine table types:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>}, a[``y"] \; {<}\Integer{>} = ``foo", 1$}\\
\end{tabular}
\end{center}

This example type checks because all the environment changes are consistent, and
$``foo" \times 1 \times \Nil{*} \lesssim \String \times \Integer \times \Value{*}$.
The type of the expression list includes the type $\Nil{*}$ in the end
because our type system has typing rules to add this type when
the type of the expression list does not end with a variadic type.
Our type system has this behavior to use $\Nil$ in the place of missing
values, like Lua does.
This example uses the rule \textsc{T-EXPLIST2}, which is really close
to the rule \textsc{T-LHSLIST}:
\[
\begin{array}{c}
\mylabel{T-EXPLIST2}\\
\dfrac{\env \vdash e_{k}:t_{k}, \env_{k} \;\;\;
       merge(\env_{1}, ..., \env_{n}) = \env_{m} \;\;\;
       n = |\;\vec{e}\;|}
      {\env \vdash \vec{e}:t_{1} \times ... \times t_{n} \times \Nil{*}, \env_{m}}
\end{array}
\]

The next example does not type check because it tries to add
the same field to $a$, but with different types:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>}, a[``x"] \; {<}\Integer{>} = ``foo", 1$}\\
\end{tabular}
\end{center}

Typed Lua also keeps track whether it is safe or not safe to
change the type of a table, but before discussing this subject,
we will discuss the different table constructors that our
abstract syntax includes, as they will appear in the next
examples.

All the examples that we presented until now use the simplest form of
the table constructor: the empty table $\{\}$.
Its inference rule is straightforward:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR1}\\
\env \vdash \{\}:\{\}_{unique}, \env
\end{array}
\]

Our abstract syntax reduces the more complex uses of the table
constructor into three forms: $\{\;\vec{p}\;\}$, $\{\;{...}_{m}\;\}$,
and $\{\;\vec{p},{...}_{m}\;\}$.
The first one uses a list of expression pairs $[e_{1}] = e_{2}$,
the second one uses just the vararg expression, and the third one uses both.
We did not include in the abstract syntax a table constructor
that uses a list of expressions because we can write it using the first form.
For instance, we can write the table constructor
$\{ [1] = ``x", [2] = ``y", [3] = ``z" \}$ to express $\{ ``x", ``y", ``z" \}$.
We chose to not include this form because its inference rule is similar
to the inference rule of the first form, and just controls the type of
the omitted indices.
For the same reason we did not include table constructors with
multiple expressions, which can return a tuple type that does not end
with a variadic type.
We did include the vararg expression in the last position to show how
our type system can infer a table type that has a record part and
also an array part.

The inference rule \textsc{T-CONSTRUCTOR2} infers a table type for
the first form:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR2}\\
\dfrac{\env_{i} \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{unique}) = t}
      {\env_{1} \vdash \{\;\vec{p}\;\}:t, \env_{n+1}}
\end{array}
\]

This inference rule infers the type of each pair, uses these types
to build a table type, and uses the predicate \emph{wf} to check
whether the table type is well formed.
We gave the definition of this predicate in the last section.

The inference rules for expression pairs would be straightforward
if our table types allowed any type in the keys.
The rules \textsc{T-PAIR1}, \textsc{T-PAIR2}, and \textsc{T-PAIR3}
check if the type of the key is a subtype of $\Boolean$, $\Number$,
or $\String$, respectively:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-PAIR1}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Boolean}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-PAIR2}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Number}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-PAIR3}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \String}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}t_{2}, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-PAIR4} is a fallback for the previous rules,
but it works only if the type of the key does not include $\Nil$:
\[
\begin{array}{c}
\mylabel{T-PAIR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1}}
      {\env_{1} \vdash [e_{1}] = e_{2}: \Any{:}t_{2}, \env_{3}}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR2} along with the rules for expression
pairs allow Typed Lua to type check the following example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\String:\Integer \cup \Nil\}_{closed} = \{ [``x"] = 1, [``y"] = 2 \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\Integer \cup \Nil = a[``x"] \; \mathbf{in} \; b = a[``z"]$}
\end{tabular}
\end{center}

This example type checks because Typed Lua infers the table type
$\{``x":1, ``y":2\}_{unique}$, which is subtype of
$\{\String:\Integer \cup \Nil\}_{closed}$.
Even though the key $``z"$ does not exist in the table $a$,
the two table indexations type check with type $\Integer \cup \Nil$,
which is subtype of the type of $b$.
The rule \textsc{T-INDEX1} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-INDEX1}\\
\dfrac{\env_{1} \vdash e_{1}:\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3} \;\;\;
       \exists i \in 1{..}n \; t \lesssim k_{i}}
      {\env_{1} \vdash e_{1}[e_{2}]:v_{i}, \env_{3}}
\end{array}
\]

Typed Lua handles arrays as hashes that maps integers to some type $t$.
In Lua, programmers often use the vararg expression to initialize arrays.
The rules \textsc{T-CONSTRUCTOR3} and \textsc{T-CONSTRUCTOR4} define
the behavior of the vararg expression for this case:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-CONSTRUCTOR3}\\
\dfrac{\env_{1}({...}) = t}
      {\env_{1} \vdash \{{...}_{m}\}:\{\Integer{:}t \cup \Nil\}_{unique}, \env_{1}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-CONSTRUCTOR4}\\
\dfrac{\begin{array}{c}
       \env_{i} \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       \env_{i+1}({...}) = t_{v}\\
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, \Integer{:}t_{v} \cup \Nil\}_{unique}) = t_{t}
       \end{array}}
      {\env_{1} \vdash \{\;\vec{p},\;{...}_{m}\;\}:t_{t}, \env_{n+1}}
\end{array}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR3} type checks the case where we use
only the vararg expression inside a table constructor to initialize
an array.
If we assume that the $...$ is in the environment and has type $\String$,
the following example type checks through this rule:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\Integer:\String \cup \Nil\}_{closed} = \{ {...}_{m} \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\String \cup \Nil = t[1] \; \mathbf{in} \; b = t[5]$}
\end{tabular}
\end{center}

The rule \textsc{T-CONSTRUCTOR4} type checks the case where we use
the table constructor as a record that includes an array part.
If we assume that the $...$ is in the environment and has type $\String$,
the following example type checks through this rule:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\Integer, ``y":\Boolean, \Integer:\String \cup \Nil\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = \mathbf{true}, {...}_{m} \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; a[``x"] = ``bar"$}
\end{tabular}
\end{center}
but the next example does not type check because the record part
includes fields that the key types are subtype of the array part:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{1:\String, 10:\Boolean, \Integer:\String \cup \Nil\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [1] = ``foo", [10] = \mathbf{true}, {...}_{m} \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; a[``x"] = ``bar"$}
\end{tabular}
\end{center}

Making the inference rules of the table constructor infer an \emph{unique}
table type also allow us to use them for initializing record types that
have optional fields.
We can include the optional field in the initialization
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = ``bar", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}
and we can also omit it in the initialization
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}

After discussing the inference rules of the table constructor,
we can get back to the discussion about the refinement of table types.

Besides allowing the refinement of table types through field assignment,
Typed Lua also keeps track whether it is safe or not safe to change the
type of a table.
To do that, our type system always promotes an \emph{open}
table to \emph{closed} and an \emph{unique} table to \emph{open}
when they appear as expressions, or when they enter in a scope that is
not its declaration scope.
The order matters, as going from \emph{unique} to \emph{open}
before going from \emph{open} to \emph{closed} closes \emph{unique} table types.

The rule \textsc{T-IDREAD} uses the predicate \emph{close} to do
this promotion before we use a local variable:
\[
\begin{array}{c}
\mylabel{T-IDREAD}\\
\dfrac{\env_{1}(n) = t}
      {\env_{1} \vdash n_{e}:close(t), \env_{1}}
\end{array}
\]

This rule does not change the type of the local variable because it
just need to ensure that an alias will not get the same type.
For instance, it makes this unsafe example not type check:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{``x":\String \cup \Nil\}_{closed} = \{ [``x"] = ``foo" \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String \}_{unique} = \{ [``x"] = ``foo" \} \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a = b \;;\; a[``x"] = \mathbf{nil} \;;\; b[``x"] = b[``x"] \;{..}\; ``bar"$}
\end{tabular}
\end{center}

The assignment $a = b$ is not valid because the aliasing changed the
type of $b$ from $\{``x":\String\}_{unique}$ to $\{``x":\String\}_{open}$,
which is not subtype of $\{``x":\String \cup \Nil\}_{closed}$.

However, sometimes we want to use \emph{unique} table types to initialize
\emph{closed} table types, as they allow us to initialize optional fields.
To do that, Typed Lua includes a cast expression that allow us
to use an \emph{unique} table type before it becomes \emph{open}.
The rule \textsc{T-CAST} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-CAST}\\
\dfrac{t \subtype \env_{1}(n)}
      {\env_{1} \vdash {<}t{>} \; n:t, \env_{1}[n \mapsto t]}
\end{array}
\]

The rule \textsc{T-CAST} allow us to type check the following example:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{ \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{2}{l}{$a[``y"] \; {<}\String{>} = ``bar";$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String, ``y":\String \cup \Nil \}_{closed} =$}\\
& & \multicolumn{1}{l}{${<}\{``x":\String, ``y":\String \cup \Nil\}_{open}{>} \; a \; \mathbf{in} \; a[``z"] \; {<}\Integer{>} = 1$}
\end{tabular}
\end{center}

We can use $a$ to initialize $b$ because the cast expression converts
the type of $a$ from $\{``x":\String, ``y":\String\}_{unique}$ to
$\{``x":\String, ``y":\String \cup \Nil\}_{open}$, which is subtype of
$\{``x":\String, ``y":\String \cup \Nil\}_{closed}$.
We can continue to refine the type of $a$ after the aliasing,
as it still holds an \emph{open} table.
At the end of this example, $a$ has type
$\{``x":\String, ``y":\String \cup \Nil, ``z":\Integer\}_{open}$.

Even though the rule \textsc{T-CAST} handles the case that we assign
an alias to a variable, we still have to close this variable due to
safety.
The rule \textsc{T-LOCAL} is one example where we handle this case:
\[
\begin{array}{c}
\mylabel{T-LOCAL}\\
\dfrac{\env_{1} \vdash el:r_{1}, \env_{2} \;\;\;
       r_{1} \lesssim \vec{t} \;\;\;
       closeset(\env_{2}[\vec{n} \mapsto \vec{t}], fav(\mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s)) \vdash s:\env_{3}}
      {\env_{1} \vdash \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s:\env_{3} - \{\vec{n} \mapsto \vec{t}\}}
\end{array}
\]

This rule prevents the following unsafe example to type check:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}

We cannot add the field $``x"$ to $b$ because its type is \emph{closed},
and thus do not allow changing the value that is stored in the field $``x"$
of local $a$.

We also need to make sure to close all \emph{open} table types before we
type check another scope.
The rule \textsc{T-FUNCTION3} shows this case:
\[
\begin{array}{c}
\mylabel{T-FUNCTION3}\\
\dfrac{closeall(\env_{1}[\vec{n} \mapsto \vec{t}, \ret \mapsto r]) \vdash s:\env_{2}}
      {\env_{1} \vdash \mathbf{fun} \; (\vec{n{:}t}){:}r \; s:\vec{t} \rightarrow r, closeset(\env_{1}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))}
\end{array}
\]

This rule prevents the following unsafe example to type check:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{local} \; b:\Integer \times \Integer \rightarrow \Integer =$}\\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$}\\
& & & \multicolumn{1}{l}{$a[``z"] \; {<}\Integer{>} = 1; \; \mathbf{return} \; x + y$}\\
& \multicolumn{3}{l}{$\mathbf{in} \; a[``z"] \; {<}\String{>} = ``foo"$}
\end{tabular}
\end{center}

Typed Lua uses the refinement of table types to allow programmers to
build modules and objects.
It also allows Typed Lua to type check an object-oriented idiom that
programmers often use it.
\[
\begin{array}{c}
\mylabel{T-METHOD3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n_{1}) = \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{unique|open} \;\;\;
       \env_{1} \vdash n_{2} : l \;\;\;
       \not \exists i \in 1..n \; l \lesssim k_{i}\\
       closeall(\env_{1}[self \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed}, \vec{n} \mapsto \vec{t}, \ret \mapsto r]) \vdash s:\env_{2}
       \end{array}}
      {\begin{array}{c}
       \env_{1} \vdash \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; s:\\
       closeset(\env_{1}[n_{1} \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}, l{:}\Const \; \Self \times \vec{t} \rightarrow r\}_{unique|closed}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))
       \end{array}}
\end{array}
\]

The rule \textsc{T-METHOD3} allow our type system to type check the
following example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{open} = \{ [``x"] = 0.0, [``y"] = 0.0 \}$}\\
\multicolumn{4}{l}{$\mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; s{:}new (x:\Number, y:\Number):\Self$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{closed} =$}\\
& & & \multicolumn{1}{l}{$setmetatable(\{\}, \{ [``\string_\string_index"] = self \})$}\\
& & \multicolumn{2}{l}{$\mathbf{in} \; s[``x"] = x; \; s[``y"] = y; \; \mathbf{return} \; s$}\\
; & \multicolumn{3}{l}{$\mathbf{fun} \; s{:}move (x:\Number, y:\Number):\Void$}\\
& & \multicolumn{2}{l}{$self[``x"] = self[``x"] + x;$}\\
& & \multicolumn{2}{l}{$self[``y"] = self[``y"] + y$}
\end{tabular}
\end{center}

This example uses the type $\{``x":\Number, ``y":\Number\}_{open}$ to
initialize the local variable $s$, which represents the type of the class
that we are defining.
Then, we use two method definitions to include $new$ and $move$ into
our class that now has type
\begin{align*}
\{ & ``x":\Number, ``y":\Number,\\
   & ``new":\Self \times \Number \times \Number \rightarrow \Self,\\
   & ``move":\Self \times \Number \times \Number \rightarrow \Void \}_{open}
\end{align*}

Inside the definition of the method \emph{new} we use \emph{setmetatable}
to initialize the local $s$ with the type of $\Self$.
The rule \textsc{T-SETMETATABLE} express this idea:
\[
\begin{array}{c}
\mylabel{T-SETMETATABLE}\\
\dfrac{\env_{1} \vdash e:t, \env_{2} \;\;\;
       t \subtype \{\}_{open}}
      {\env_{1} \vdash setmetatable(\{\}, \{[``\string_\string_index"] = e\}):close(t), \env_{2}}
\end{array}
\]

After we define our class, we can use it to create object instances
of this class and call its methods.
The next example assumes the object $o$ is in the environment as
has the type of the class we just defined:
\begin{center}
\begin{tabular}{l}
$o{:}move(10, 10)_{s}$
\end{tabular}
\end{center}

This method call type checks through the rule \textsc{T-INVOKESTM1}.
This rule uses the inference rule \textsc{T-INVOKE1} and discards the results.
We defined the rule \textsc{T-INVOKE1} as follows:
\[
\begin{array}{c}
\mylabel{T-INVOKE1}\\
\dfrac{\env_{1} \vdash e:t, \env_{2} \;\;\;
       \env_{2} \vdash e[n]:p_{1} \rightarrow r, \env_{3} \;\;\;
       \env_{3} \vdash el:p_{2}, \env_{4} \;\;\;
       \Self \times p_{2} \lesssim p_{1}}
      {\env_{1} \vdash e{:}n(el)_{m}:[\Self \mapsto t]r, \env_{4}}
\end{array}
\]

Multiple assignments and multiple return values can also appear in
function applications, as the following example shows:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; m:\Void \rightarrow \Integer \times \String =$} \\
& \multicolumn{3}{l}{$\mathbf{fun} \; ():\Integer \times \String$} \\
& & \multicolumn{2}{l}{$\mathbf{return} \; 2, ``foo"$} \\
\multicolumn{4}{l}{$\mathbf{in}$} \\
& \multicolumn{3}{l}{$\mathbf{local} \; s:\Integer \times \Integer \rightarrow \Integer =$} \\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$} \\
& & & \multicolumn{1}{l}{$\mathbf{return} \; x + y$} \\
& \multicolumn{3}{l}{$\mathbf{in} \; s(m()_{e}, m()_{m})_{s}$}
\end{tabular}
\end{center}

This example does not type check because we are trying to call
$s$ with $\Integer \times \Integer \times \String$,
but its input parameter has type $\Integer \times \Integer$.
Lua drops extra values in function calls, and Typed Lua can also
have this behavior.
If we change the input type of $s$ to $\Integer \times \Integer \times \Value{*}$,
this example type checks.
Typed Lua also has to adjust function calls to use $\Nil$ in the
place of missing parameters, otherwise it would not be able to
type check function calls that have optional parameters.

\textit{/* I guess we should have different typing rules for strict and default. */}

Typed Lua includes four typing rules to handle the $\mathbf{or}$
logical operator and its common idioms:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR1}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \Nil \not\lesssim t \;\;\;
       \False \not\lesssim t}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR2}\\
\dfrac{\env_{1} \vdash e_{1}:\Nil, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-OR3}\\
\dfrac{\env_{1} \vdash e_{1}:\False, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-OR1} is the rule that implements the short circuit.
We use the consistent-subtyping relation in this rule to guarantee that
the type system checks the second expression when the first one
has the dynamic type, as it can be hiding a false value.

The rules \textsc{T-OR2} and \textsc{T-OR3} guarantee that the final
result is the type of the second expression, because the first one
is certainly a false value.

The rule \textsc{T-OR4} is the most general rule, but it is also
the rule that handles the common $\mathbf{or}$ idioms.
It uses the predicate \emph{filter} to filter possible false values
that might be part of the type of the first expression.
We can use pattern matching to the define the recursive predicate
\emph{filter} as follows:
\begin{align*}
filter(t_{1} \cup t_{2}, t_{1}) & = filter(t_{2}, t_{1})\\
filter(t_{1} \cup t_{2}, t_{2}) & = filter(t_{1}, t_{2})\\
filter(t_{1} \cup t_{2}, t_{3}) & = filter(t_{1}, t_{3}) \cup filter(t_{2}, t_{3})\\
filter(t_{1}, t_{2}) & = t_{1}
\end{align*}

Using these typing rules our type system can type check the following
example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\String \cup \Nil = \mathbf{nothing} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

Without the \emph{filter} predicate,
the expression $x \; \mathbf{or} \; ``Hello"$ would have type
$\String \cup \Nil \cup ``Hello"$.
The \emph{filter} predicate removes the type $\Nil$ from the result,
leaving type $\String \cup ``Hello"$.
At the end of the evaluation, the expression has type $\String$
because unions are disjoint and $``Hello" \subtype \String$.

\textit{/* The following example does not type check */}
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\Nil \cup \False = \mathbf{false} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

\textit{/* Should we define the following rules? */}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \cup \False \subtype t_{1} \;\;\;
       t_{1} \subtype \Nil \cup \False}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR5}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR6}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \Nil) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR7}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR8}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{1} \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

\textit{/* Or who writes this kind of code deserves a type error? */}

Another common idiom that programmers use in Lua is to overload
the input parameter of functions, and use the function \texttt{type}
to execute different actions according to their types.
\[
\begin{array}{c}
\mylabel{T-IF2}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = t\\
       closeall(\env_{1}[n \mapsto \String]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[n \mapsto filter(t, \String)) \vdash s_{2}:\env_{3}
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; type(n) == ``string" \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:closeset(\env_{1}[n \mapsto t], fav(s_{1}) \cup fav(s_{2}))}

\end{array}
\]

Using the rule \textsc{T-IF2}, Typed Lua can type check the following example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; o:\String \times \String \cup \Integer \rightarrow \String =$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; (a:\String, b:\String \cup \Integer):\String$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; r:\String = ``" \; \mathbf{in}$}\\
& & & \multicolumn{1}{l}{$\mathbf{if} \; type(b) == ``string" \; \mathbf{then} \; r = a \;{..}\;b \; \mathbf{else} \; r = rep(a, b)_{e}\; ;$}\\
& & & \multicolumn{1}{l}{$\mathbf{return} \; r$}\\
\multicolumn{4}{l}{$\mathbf{in} \; o(``foo", 2)_{s}$}
\end{tabular}
\end{center}

We are assuming that the function \emph{rep} is in the environment and has type
$\String \times \Integer \times \String \cup \Nil \rightarrow \String$.

Typed Lua also includes similar rules to handle the tags \texttt{nil},
\texttt{boolean}, and \texttt{number}.
There is also a similar rule for handling the type $\Integer$, but
it works only with Lua 5.3, as it depends on the function \texttt{math.type}.
This function appears only in Lua 5.3 and it returns the string $``integer"$
when its input parameter is a number that has an integer representation,
the string $``float"$ when its input parameter is a number that has a
floating point representation, or $\Nil$ otherwise.

Lua programmers also overload the return type of functions to denote
errors, and Typed Lua also handles this case with the rule \textsc{T-IF3}:
\[
\begin{array}{c}
\mylabel{T-IF3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = \pi_{i}\\
       closeall(\env_{1}[\pi \mapsto fpt(\env_{1}(\pi), \Nil, i)]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[\pi \mapsto gpt(\env_{1}(\pi), \Nil, i)) \vdash s_{2}:\env_{3}
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; n \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:closeset(\env_{1}, fav(s_{1}) \cup fav(s_{2}))}

\end{array}
\]

\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; q:\pi_{1}, r:\pi_{2} = idiv(1, 2)_{m} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{if} \; q \; \mathbf{then} \; print(q + r)_{s} \; \mathbf{else} \; print(``ERROR: " \; .. \; r)_{s}$}
\end{tabular}
\end{center}

\textit{/* How should we write the typing rule of the local declaration? */}

\textit{/* How this is valid if projection types do not have subtyping rules? */}

We are assuming that functions \emph{idiv} and \emph{print} are in
the environment with the respective types
$\Integer \times \Integer \rightarrow \Integer \times \Integer \sqcup \Nil \times \String$
and
$\Value{*} \rightarrow \Void$.

Lua has operator overloading, and allows the programmers to redefine
the behavior of some operations.
For instance, programmers can use metatables to redefine the
behavior of arithmetic operations.
Even though Typed Lua does not support operator overloading yet,
it includes typing rules that allow programmers to use the
dynamic type when they are using overloaded operations.
The following typing rules show how Typed Lua uses the dynamic type
to handle the overloading of arithmetic operations:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-ARITH5}\\
\dfrac{\env_{1} \vdash e_{1}:\Any, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-ARITH6}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:\Any, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-ARITH5} allows type checking the following
example:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Any = 1 \; \mathbf{in} \; x = x + 1$
\end{tabular}
\end{center}

This example is safe, but the following it is not:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Integer, \;y{:}\Any = 1 \; \mathbf{in} \; x = x + y$
\end{tabular}
\end{center}

Although this last example is not safe, it shows that optional
type systems still preserve the flexibility of dynamically
typed languages along with the benefits of static type checking.
