
In the previous chapter we presented an informal overview of Typed Lua.
We showed that programmers can use Typed Lua to combine static and dynamic
typing in the same code, and it allows them to incrementally migrate from
dynamic to static typing.
This is a benefit to programmers that use dynamically typed languages
to build large applications, as static types detect many bugs
during the development phase, and also provide better documentation.

In this chapter we present the formalization of Typed Lua.
Besides its practical contribution, Typed Lua also has some interesting
contributions on the field of optional type systems for scripting
languages.
Namely, it is a simple type system that covers several Lua idioms
and features, such as the refinement of tables, multiple return values,
and optional parameters.
We will use typing rules to explain how we implemented the features of Typed Lua.

\section{Types}

Our type system uses subtyping \citep{cardelli1984smi,abadi1996to} to order
types and consistent-subtyping \citep{siek2007objects,siek2013mutable}
to allow the interaction between statically and dynamically typed code.
We will explain the subtyping and consistent-subtyping rules along this
section while we introduce each type from our type system.
We will focus the discussion on the definition of subtyping because,
as we mentioned in Chapter \ref{chap:review}, we can combine the
consistency and subtyping relations to achieve consistent-subtyping.
The differences between subtyping and consistent-subtyping are the way
they handle the dynamic type, and the fact that subtyping is transitive,
but consistent-subtyping is not.

\begin{figure}[!ht]
\textbf{Type Language}\\
\dstart
$$
\begin{array}{rlr}
\multicolumn{3}{c}{\textbf{First-level types}}\\
t ::= & \;\; l & \textit{literal types}\\
& | \; b & \textit{base types}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; t \cup t & \textit{disjoint union types}\\
& | \; p \rightarrow r & \textit{function types}\\
& | \; \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed|open|unique} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.t & \textit{recursive types}\\
& | \; \pi_{i} & \textit{projection types}\\
l ::= & \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} & \\
b ::= & \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String & \\
k ::= & \;\; l \; | \; b \; | \; \Any & \textit{key types}\\
v ::= & \;\; t \; | \; \Const \; t & \textit{field types}\\ 
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{\textbf{Second-level types}}\\
s ::= & \;\; t &\\
& | \; t* & \textit{variadic types}\\
& | \; t \times s & \textit{tuple types}\\
p ::= & \;\; \Void \; | \; s & \textit{parameters list type}\\
r ::= & \;\; \Void \; | \; s \; | \; s \sqcup r & \textit{return types}\\
\end{array}
$$
\dend
\caption{The abstract syntax of Typed Lua types}
\label{fig:typelang}
\end{figure}

Figure \ref{fig:typelang} presents the abstract syntax of the
Typed Lua types.
Typed Lua splits types into two categories:
\emph{first-level types} and \emph{second-level types}.
Typed Lua uses first-level types to represent Lua values and
second-level types to represent expression lists, and it also
uses them to type multiple assignments and function applications.
First-level types include literal types, base types, the type $\Nil$,
the top type $\Value$, the dynamic type $\Any$, the type $\Self$,
union types, function types, table types, recursive types, and
projection types.
Second-level types include the type $\Void$, tuples of first-level
types optionally ending in a variadic type, and union of these tuples.

Literal types represent the type of literal values.
They can be the boolean values $\False$ and $\True$,
any integer value, any floating point value, and any string value.
We shall see that literal types are important to represet table types
as records.

Our type system also includes the following base types: $\Boolean$,
$\Integer$, $\Number$, and $\String$.
The base types $\Boolean$ and $\String$ represent the values that
during run-time Lua tags as \texttt{boolean} and \texttt{string},
respectively;
the base types $\Integer$ and $\Number$ represent the values
that during run-time Lua tags as \texttt{number}.
We introduced two different base types to represent Lua numbers
because Lua introduced integers in version 5.3.

The subtyping rules for literal types include a reflexive rule,
and the rules for defining that literal types are subtypes of
their respective base types;
the subtyping rules for base types include a reflexive rule,
and another rule for defining that $\Integer$ is subtype of
$\Number$.
We defined these subtyping rules as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-LITERAL}\\
\senv \vdash l \subtype l
\end{array}
\;
\begin{array}{c}
\mylabel{S-FALSE}\\
\senv \vdash \False \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-TRUE}\\
\senv \vdash \True \subtype \Boolean
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-INT1}\\
\senv \vdash {\it int} \subtype \Integer
\end{array}
\;
\begin{array}{c}
\mylabel{S-INT2}\\
\senv \vdash {\it int} \subtype \Number
\end{array}
\;
\begin{array}{c}
\mylabel{S-FLOAT}\\
\senv \vdash {\it float} \subtype \Number
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-STRING}\\
\senv \vdash {\it string} \subtype \String
\end{array}
\begin{array}{c}
\mylabel{S-BASE}\\
\senv \vdash b \subtype b
\end{array}
\;
\begin{array}{c}
\mylabel{S-NUMBER}\\
\senv \vdash \Integer \subtype \Number
\end{array}
\end{array}
\]

The variable $\senv$ is a set of pairs of recursion variables.
We shall notice that we need this set to record the pairs of valid
recursive types.

We could have omitted the rules \textsc{S-LITERAL}, \textsc{S-BASE},
and \textsc{S-INT2}, because the first two are reflexive and we
could achieve the third one trhough transitivity.
More precisely, we could have defined subsumption rules that
specify the reflexive and trasitive behavior of subtyping,
and use these rules instead of the ones we defined.
For instance, we would not need \textsc{S-INT2} because we could
use the transisitive subsumption rule to derive that
\[
\dfrac{\senv \vdash 1 \subtype \Integer \;\;\;
       \senv \vdash \Integer \subtype \Number}
      {\senv \vdash 1 \subtype \Number}
\]

However, we are using the subtyping rules as the template for defining
the consistent-subtyping rules, and consistent-subtyping is not
transitive.
More precisely, we want the subtyping and consistent-subtyping rules
to differ only in the way they handle the dynamic type.
Thus, we define the subtyping rules using an algorithmic
way that is close to the implementation, as this way allows us to use
subtyping to formalize consistent-subtyping.

The type $\Nil$ represents the type of values that during run-time
Lua tags as \texttt{nil}.
It is a separated type because in our type system $\Nil$ is
not the bottom type.
Typed Lua has this behavior because in Lua the tag \texttt{nil}
represents the absence of an useful value.
Thus, making $\Nil$ the bottom type would severally reduce the
amount of type safety in our type system.
The next subtyping rule shows this behavior:
\[
\begin{array}{c}
\mylabel{S-NIL}\\
\senv \vdash \Nil \subtype \Nil
\end{array}
\]

The type $\Value$ is the top type, so any first-level type is
subtype of $\Value$.
We shall see that this type along with variadic types help to
drop extra values on multiple assignments, and function calls,
thus preserving the semantics of Lua in these cases.
Following we show its subtyping rule:
\[
\begin{array}{c}
\mylabel{S-VALUE}\\
\senv \vdash t \subtype \Value
\end{array}
\]

The dynamic type $\Any$ is the type that allows programmers to mix
static and dynamic typing.
The type $\Any$ is neither the bottom nor the top type, but a
separated typed that is subtype only of itself:
\[
\begin{array}{c}
\mylabel{S-ANY}\\
\senv \vdash \Any \subtype \Any
\end{array}
\]

Even though the dynamic type $\Any$ is neutral to subtyping,
it is not to consistent-subtyping:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{C-ANY1}\\
\senv \vdash t \lesssim \Any
\end{array}
\;
\begin{array}{c}
\mylabel{C-ANY2}\\
\senv \vdash \Any \lesssim t
\end{array}
\end{array}
\]

The rules that handle the dynamic type are the only rules that
differ between subtyping and consistent-subtyping.
If we set the type $\Any$ as both bottom and top types of our
subtyping relation, then all programs would type check without errors.
This would happen due to the transitivity of subtyping, that is,
we would be able to down-cast any type to $\Any$ and then up-cast
$\Any$ to any type.
While the rule \textsc{S-ANY} is neutral and makes transitivity
not be a problem, the rules \textsc{C-ANY1} and \textsc{C-ANY2}
are the rules that allow the dynamic type to interact with other
first-level types, and thus allow dynamically typed code coexist
with statically typed code.
Because of these two rules consistent-subtyping cannot be transitive.

Typed Lua uses the type $\Self$ to represent \emph{objects}.
As we mentioned in Chapter \ref{chap:typedlua}, we need the type
$\Self$ to prevent programmers from indexing a method without
calling it with the correct receiver.
The type $\Self$ is only a subtype of itself:
\[
\begin{array}{c}
\mylabel{S-SELF}\\
\senv \vdash \Self \subtype \Self
\end{array}
\]

Union types represent types that can hold a value of several
different, but fixed types.
Next we show the subtyping rules for union types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION1}\\
\dfrac{\senv \vdash t_{1} \subtype t \;\;\;
       \senv \vdash t_{2} \subtype t}
      {\senv \vdash t_{1} \cup t_{2} \subtype t}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION2}\\
\dfrac{\senv \vdash t \subtype t_{1}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION3}\\
\dfrac{\senv \vdash t \subtype t_{2}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\end{array}
\]

The first rule shows that a union type $t_{1} \cup t_{2}$
is subtype of $t$ if both $t_{1}$ and $t_{2}$ are subtypes
of $t$;
and the other rules show that a type $t$ is subtype
of a union type $t_{1} \cup t_{2}$ if $t$ is subtype of
$t_{1}$ or if $t$ is subtype of $t_{2}$.

Union types are disjoint, that is, the types in the union are not
consistent-subtype of any other type in the same union.
For instance, the union type $\Boolean \;\cup\; \Any$ results the
type $\Any$, because $\Boolean \lesssim \Any$;
and the union type $\Number \;\cup\; \Nil \;\cup\; 1$ results the union
type $\Number \;\cup\; \Nil$ because $1 \lesssim \Number$.

\emph{/* Do we need to show how Typed Lua simplifies union types? */}

To introduce function types we first need to introduce
second-level types, as they appear on both sides of function types.
Second-level types are tuples of first-level types
that can optionally end with a variadic type.
Our type system needs second-level types because tuples are
not first-class values in Lua, though they may appear on
argument passing, multiple returns, and multiple assignments.
A variadic type $t*$ is a generator for a sequence of values of
type $t \cup \Nil$, and it represents the type of the vararg
expression.
Next we show their subtyping rules:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VARARG}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1}* \subtype t_{2}*}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE1}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash s_{1} \subtype s_{2}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2} \times s_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-TUPLE2}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \;\;\;
       \senv \vdash t_{1}* \subtype s_{2}}
      {\senv \vdash t_{1}* \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE3}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \cup \Nil \;\;\;
       \senv \vdash s_{1} \subtype t_{2}*}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2}*}
\end{array}
\end{array}
\]

The subtyping rules for variadic and tuple types show that
these types are covariant.
The subtyping rule for variadic types is straightforward:
it shows that a variadic type $t_{1}*$ is subtype of another
variadic type $t_{2}*$ if $t_{1} \cup \Nil$ is subtype of
$t_{2} \cup \Nil$.
The first rule for tuple types shows that a tuple type
$t_{1} \times s_{1}$ is subtype of another tuple type
$t_{2} \times s_{2}$ if $t_{1}$ is subtype of $t_{2}$
and $s_{1}$ is subtype of $s_{2}$.
A tuple type can optionally end with a variadic type, and
the rules \textsc{S-TUPLE2} and \textsc{S-TUPLE3} handle this case.
The rule \textsc{S-TUPLE2} shows that a variadic type is subtype of
a tuple type whenever the type of the value that it generates is
subtype of all the elements of the tuple.
The rule \textsc{S-TUPLE3} shows that a tuple type is subtype of a
variadic type whenever all the elements of the tuple are subtype of
the type of the value that it generates.
We shall see that these subtyping relations along with the
types $\Value$ and $\Nil$ allow our type system to reflect
the semantics of Lua on discarding extra parameters and
replacing missing parameters.

In our type system function types have the form $p \rightarrow r$,
where $p$ is the type of the parameters list and $r$ is the
return type.
The type of the parameters list can be $\Void$ or a tuple type,
while the return type can be $\Void$, a tuple type, or a union of
tuple types.
The type $\Void$ means an empty tuple.
Our type system includes union of tuples on the return type because
in Lua it is common to overload the return type to denote error,
as we mentioned in Section \ref{sec:statistics}.

The type $\Void$ and union of tuple types are also second-level types.
The type $\Void$ is subtype only of itself.
The subtyping rules for union of tuple types are similar to the
subtyping rules for union of first-level types.
Next we show the subtyping rules for these second-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VOID}\\
\senv \vdash \Void \subtype \Void
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-UNION4}\\
\dfrac{\senv \vdash s_{1} \subtype s \;\;\;
       \senv \vdash s_{2} \subtype s}
      {\senv \vdash s_{1} \sqcup s_{2} \subtype s}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION5}\\
\dfrac{\senv \vdash s \subtype s_{1}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION6}\\
\dfrac{\senv \vdash s \subtype s_{2}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\end{array}
\]

The subtyping rule for function types is standard, that is, it is
contravariant on the type of the parameters list and
covariant on the return type:
\[
\begin{array}{c}
\mylabel{S-FUNCTION}\\
\dfrac{\senv \vdash p_{2} \subtype p_{1} \;\;\;
       \senv \vdash r_{1} \subtype r_{2}}
      {\senv \vdash p_{1} \rightarrow r_{1} \subtype p_{2} \rightarrow r_{2}}
\end{array}
\]

Our type system includes table types to represent Lua tables.
The syntactical form of table types is $\{ k_{i}{:}v_{i}, ..., k_{n}{:}v_{n} \}_{tag}$.
When $n = 0$, then $i = 0$ and it represents the type of an empty table.
When $n > 0$, then $i$ varies from 1 to $n$, each $k_{i}$ represents
the type of a table key, and each $v_{i}$ represents the type of the
value that the table key $k_{i}$ maps to.
We restricted the type of keys to literal types, base types, and the dynamic type,
but we can use any first-level type to represent the type of values they map to.
We made this restriction to the type of the keys because the statistics
that we discussed in Section \ref{sec:statistics} showed that most
of the tables are records, lists, and hashes.
The dynamic type is an option when we need a more loosen table type.

We also use the tags \emph{closed}, \emph{open}, and \emph{unique}
to classify table types, though they have only one syntactical form.
The first tag represents the table types that the type annotations,
interface, and userdata declarations describe.
The second tag represents the table types that we can use field assignment
to add new fields to them.
The third tag represents the table types of table constructors.
We have different subtyping rules for table types according to their
tags.
We will discuss these subtyping rules in the next paragraphs to
explain why we needed different tags.

The following subtyping rule shows that \emph{closed} table types
have width subtyping, and depth subtyping on $\Const$ fields;
it resembles the subtyping rule for record types.

\[
\begin{array}{c}
\mylabel{S-TABLE1}\\
\dfrac{\forall i \in 1..n \; \exists j \in 1..m \;\;\;
       \senv \vdash k_{j} \subtype k_{i}' \;\;\;
       \senv \vdash k_{i}' \subtype k_{j} \;\;\;
       \senv \vdash v_{j} \subtype_{c} v_{i}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{closed} \subtype \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}}
\end{array}
\]

The rule \textsc{S-TABLE1} introduced the relation $\subtype_{c}$.
It is just an auxiliary relation that defines the subtyping of the
type of the values stored in table fields.
We needed an auxiliary relation because the subtyping of the type
of the values stored in the table fields change according to the
tag of the table type.
For closed tables, subtyping handles mutable fields invariantly,
and imutable fields covariantly.
The following rules define this behavior.
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD1}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2} \;\;\;
       \senv \vdash v_{2} \subtype v_{1}}
      {\senv \vdash v_{1} \subtype_{c} v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD2}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD3}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\end{array}
\]

There are two limitations on \emph{closed} table types that led us to
introduce \emph{open} and \emph{unique} table types.
First, they do not allow programmers to use the table constructor to
initialize table types that include optional fields.
For instance,
\begin{align*}
\{ & ``firstname":\String, ``lastname":\String \}_{closed} \not \subtype\\
\{ & ``firstname":\String,\\
  &  ``middlename":\String \cup \Nil, ``lastname":\String \}_{closed}
\end{align*}
Second, they do not allow programmers to use the table construtor to
initialize table types that represent hashes.
For instance,
\begin{align*}
\{ & ``x":\Number, ``y":\Number, ``z":\Number \}_{closed} \not \subtype\\
\{ & \String:\Number \cup \Nil\}_{closed}
\end{align*}

We introduced \emph{open} table types to allow the refinement
of table types, and also to allow programmers to omit optional
fields in the initialization of table types.
To do that, we defined a subtyping rule that allow \emph{open}
table types to omit fields when $\Nil$ is subtype of the type of
the value of the ommited key.
The following subtyping rule show this behavior:
\[
\begin{array}{c}
\mylabel{S-TABLE2}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{c} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{open} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open}}
\end{array}
\]

The rule \textsc{S-TABLE2} introduced the relation $\subtype_{o}$.
It is an auxiliary relation that defines the subtyping relation
on optional fields, and we defined it as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD4}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} v}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD5}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} \Const \; v}
\end{array}
\end{array}
\]

Although \emph{open} table types let programmers omit optional fields,
they do not let programmers initialize optional fields that are
mutable, unless they use the same type of the field in the initialization.
For instance,
\begin{align*}
\{ & ``firstname":\String,\\
   & ``middlename":\String, ``lastname":\String \}_{open} \not \subtype \\
\{ & ``firstname":\String, \\
   & ``middlename":\String \cup \Nil, ``lastname":\String \}_{closed}
\end{align*}

We introduced \emph{unique} table types to solve this problem.
We use \emph{unique} table types to denote the type of the
table constructor.
The following subtyping rule allow programmers to use table constructors
to initialize and omit optional fields:
\[
\begin{array}{c}
\mylabel{S-TABLE3}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{u} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{unique} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open|unique}}
\end{array}
\]

The rule \textsc{S-TABLE3} introduced the relation $\subtype_{u}$.
It is an auxiliary relation that makes \emph{unique} table types
have width and depth subtyping on all fields, and we defined it
as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD6}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD7}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD8}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\end{array}
\]

Table types can be ambiguous.
For instance, $\{1:\Number, \Integer:\String\}$ is an ambiguous
table type because the type of the value stored by key $1$ can be
$\Number$ or $\String$, as $1 \subtype 1$ and
$1 \subtype \Integer$.
Table types can get even more ambiguous when we use the dynamic
type in the type of table keys.
For instance, the table type $\{1:\Number, \Integer:\String, \Any:\Boolean\}$
is ambiguous because the type of the value stored by key $1$ can be
$\Number$, or $\String$, or $\Boolean$, as $1 \subtype 1$,
$1 \subtype \Integer$, and $1 \lesssim \Any$.
Moreover, the type of the value stored by a key of type $\Integer$,
which is not the literal type $1$, can be $\Number$ or $\Boolean$,
as $\Integer \subtype \Integer$, and $\Integer \lesssim \Any$.

To avoid ambiguous table types we use the following rule to check
whether a table type is well formed:
\[
\forall i \not\exists j \; i \not= j \wedge k_{i} \lesssim k_{j}
\]

\emph{/* Can we use this well formed rule to allow $k$ to be $t$? */}

Our type system also includes recursive types: $\mu x.t$,
where $t$ is a function or table type with $x$ appearing anywhere
a function or table type could appear.
For instance, $\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed}$
represents the type of single linked list of numbers.

We use the \emph{Amber rule} from the Amber language
\citep{cardelli1986amber} to define the subtyping rule for
recursive types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-ASSUMPTION}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
      {\senv \vdash x_{1} \subtype x_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBER}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-AMBER} needs the rule \textsc{S-ASSUMPTION}
to show that $\mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}$.
The rule \textsc{S-ASSUMPTION} checks if the assumption
$x_{1} \subtype x_{2}$ exists in the set of assumptions $\senv$.
The rule \textsc{S-AMBER} extends the set of assumptions
with the assumption $x_{1} \subtype x_{2}$ to check whether
$t_{1} \subtype t_{2}$ or not.

Our type system does not infer recursive types, so we defined two
extra subtyping rules that handle the cases where they may
appear inside a table or function type:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-AMBERL}\\
\dfrac{\senv \vdash [x \mapsto \mu x.t_{1}]t_{1} \subtype t_{2}}
      {\senv \vdash \mu x.t_{1} \subtype t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBERR}\\
\dfrac{\senv \vdash t_{1} \subtype [x \mapsto \mu x.t_{2}]t_{2}}
      {\senv \vdash t_{1} \subtype \mu x.t_{2}}
\end{array}
\end{array}
\]

For instance, the rule \textsc{S-AMBERR} allows our type system
check whether the type of a table constructor is subtype of
a recursive type or not, as we show in the following example:
\begin{align*}
\{ & ``info":\Number, \\
   & ``next":\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed} \cup \Nil \}_{unique} \subtype \\
& \mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed}
\end{align*}

Our type system also introduces projection types, but they do not
appear on the subtyping and consistent-subtyping rules.
They are just a mechanism that the type system uses for handling
union of tuple types, when they appear on the right-hand side of
the declaration of local variables.
That is the reason why we do not need to define subtyping and
consistent-subtyping rules for them.
We will see projection types in more detail in the next section.

\section{Typing rules}

In this section we use a reduced core of Typed Lua to present the
most interesting typing rules of our type system.
It is also a reduced core of the Lua language with only if and while
control flow statements, without syntactic sugar, with explicit
type annotations, with explicit scope of local variables, and
with explicit declaration of methods.
We use this reduced core because it simplifies the presentation
of our type system.
Appendix \ref{app:rules} presents the full set of typing rules.

\begin{figure}[!ht]
\textbf{Abstract Syntax}\\
\dstart
$$
\begin{array}{rl}
s ::= & \;\; \mathbf{skip} \; | \;
s_{1} \; ; \; s_{2} \; | \;
ll = el_{1} \; | \;
m \; | \;
\mathbf{while} \; e \; \mathbf{do} \; s \; | \;
\mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}\\
& | \; \mathbf{local} \; \vec{n{:}t} = el_{0} \; \mathbf{in} \; s \; | \;
\mathbf{rec} \; n{:}t = f \; \mathbf{in} \; s \; | \;
\mathbf{return} \; el\\
& | \; e(el)_{s} \; | \;
e{:}n(el)_{s}\\
e ::= & \;\; \mathbf{nil} \; | \;
x \; | \;
{...}_{e} \; | \;
n \; | \;
e_{1}[e_{2}] \; | \;
{<}t{>} \; n \; | \;
f \; | \;
\{ \} \; | \;
\{ \; cl \; \} \\
& | \; e_{1} + e_{2} \; | \;
e_{1} \; {..} \; e_{2} \; | \;
e_{1} == e_{2} \; | \;
e_{1} < e_{2} \; | \;
e_{1} \; \mathbf{and} \; e_{2} \; | \;
e_{1} \; \mathbf{or} \; e_{2} \\
& | \; \mathbf{not} \; e \; | \;
- e \; | \;
\# \; e \; | \;
e(el)_{e} \; | \;
e{:}n(el)_{e}\\
x ::= & \;\; \mathbf{false} \; | \;
\mathbf{true} \; | \;
{\it int} \; | \;
{\it float} \; | \;
{\it string}\\
l ::= & \;\; n \; | \;
e_{1}[e_{2}] \; | \;
n[e] \; {<}t{>}\\
ll ::= & \;\; \vec{l}\\
el_{0} ::= & \;\; \mathbf{nothing} \; | \;
el_{1}\\
el_{1} ::= & \;\; \vec{e} \; | \;
me \; | \;
\vec{e}, me\\
el ::= & \;\; el_{0}\\
cl ::= & \;\; \vec{c} \; | \;
{...}_{m} \; | \;
\vec{c}, {...}_{m}\\
me ::= & \;\; e(el)_{m} \; | \;
e{:}n(el)_{m} \; | \;
{...}_{m}\\
m ::= & \;\; \mathbf{fun} \; n_{1}{:}n_{2} \; (){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; n_{1}{:}n_{2} \; ({...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t},{...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
f ::= & \;\; \mathbf{fun} \; (){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; ({...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; (\vec{n{:}t}){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; (\vec{n{:}t},{...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
c ::= & \;\; [e_{1}] = e_{2}\\
n ::= & \;\; {\it name}\\
\end{array}
$$
\dend
\caption{Typed Lua abstract syntax}
\label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} presents the abstract syntax of core Typed Lua.
It splits the syntactic categories as follows:
$s$ are statements, $e$ are expressions, $l$ are left-hand values,
$el$ are expression lists, $c$ are constructor fields, $cl$ are lists of
constructor fields, $me$ are expressions with multiple results,
$f$ are function declarations, $m$ are method declarations, $n$ are variable names,
$t$ are first-level types, and $r$ are second-level types.
The notation $\vec{n{:}t}$ denotes the non-empty list
$n_{1}{:}t_{1}, ..., n_{n}{:}t_{n}$.

Our reduced code also splits function application, method application, and
the vararg expression (${...}$) into different categories.
It uses $e(el)_{s}$ to denote function applications that return no value
because they appear as statements,
$e(el)_{e}$ to denote function applications that return only one value,
and $e(el)_{m}$ to denote function applications that return multiple values.
It uses the same categories for method applications, but only ${...}_{e}$
and ${...}_{m}$, as the vararg expression cannot appear as a statement.

We will present the typing rules as a deduction system for the typing
relations $\env_{1} \vdash s : \env_{2}$ and $\env_{1} \vdash e : t, \env_{2}$. 
We will use the first one for typing statements, and the sencond one
for typing expressions.
The first relation means that given the type environment $\env_{1}$,
typing the statement $s$ produces the new type environment $\env_{2}$. 
The sencond relation means that given the type environment $\env_{1}$,
the expression $e$ has type $t$, and produces the new type environment $\env_{2}$.
We need two typing relations because only expressions have types,
though both expressions and statements can modify the environment.
The environment maps variables to types, and we will use $\env_{1}[n \mapsto t]$
for meaning that we extended the environment $\env_{1}$ with the
variable $n$ that maps to type $t$, and this mapping does not affect
the other mappings that extisted before.

The most unusual feature of our type system is the refinement of
table types:
\[
\begin{array}{c}
\mylabel{T-REFINE}\\
\dfrac{\env_{1}(n) = \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n} \}_{open|unique} \;\;\;
       \env_{1} \vdash x:t_{1}, \env_{2} \;\;\;
       \not \exists i \in 1..n \; t_{1} \lesssim k_{i}}
      {\env_{1} \vdash n[x] {<}t{>}:t, \env_{2}[n \mapsto \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, t_{1}{:}t\}_{open|unique}]}
\end{array}
\]

The rule \textsc{T-REFINE} allow us to add new keys to \emph{open}
or \emph{unique} table types.
We restricted the keys to literals only because the purpose of
this rule is to make it easier to add new fields to table types
that represent records.
We also do not allow changing the type of a field that is already
in the table because this could lead to loosen table types that
have no static type checking. 
For instance, Typed Lua allows us to write the following code:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; t:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$t[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{1}{l}{$t[``y"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
but it does not allow us to write the following code:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; t:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$t[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{1}{l}{$t[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}

This example also uses the rule \textsc{T-CONSTRUCTOR1} to
infer the type of the empty table constructor:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR1}\\
\env \vdash \{\}:\{\}_{unique}, \env
\end{array}
\]

Typed Lua also has inference rules to infer table types that we
can use to initialize hashes, arrays, and records:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-CONSTRUCTOR2}\\
\dfrac{\env \vdash c:k_{i}{:}v_{i}, \env_{i} \;\;\;
       n = |\;\vec{c}\;| \;\;\;
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{unique})}
      {\env \vdash \{\;\vec{c}\;\}:\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{unique}, \env}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-CONSTRUCTOR3}\\
\dfrac{\env \vdash {...}:t, \env}
      {\env \vdash \{{...}_{m}\}:\{\Integer{:}t \cup \Nil\}_{unique}, \env}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-CONSTRUCTOR4}\\
\dfrac{\begin{array}{c}
       \env \vdash c:k_{i}{:}v_{i}, \env_{i} \;\;\;
       \env \vdash {...}:t, \env \;\;\;
       n = |\;\vec{c}\;| \\
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, \Integer{:}t \cup \Nil\}_{unique})
       \end{array}}
      {\env \vdash \{\;\vec{c},\;{...}_{m}\;\}:\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, \Integer{:}v \cup \Nil\}_{unique}, \env}
\end{array}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR2} type checks the following example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\String:\Integer \cup \Nil\}_{closed} = \{ [``x"] = 1, [``y"] = 2 \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\Integer \cup \Nil = a[``x"] \; \mathbf{in} \; x = a[``z"]$}
\end{tabular}
\end{center}

It also uses the rules \textsc{T-FIELD1} and \textsc{T-FIELD2}:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-FIELD1}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Boolean \cup \Number \cup \String}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}:super(t_{2}), \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-FIELD2}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1}}
      {\env_{1} \vdash [e_{1}] = e_{2}: \Any:super(t_{2}), \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-FIELD1} infers fields that keys are subype
of $\Boolean$, $\Number$, or $\String$.
The rule \textsc{T-FIELD2} infers fields thaty keys have the
dynamic type if its type does not include $\Nil$.

Typed Lua handles arrays as hashes that maps $\Integer$ to some
type $t$.
We did not include in the abstract syntax tree the simplified
syntax of table consturctors that initializes arrays because
we can write it using explicit indices.
For instance, we write the table constructor
$\{ [1] = ``x", [2] = ``y", [3] = ``z" \}$ to mean the table constructor
$\{ ``x", ``y", ``z" \}$.
We chose to make this simplification because the inference rules
for the simpflified version does not include anything new.
They are the same rules that just automatically control the indices.
For the same reason, we also omitted in the table constructor expressions
that return multiple results.
However, we did not omit the vararg expression in the last position
to show the case that we infer a record with an array part.

The rule \textsc{T-CONSTRUCTOR3} type checks the following example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\Integer:\String \cup \Nil\}_{closed} = \{ {...}_{m} \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\String \cup \Nil = t[1] \; \mathbf{in} \; b = t[5]$}
\end{tabular}
\end{center}

We are assuming that $...$ is in the environment as has type $\String$.

The rule \textsc{T-CONSTRUCTOR4} type checks the following example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\Integer, ``y":\Boolean, \Integer:\String \cup \Nil\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = \mathbf{true}, {...}_{m} \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; a[``x"] = ``bar"$}
\end{tabular}
\end{center}

We are also assuming that $...$ is in the environment as has type $\String$.

These rules along \emph{unique} table types also allow us initialize
record types that have optional fields.
We can include the optional field in the initialization
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = ``bar", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}
and we can also ommit it
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}

Typed Lua also keeps track whether it is safe or not safe to
change the type of a table.
To do that, our type system always promotes an \emph{open}
table to \emph{closed} and an \emph{unique} table to \emph{open}
when they appear as expressions.
The order also matters, as going from \emph{unique} to \emph{open}
before going from \emph{open} to \emph{closed} closes \emph{unique} tables.
The rule \textsc{T-IDREAD} along with the predicate \emph{close}
express this intuition:
\[
\begin{array}{c}
\mylabel{T-IDREAD}\\
\dfrac{\env_{1}(n_{r}) = t}
      {\env_{1} \vdash n_{r}:close(t), \env_{1}}
\end{array}
\]

The rule \textsc{T-IDREAD} makes this unsafe example not type check:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{``x":\String \cup \Nil\}_{closed} = \{ [``x"] = ``foo" \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String \}_{unique} = \{ [``x"] = ``foo" \} \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a = b \;;\; a[``x"] = \mathbf{nil}$}
\end{tabular}
\end{center}

The assignment $a = b$ is not valid because the aliasing changed the
type of $b$ from $\{``x":\String\}_{unique}$ to $\{``x":\String\}_{open}$,
which is not subtype of $\{``x":\String \cup \Nil\}_{closed}$.

However, sometimes we want to use \emph{unique} tables to initialize
closed tables, as they allow us to initialize optional fields.
To do that, Typed Lua includes a cast expression that allow us
to use the \emph{unique} table type before it becomes \emph{open}.
The rule \textsc{T-CAST} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-CAST}\\
\dfrac{t \subtype \env_{1}(n)}
      {\env_{1} \vdash {<}t{>} \; n:t, \env_{1}[n \mapsto t]}
\end{array}
\]

The rule \textsc{T-CAST} allow us to type check the following example:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{ \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{2}{l}{$a[``y"] \; {<}\String{>} = ``bar";$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String, ``y":\String \cup \Nil \}_{closed} =$}\\
& & \multicolumn{1}{l}{${<}\{``x":\String, ``y":\String \cup \Nil\}_{open}{>} \; a \; \mathbf{in} \; a[``z"] \; {<}\Integer{>} = 1$}
\end{tabular}
\end{center}

We can use $a$ to initialize $b$ because the cast expression converts
the type of $a$ from $\{``x":\String, ``y":\String\}_{unique}$ to
$\{``x":\String, ``y":\String \cup \Nil\}_{open}$, which is subtype of
$\{``x":\String, ``y":\String \cup \Nil\}_{closed}$.
We can continue to refine the type of $a$ after the aliasing,
as it still holds an \emph{open} table.
At the end of this example, $a$ has type
$\{``x":\String, ``y":\String \cup \Nil, ``z":\Integer\}_{open}$.

Refinement of table types (second example).
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}

Typed Lua uses the refinement of table types to express an object-oriented
idioms that is commonly used by Lua programmers.
\[
\begin{array}{c}
\mylabel{T-METHOD3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n_{1}) = \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{unique|open} \;\;\;
       \env_{1} \vdash n_{2} : l \;\;\;
       \not \exists i \in 1..n \; l \lesssim k_{i}\\
       closeall(\env_{1}[self \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed}, \vec{n} \mapsto \vec{t}, \ret \mapsto r]) \vdash s:\env_{2}
       \end{array}}
      {\begin{array}{c}
       \env_{1} \vdash \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; s:\\
       closeset(\env_{1}[n_{1} \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}, l{:}\Const \; \Self \times \vec{t} \rightarrow r\}_{unique|closed}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))
       \end{array}}
\end{array}
\]

\[
\begin{array}{c}
\mylabel{T-INVOKE1}\\
\dfrac{\env_{1} \vdash e[n]:p_{1} \rightarrow r, \env_{2} \;\;\;
       \env_{2} \vdash el:p_{2}, \env_{3} \;\;\;
       \Self \times p_{2} \lesssim p_{1}}
      {\env_{1} \vdash e{:}n(el)_{m}:r, \env_{3}}
\end{array}
\]

\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{open} = \{ [``x"] = 0.0, [``y"] = 0.0 \}$}\\
\multicolumn{4}{l}{$\mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; s{:}new (x:number, y:number):\Self$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{closed} =$}\\
& & & \multicolumn{1}{l}{$setmetatable(\{\}, \{ [``\string_\string_index"] = self \})$}\\
& & \multicolumn{2}{l}{$\mathbf{in} \; s[``x"] = x; \; s[``y"] = y; \; \mathbf{return} \; s$}\\
; & \multicolumn{3}{l}{$\mathbf{fun} \; s{:}move (x:number, y:number):\Void$}\\
& & \multicolumn{2}{l}{$self[``x"] = self[``x"] + x;$}\\
& & \multicolumn{2}{l}{$self[``y"] = self[``y"] + y$}
\end{tabular}
\end{center}

Lua has operator overloading, and allows the programmers to redefine
the behavior of some operations.
For instance, programmers can use metatables to redefine the
behavior of arithmetic operations.
Even though Typed Lua does not support operator overloading yet,
it includes typing rules that allow programmers to use the
dynamic type when they are using overloaded operations.
The following typing rules show how Typed Lua uses the dynamic type
to handle the overloading of arithmetic operations:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-ARITH5}\\
\dfrac{\env_{1} \vdash e_{1}:\Any, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-ARITH6}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:\Any, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-ARITH5} allows type checking the following
example:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Any = 1 \; \mathbf{in} \; x = x + 1$
\end{tabular}
\end{center}

This example is safe, but the following it is not:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Integer, \;y{:}\Any = 1 \; \mathbf{in} \; x = x + y$
\end{tabular}
\end{center}

\textit{/* Expression list rules. Where should we describe the
discarding/replacement of tuple elements? */}

Even though Lua has multiple assignments, the rule \textsc{T-ASSIGNMENT}
shows that tuples types and consistent-subtyping make straightforward
to type check them.
\[
\begin{array}{c}
\mylabel{T-ASSIGNMENT}\\
\begin{array}{c}
\dfrac{\env_{1} \vdash el:r_{1}, \env_{2} \;\;\;
       \env_{2} \vdash \vec{l}:r_{2}, \env_{3} \;\;\;
       r_{1} \lesssim r_{2}}
      {\env_{1} \vdash \vec{l} = el:\env_{3}}
\end{array}
\end{array}
\]

Multiple assignments and multiple return values can also appear in
function applications, as the following example shows:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; m:\Void \rightarrow \Integer \times \String =$} \\
& \multicolumn{3}{l}{$\mathbf{fun} \; ():\Integer \times \String$} \\
& & \multicolumn{2}{l}{$\mathbf{return} \; 2, ``foo"$} \\
\multicolumn{4}{l}{$\mathbf{in}$} \\
& \multicolumn{3}{l}{$\mathbf{local} \; s:\Integer \times \Integer \rightarrow \Integer =$} \\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$} \\
& & & \multicolumn{1}{l}{$\mathbf{return} \; x + y$} \\
& \multicolumn{3}{l}{$\mathbf{in} \; s(m()_{e}, m()_{m})_{s}$}
\end{tabular}
\end{center}

Typed Lua includes four typing rules to handle the $\mathbf{or}$
logical operator and its common idioms:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR1}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \Nil \not\lesssim t \;\;\;
       \False \not\lesssim t}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR2}\\
\dfrac{\env_{1} \vdash e_{1}:\Nil, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-OR3}\\
\dfrac{\env_{1} \vdash e_{1}:\False, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-OR1} is the rule that implements the short circuit.
We use the consistent-subtyping in this relation to guarantee that
the type system avaliates the second expression when the first one
has the dynamic type, as it can be hiding a false value.

The rules \textsc{T-OR2} and \textsc{T-OR3} guarantee that the final
result is the type of the second expression, because the first one
is certainly a false value.

The rule \textsc{T-OR4} is the most general rule, but it is also
the rule that handles the common $\mathbf{or}$ idioms.
It uses the predicate \emph{filter} to filter possible false values
that might be part of the type of the first expression.
We can use pattern matching to the define the recursive predicate
\emph{filter} as follows:
\begin{align*}
fu(t_{1} \cup t_{2}, t_{3}) & = fu(t_{1}, t_{3}) \cup fu(t_{2}, t_{3})\\
fu(t_{1} \cup t_{2}, t_{1}) & = fu(t_{2}, t_{1})\\
fu(t_{1} \cup t_{2}, t_{2}) & = fu(t_{1}, t_{2})\\
fu(t_{1}, t_{2}) & = t_{1}
\end{align*}

Using these typing rules our type system can type check the following
example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\String \cup \Nil = \mathbf{nothing} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

Without the \emph{filter} predicate,
the expression $x \; \mathbf{or} \; ``Hello"$ would have type
$\String \cup \Nil \cup ``Hello"$.
The \emph{filter} predicate removes the type $\Nil$ from the result,
leaving type $\String \cup ``Hello"$.
At the end of the evaluation, the expression has type $\String$
because unions are disjoint and $``Hello" \subtype \String$.

\textit{/* The following example does not type check */}
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\Nil \cup \False = \mathbf{false} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

\textit{/* Should we define the following rules? */}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \cup \False \subtype t_{1} \;\;\;
       t_{1} \subtype \Nil \cup \False}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR5}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR6}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \Nil) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR7}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR8}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{1} \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

\textit{/* Or who writes this kind of code deserves a type error? */}

Another common idiom that programmers use in Lua is to overload
the input parameter of functions, and use the function \texttt{type}
to execute different actions according to their types.
\[
\begin{array}{c}
\mylabel{T-IF2}\\
\dfrac{\begin{array}{c}
       closeall(\env_{1}[n \mapsto \String]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[n \mapsto filter(\env_{1}(n), \String)) \vdash s_{2}:\env_{3}
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; type(n) == ``string" \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:closeset(\env_{2}, fav(s_{1}) \cup fav(s_{2}))}

\end{array}
\]

Using the rule \textsc{T-IF2}, Typed Lua can type check the following example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; o:\String \times \String \cup \Integer \rightarrow \String =$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; (a:\String, b:\String \cup \Integer):\String$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; r:\String = ``" \; \mathbf{in}$}\\
& & & \multicolumn{1}{l}{$\mathbf{if} \; type(b) == ``string" \; \mathbf{then} \; r = a \;{..}\;b \; \mathbf{else} \; r = rep(a, b)_{e}\; ;$}\\
& & & \multicolumn{1}{l}{$\mathbf{return} \; r$}\\
\multicolumn{4}{l}{$\mathbf{in} \; o(``foo", 2)_{s}$}
\end{tabular}
\end{center}

We are assuming that the function \emph{rep} is in the environment and has type
$\String \times \Integer \times \String \cup \Nil \rightarrow \String$.

Typed Lua also includes similar rules to handle the tags \texttt{nil},
\texttt{boolean}, and \texttt{number}.

Overloading on the return type.
\[
\begin{array}{c}
\mylabel{T-IF3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = \pi_{i}\\
       closeall(\env_{1}[\pi \mapsto fpt(\env_{1}(\pi), \Nil, i)]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[\pi \mapsto gpt(\env_{1}(\pi), \Nil, i)) \vdash s_{2}:\env_{3}
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; n \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:closeset(\env_{2}, fav(s_{1}) \cup fav(s_{2}))}

\end{array}
\]

\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; q:\pi_{1}, r:\pi_{2} = idiv(1, 2)_{m} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{if} \; q \; \mathbf{then} \; print(q + r)_{s} \; \mathbf{else} \; print(``ERROR: " \; .. \; r)_{s}$}
\end{tabular}
\end{center}

\textit{/* How should we write the typing rule of the local declaration? */}

\textit{/* How this is valid if projection types do not have subtyping rules? */}

We are assuming that functions \emph{idiv} and \emph{print} are in
the environment with the respective types
$\Integer \times \Integer \rightarrow \Integer \times \Integer \sqcup \Nil \times \String$
and
$\Value{*} \rightarrow \Void$.


