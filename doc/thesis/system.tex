
In the previous chapter we presented an informal overview of Typed Lua.
We showed that programmers can use Typed Lua to combine static and dynamic
typing in the same code, and it allows them to incrementally migrate from
dynamic to static typing.
This is a benefit to programmers that use dynamically typed languages
to build large applications, as static types detect many bugs
during the development phase, and also provide better documentation.

In this chapter we present the formalization of Typed Lua.
Besides its practical contribution, Typed Lua also has some interesting
contributions on the field of optional type systems for scripting
languages.
Namely, it is a simple type system that covers several Lua idioms
and features, such as the refinement of tables, multiple return values,
and optional parameters.
We will use typing rules to explain how we implemented the features of Typed Lua.

\section{Types}

Our type system uses subtyping \citep{cardelli1984smi,abadi1996to} to order
types and consistent-subtyping \citep{siek2007objects,siek2013mutable}
to allow the interaction between statically and dynamically typed code.
We will explain the subtyping and consistent-subtyping rules along this
section while we introduce each type from our type system.
We will focus the discussion on the definition of subtyping because,
as we mentioned in Chapter \ref{chap:review}, we can combine the
consistency and subtyping relations to achieve consistent-subtyping.
The differences between subtyping and consistent-subtyping are the way
they handle the dynamic type, and the fact that subtyping is transitive,
but consistent-subtyping is not.

\begin{figure}[!ht]
\textbf{Type Language}\\
\dstart
$$
\begin{array}{rlr}
\multicolumn{3}{c}{\textbf{First-level types}}\\
t ::= & \;\; l & \textit{literal types}\\
& | \; b & \textit{base types}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; t \cup t & \textit{disjoint union types}\\
& | \; p \rightarrow r & \textit{function types}\\
& | \; \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed|open|unique} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.t & \textit{recursive types}\\
& | \; \pi_{i} & \textit{projection types}\\
l ::= & \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} & \\
b ::= & \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String & \\
k ::= & \;\; l \; | \; b \; | \; \Any & \textit{key types}\\
v ::= & \;\; t \; | \; \Const \; t & \textit{field types}\\ 
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{\textbf{Second-level types}}\\
s ::= & \;\; t &\\
& | \; t* & \textit{variadic types}\\
& | \; t \times s & \textit{tuple types}\\
p ::= & \;\; \Void \; | \; s & \textit{parameters list type}\\
r ::= & \;\; \Void \; | \; s \; | \; s \sqcup r & \textit{return types}\\
\end{array}
$$
\dend
\caption{The abstract syntax of Typed Lua types}
\label{fig:typelang}
\end{figure}

Figure \ref{fig:typelang} presents the abstract syntax of the
Typed Lua types.
Typed Lua splits types into two categories:
\emph{first-level types} and \emph{second-level types}.
Typed Lua uses first-level types to represent Lua values and
second-level types to represent expression lists, and it also
uses them to type multiple assignments and function applications.
First-level types include literal types, base types, the type $\Nil$,
the top type $\Value$, the dynamic type $\Any$, the type $\Self$,
union types, function types, table types, recursive types, and
projection types.
Second-level types include the type $\Void$, tuples of first-level
types optionally ending in a variadic type, and union of these tuples.

Literal types represent the type of literal values.
They can be the boolean values $\False$ and $\True$,
any integer value, any floating point value, and any string value.
We shall see that literal types are important to represet table types
as records.

Our type system also includes the following base types: $\Boolean$,
$\Integer$, $\Number$, and $\String$.
The base types $\Boolean$ and $\String$ represent the values that
during run-time Lua tags as \texttt{boolean} and \texttt{string},
respectively;
the base types $\Integer$ and $\Number$ represent the values
that during run-time Lua tags as \texttt{number}.
We introduced two different base types to represent Lua numbers
because Lua introduced integers in version 5.3.

The subtyping rules for literal types include a reflexive rule,
and the rules for defining that literal types are subtypes of
their respective base types;
the subtyping rules for base types include a reflexive rule,
and another rule for defining that $\Integer$ is subtype of
$\Number$.
We defined these subtyping rules as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-LITERAL}\\
\senv \vdash l \subtype l
\end{array}
\;
\begin{array}{c}
\mylabel{S-FALSE}\\
\senv \vdash \False \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-TRUE}\\
\senv \vdash \True \subtype \Boolean
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-INT1}\\
\senv \vdash {\it int} \subtype \Integer
\end{array}
\;
\begin{array}{c}
\mylabel{S-INT2}\\
\senv \vdash {\it int} \subtype \Number
\end{array}
\;
\begin{array}{c}
\mylabel{S-FLOAT}\\
\senv \vdash {\it float} \subtype \Number
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-STRING}\\
\senv \vdash {\it string} \subtype \String
\end{array}
\begin{array}{c}
\mylabel{S-BASE}\\
\senv \vdash b \subtype b
\end{array}
\;
\begin{array}{c}
\mylabel{S-NUMBER}\\
\senv \vdash \Integer \subtype \Number
\end{array}
\end{array}
\]

The variable $\senv$ is a set of pairs of recursion variables.
We shall notice that we need this set to record the pairs of valid
recursive types.

We could have omitted the rules \textsc{S-LITERAL}, \textsc{S-BASE},
and \textsc{S-INT2}, because the first two are reflexive and we
could achieve the third one trhough transitivity.
More precisely, we could have defined subsumption rules that
specify the reflexive and trasitive behavior of subtyping,
and use these rules instead of the ones we defined.
For instance, we would not need \textsc{S-INT2} because we could
use the transisitive subsumption rule to derive that
\[
\dfrac{\senv \vdash 1 \subtype \Integer \;\;\;
       \senv \vdash \Integer \subtype \Number}
      {\senv \vdash 1 \subtype \Number}
\]

However, we are using the subtyping rules as the template for defining
the consistent-subtyping rules, and consistent-subtyping is not
transitive.
More precisely, we want the subtyping and consistent-subtyping rules
to differ only in the way they handle the dynamic type.
Thus, we define the subtyping rules using an algorithmic
way that is close to the implementation, as this way allows us to use
subtyping to formalize consistent-subtyping.

The type $\Nil$ represents the type of values that during run-time
Lua tags as \texttt{nil}.
It is a separated type because in our type system $\Nil$ is
not the bottom type.
Typed Lua has this behavior because in Lua the tag \texttt{nil}
represents the absence of an useful value.
Thus, making $\Nil$ the bottom type would severally reduce the
amount of type safety in our type system.
The next subtyping rule shows this behavior:
\[
\begin{array}{c}
\mylabel{S-NIL}\\
\senv \vdash \Nil \subtype \Nil
\end{array}
\]

The type $\Value$ is the top type, so any first-level type is
subtype of $\Value$.
We shall see that this type along with variadic types help to
drop extra values on multiple assignments, and function calls,
thus preserving the semantics of Lua in these cases.
Following we show its subtyping rule:
\[
\begin{array}{c}
\mylabel{S-VALUE}\\
\senv \vdash t \subtype \Value
\end{array}
\]

The dynamic type $\Any$ is the type that allows programmers to mix
static and dynamic typing.
The type $\Any$ is neither the bottom nor the top type, but a
separated typed that is subtype only of itself:
\[
\begin{array}{c}
\mylabel{S-ANY}\\
\senv \vdash \Any \subtype \Any
\end{array}
\]

Even though the dynamic type $\Any$ is neutral to subtyping,
it is not to consistent-subtyping:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{C-ANY1}\\
\senv \vdash t \lesssim \Any
\end{array}
\;
\begin{array}{c}
\mylabel{C-ANY2}\\
\senv \vdash \Any \lesssim t
\end{array}
\end{array}
\]

The rules that handle the dynamic type are the only rules that
differ between subtyping and consistent-subtyping.
If we set the type $\Any$ as both bottom and top types of our
subtyping relation, then all programs would type check without errors.
This would happen due to the transitivity of subtyping, that is,
we would be able to down-cast any type to $\Any$ and then up-cast
$\Any$ to any type.
While the rule \textsc{S-ANY} is neutral and makes transitivity
not be a problem, the rules \textsc{C-ANY1} and \textsc{C-ANY2}
are the rules that allow the dynamic type to interact with other
first-level types, and thus allow dynamically typed code coexist
with statically typed code.
Because of these two rules consistent-subtyping cannot be transitive.

Typed Lua uses the type $\Self$ to represent \emph{objects}.
As we mentioned in Chapter \ref{chap:typedlua}, we need the type
$\Self$ to prevent programmers from indexing a method without
calling it with the correct receiver.
The type $\Self$ is only a subtype of itself:
\[
\begin{array}{c}
\mylabel{S-SELF}\\
\senv \vdash \Self \subtype \Self
\end{array}
\]

Union types represent types that can hold a value of several
different, but fixed types.
Next we show the subtyping rules for union types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION1}\\
\dfrac{\senv \vdash t_{1} \subtype t \;\;\;
       \senv \vdash t_{2} \subtype t}
      {\senv \vdash t_{1} \cup t_{2} \subtype t}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION2}\\
\dfrac{\senv \vdash t \subtype t_{1}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION3}\\
\dfrac{\senv \vdash t \subtype t_{2}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\end{array}
\]

The first rule shows that a union type $t_{1} \cup t_{2}$
is subtype of $t$ if both $t_{1}$ and $t_{2}$ are subtypes
of $t$;
and the other rules show that a type $t$ is subtype
of a union type $t_{1} \cup t_{2}$ if $t$ is subtype of
$t_{1}$ or if $t$ is subtype of $t_{2}$.

Union types are disjoint, that is, the types in the union are not
consistent-subtype of any other type in the same union.
For instance, the union type $\Boolean \;\cup\; \Any$ results the
type $\Any$, because $\Boolean \lesssim \Any$;
and the union type $\Number \;\cup\; \Nil \;\cup\; 1$ results the union
type $\Number \;\cup\; \Nil$ because $1 \lesssim \Number$.

\emph{/* Do we need to show how Typed Lua simplifies union types? */}

To introduce function types we first need to introduce
second-level types, as they appear on both sides of function types.
Second-level types are tuples of first-level types
that can optionally end with a variadic type.
Our type system needs second-level types because tuples are
not first-class values in Lua, though they may appear on
argument passing, multiple returns, and multiple assignments.
A variadic type $t*$ is a generator for a sequence of values of
type $t \cup \Nil$, and it represents the type of the vararg
expression.
Next we show their subtyping rules:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VARARG}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1}* \subtype t_{2}*}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE1}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash s_{1} \subtype s_{2}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2} \times s_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-TUPLE2}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \;\;\;
       \senv \vdash t_{1}* \subtype s_{2}}
      {\senv \vdash t_{1}* \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE3}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \cup \Nil \;\;\;
       \senv \vdash s_{1} \subtype t_{2}*}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2}*}
\end{array}
\end{array}
\]

The subtyping rules for variadic and tuple types show that
these types are covariant.
The subtyping rule for variadic types is straightforward:
it shows that a variadic type $t_{1}*$ is subtype of another
variadic type $t_{2}*$ if $t_{1} \cup \Nil$ is subtype of
$t_{2} \cup \Nil$.
The first rule for tuple types shows that a tuple type
$t_{1} \times s_{1}$ is subtype of another tuple type
$t_{2} \times s_{2}$ if $t_{1}$ is subtype of $t_{2}$
and $s_{1}$ is subtype of $s_{2}$.
A tuple type can optionally end with a variadic type, and
the rules \textsc{S-TUPLE2} and \textsc{S-TUPLE3} handle this case.
The rule \textsc{S-TUPLE2} shows that a variadic type is subtype of
a tuple type whenever the type of the value that it generates is
subtype of all the elements of the tuple.
The rule \textsc{S-TUPLE3} shows that a tuple type is subtype of a
variadic type whenever all the elements of the tuple are subtype of
the type of the value that it generates.
We shall see that these subtyping relations along with the
types $\Value$ and $\Nil$ allow our type system to reflect
the semantics of Lua on discarding extra parameters and
replacing missing parameters.

In our type system function types have the form $p \rightarrow r$,
where $p$ is the type of the parameters list and $r$ is the
return type.
The type of the parameters list can be $\Void$ or a tuple type,
while the return type can be $\Void$, a tuple type, or a union of
tuple types.
The type $\Void$ means an empty tuple.
Our type system includes union of tuples on the return type because
in Lua it is common to overload the return type to denote error,
as we mentioned in Section \ref{sec:statistics}.

The type $\Void$ and union of tuple types are also second-level types.
The type $\Void$ is subtype only of itself.
The subtyping rules for union of tuple types are similar to the
subtyping rules for union of first-level types.
Next we show the subtyping rules for these second-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VOID}\\
\senv \vdash \Void \subtype \Void
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-UNION4}\\
\dfrac{\senv \vdash s_{1} \subtype s \;\;\;
       \senv \vdash s_{2} \subtype s}
      {\senv \vdash s_{1} \sqcup s_{2} \subtype s}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION5}\\
\dfrac{\senv \vdash s \subtype s_{1}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION6}\\
\dfrac{\senv \vdash s \subtype s_{2}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\end{array}
\]

The subtyping rule for function types is standard, that is, it is
contravariant on the type of the parameters list and
covariant on the return type:
\[
\begin{array}{c}
\mylabel{S-FUNCTION}\\
\dfrac{\senv \vdash p_{2} \subtype p_{1} \;\;\;
       \senv \vdash r_{1} \subtype r_{2}}
      {\senv \vdash p_{1} \rightarrow r_{1} \subtype p_{2} \rightarrow r_{2}}
\end{array}
\]

Our type system includes table types to represent Lua tables.
The syntactical form of table types is $\{ k_{i}{:}v_{i}, ..., k_{n}{:}v_{n} \}_{tag}$.
When $n = 0$, then $i = 0$ and it represents the type of an empty table.
When $n > 0$, then $i$ varies from 1 to $n$, each $k_{i}$ represents
the type of a table key, and each $v_{i}$ represents the type of the
value that the table key $k_{i}$ maps to.
We restricted the type of keys to literal types, base types, and the dynamic type,
but we can use any first-level type to represent the type of values they map to.
We made this restriction to the type of the keys because the statistics
that we discussed in Section \ref{sec:statistics} showed that most
of the tables are records, lists, and hashes.
The dynamic type is an option when we need a more loosen table type.

We also use the tags \emph{closed}, \emph{open}, and \emph{unique}
to classify table types, though they have only one syntactical form.
The first tag represents the table types that the type annotations,
interface, and userdata declarations describe.
The second tag represents the table types that we can use field assignment
to add new fields to them.
The third tag represents the table types of table constructors.
We have different subtyping rules for table types according to their
tags.
We will discuss these subtyping rules in the next paragraphs to
explain why we needed different tags.

The following subtyping rule shows that \emph{closed} table types
have width subtyping, and depth subtyping on $\Const$ fields;
it resembles the subtyping rule for record types.

\[
\begin{array}{c}
\mylabel{S-TABLE1}\\
\dfrac{\forall i \in 1..n \; \exists j \in 1..m \;\;\;
       \senv \vdash k_{j} \subtype k_{i}' \;\;\;
       \senv \vdash k_{i}' \subtype k_{j} \;\;\;
       \senv \vdash v_{j} \subtype_{c} v_{i}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{closed} \subtype \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}}
\end{array}
\]

The rule \textsc{S-TABLE1} introduced the relation $\subtype_{c}$.
It is just an auxiliary relation that defines the subtyping of the
type of the values stored in table fields.
We needed an auxiliary relation because the subtyping of the type
of the values stored in the table fields change according to the
tag of the table type.
For closed tables, subtyping handles mutable fields invariantly,
and imutable fields covariantly.
The following rules define this behavior.
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD1}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2} \;\;\;
       \senv \vdash v_{2} \subtype v_{1}}
      {\senv \vdash v_{1} \subtype_{c} v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD2}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD3}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\end{array}
\]

There are two limitations on \emph{closed} table types that led us to
introduce \emph{open} and \emph{unique} table types.
First, they do not allow programmers to use the table constructor to
initialize table types that include optional fields.
For instance,
\begin{align*}
\{ & ``firstname":\String, ``lastname":\String \}_{closed} \not \subtype\\
\{ & ``firstname":\String,\\
  &  ``middlename":\String \cup \Nil, ``lastname":\String \}_{closed}
\end{align*}
Second, they do not allow programmers to use the table construtor to
initialize table types that represent hashes.
For instance,
\begin{align*}
\{ & ``x":\Number, ``y":\Number, ``z":\Number \}_{closed} \not \subtype\\
\{ & \String:\Number \cup \Nil\}_{closed}
\end{align*}

We introduced \emph{open} table types to allow the refinement
of table types, and also to allow programmers to omit optional
fields in the initialization of table types.
To do that, we defined a subtyping rule that allow \emph{open}
table types to omit fields when $\Nil$ is subtype of the type of
the value of the ommited key.
The following subtyping rule show this behavior:
\[
\begin{array}{c}
\mylabel{S-TABLE2}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{c} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{open} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open}}
\end{array}
\]

The rule \textsc{S-TABLE2} introduced the relation $\subtype_{o}$.
It is an auxiliary relation that defines the subtyping relation
on optional fields, and we defined it as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD4}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} v}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD5}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} \Const \; v}
\end{array}
\end{array}
\]

Although \emph{open} table types let programmers omit optional fields,
they do not let programmers initialize optional fields that are
mutable, unless they use the same type of the field in the initialization.
For instance,
\begin{align*}
\{ & ``firstname":\String,\\
   & ``middlename":\String, ``lastname":\String \}_{open} \not \subtype \\
\{ & ``firstname":\String, \\
   & ``middlename":\String \cup \Nil, ``lastname":\String \}_{closed}
\end{align*}

We introduced \emph{unique} table types to solve this problem.
We use \emph{unique} table types to denote the type of the
table constructor.
The following subtyping rule allow programmers to use table constructors
to initialize and omit optional fields:
\[
\begin{array}{c}
\mylabel{S-TABLE3}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{u} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{unique} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open|unique}}
\end{array}
\]

The rule \textsc{S-TABLE3} introduced the relation $\subtype_{u}$.
It is an auxiliary relation that makes \emph{unique} table types
have width and depth subtyping on all fields, and we defined it
as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD6}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD7}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD8}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\end{array}
\]

Table types can be ambiguous.
For instance, $\{1:\Number, \Integer:\String\}$ is an ambiguous
table type because the type of the value stored by key $1$ can be
$\Number$ or $\String$, as $1 \subtype 1$ and
$1 \subtype \Integer$.
Table types can get even more ambiguous when we use the dynamic
type in the type of table keys.
For instance, the table type $\{1:\Number, \Integer:\String, \Any:\Boolean\}$
is ambiguous because the type of the value stored by key $1$ can be
$\Number$, or $\String$, or $\Boolean$, as $1 \subtype 1$,
$1 \subtype \Integer$, and $1 \lesssim \Any$.
Moreover, the type of the value stored by a key of type $\Integer$,
which is not the literal type $1$, can be $\Number$ or $\Boolean$,
as $\Integer \subtype \Integer$, and $\Integer \lesssim \Any$.

To avoid ambiguous table types we use the following rule to check
whether a table type is well formed:
\[
\forall i \not\exists j \; i \not= j \wedge k_{i} \lesssim k_{j}
\]

\emph{/* Can we use this well formed rule to allow $k$ to be $t$? */}

Our type system also includes recursive types: $\mu x.t$,
where $t$ is a function or table type with $x$ appearing anywhere
a function or table type could appear.
For instance, $\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed}$
represents the type of single linked list of numbers.

We use the \emph{Amber rule} from the Amber language
\citep{cardelli1986amber} to define the subtyping rule for
recursive types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-ASSUMPTION}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
      {\senv \vdash x_{1} \subtype x_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBER}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-AMBER} needs the rule \textsc{S-ASSUMPTION}
to show that $\mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}$.
The rule \textsc{S-ASSUMPTION} checks if the assumption
$x_{1} \subtype x_{2}$ exists in the set of assumptions $\senv$.
The rule \textsc{S-AMBER} extends the set of assumptions
with the assumption $x_{1} \subtype x_{2}$ to check whether
$t_{1} \subtype t_{2}$ or not.

Our type system does not infer recursive types, so we defined two
extra subtyping rules that handle the cases where they may
appear inside a table or function type:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-AMBERL}\\
\dfrac{\senv \vdash [x \mapsto \mu x.t_{1}]t_{1} \subtype t_{2}}
      {\senv \vdash \mu x.t_{1} \subtype t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBERR}\\
\dfrac{\senv \vdash t_{1} \subtype [x \mapsto \mu x.t_{2}]t_{2}}
      {\senv \vdash t_{1} \subtype \mu x.t_{2}}
\end{array}
\end{array}
\]

For instance, the rule \textsc{S-AMBERR} allows our type system
check whether the type of a table constructor is subtype of
a recursive type or not, as we show in the following example:
\begin{align*}
\{ & ``info":\Number, \\
   & ``next":\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed} \cup \Nil \}_{unique} \subtype \\
& \mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}_{closed}
\end{align*}

Our type system also introduces projection types, but they do not
appear on the subtyping and consistent-subtyping rules.
They are just a mechanism that the type system uses for handling
union of tuple types, when they appear on the right-hand side of
the declaration of local variables.
That is the reason why we do not need to define subtyping and
consistent-subtyping rules for them.
We will see projection types in more detail in the next section.

\section{Typing rules}

In this section we will use a reduced core of Typed Lua to present
its typing rules in an easier way.
It is a reduced core of the Lua language with explicit type annotations,
without syntactic sugar, with only if and while control flow statements,
and making variable scope explicit.

\begin{figure}[!ht]
\textbf{Abstract Syntax}\\
\dstart
$$
\begin{array}{rl}
s ::= & \;\; \mathbf{skip} \; | \;
s_{1} \; ; \; s_{2} \; | \;
\vec{l} = el \; | \;
\mathbf{while} \; e \; \mathbf{do} \; s \; | \;
\mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}\\
& | \; \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s \; | \;
\mathbf{rec} \; n{:}t = f \; \mathbf{in} \; s \; | \;
\mathbf{return} \; el \; | \;
e(el)_{s} \; | \;
e{:}n(el)_{s}\\
e ::= & \;\; \mathbf{nil} \; | \;
\mathbf{false} \; | \;
\mathbf{true} \; | \;
{\it int} \; | \;
{\it float} \; | \;
{\it string} \; | \;
{...}_{e} \; | \;
f \; | \;
\{ \; cl \; \} \\
& | \; e_{1} + e_{2} \; | \;
e_{1} \; {..} \; e_{2} \; | \;
e_{1} == e_{2} \; | \;
e_{1} < e_{2} \; | \;
e_{1} \; \mathbf{and} \; e_{2} \; | \;
e_{1} \; \mathbf{or} \; e_{2} \\
& | \; \mathbf{not} \; e \; | \;
- e \; | \;
\# \; e \; | \;
e(el)_{e} \; | \;
e{:}n(el)_{e} \; | \;
n \; | \;
e_{1}[e_{2}] \; | \;
{<}t{>} \; n\\
l ::= & \;\; n \; | \;
e_{1}[e_{2}] \; | \;
n[e] \; {<}t{>} \; | \;
n_{1}{:}n_{2} \; {<}t{>}\\
el ::= & \;\; \mathbf{nothing} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{e}, me\\
cl ::= & \;\; \mathbf{nothing} \; | \;
\vec{c} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{c}, \vec{e} \; | \;
\vec{c}, me \; | \;
\vec{c}, \vec{e}, me \; | \;
\vec{e}, me\\
me ::= & \;\; e(el) \; | \;
e{:}n(el) \; | \;
{...}\\
f ::= & \;\; \mathbf{fun} \; (){:}r \; s \; ; \; \mathbf{return} \; el \; | \;
\mathbf{fun} \; ({...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; (\vec{n{:}t}){:}r \; s \; ; \; \mathbf{return} \; el \; | \;
\mathbf{fun} \; (\vec{n{:}t},{...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
c ::= & \;\; [e_{1}] = e_{2}\\
n ::= & \;\; {\it name}\\
\end{array}
$$
\dend
\caption{Typed Lua abstract syntax}
\label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} presents the abstract syntax of core Typed Lua.
It splits the syntactic categories as follows:
$s$ are statements, $e$ are expressions, $l$ are left-hand values,
$el$ are expression lists, $c$ are constructor fields, $cl$ are lists of
constructor fields, $me$ are multiple expressions, $a$ are function
applications, $f$ are function declarations, $n$ are variable names,
$t$ are first-level types, and $r$ are second-level types.
The notation $\vec{n{:}t}$ denotes the non-empty list
$n_{1}{:}t_{1}, ..., n_{n}{:}t_{n}$.

We will present the typing rules as a deduction system for the typing
relations $\env_{1} \vdash s : \env_{2}$ and $\env_{1} \vdash e : t, \env_{2}$. 
We will use the first one for typing statements, and the sencond one
for typing expressions. 
The first relation means that given the type environment $\env_{1}$,
typing the statement $s$ produces the new type environment $\env_{2}$. 
The sencond relation means that given the type environment $\env_{1}$,
the expression $e$ has type $t$, and produces the new type environment $\env_{2}$.
We need two typing relations because only expressions have types,
though both expressions and statements can modify the environment.
The environment maps variables to types, and we will use $\env_{1}[n \mapsto t]$
for meaning that we extended the environment $\env_{1}$ with the
variable $n$ that maps to type $t$, and this mapping does not affect
the other mappings that extisted before.

Função recursiva (another example?).

\begin{verbatim}
    rec f:(integer) -> (integer) =
      fun (x:integer)
        if n == 0 then
          return 1
        else
          return n * f(n - 1)
    in f(5)
\end{verbatim}

Dynamic typing and static typing in the same code (another example?).

\begin{verbatim}
    local a:(integer) -> (integer) =
      fun (x:integer)
        if n < 0 then return -n else return n
    in local d:(any, any) -> (integer) =
         fun (x:any, y:any)
           skip ; return a(x - y)
       in d(1, 1)
\end{verbatim}

Another example:

\begin{verbatim}
    local x:any = 1 in x = x + 1
\end{verbatim}

This example is safe, but the following is not:

\begin{verbatim}
    local x:any, y:any = 1 in x = x + y
\end{verbatim}

Functions and multiple return.

%\begin{center}
%\begin{tabular}{llll}
%\multicolumn{4}{l}{$\mathbf{local} \; m:\Void \rightarrow \Number \times \String =$} \\
%& \multicolumn{3}{l}{$\mathbf{fun} \; ():\Number \times \String$} \\
%& & \multicolumn{2}{l}{$\mathbf{skip} \;;\; \mathbf{return} \; 2, ``foo"$} \\
%\multicolumn{4}{l}{$\mathbf{in}$} \\
%& \multicolumn{3}{l}{$\mathbf{local} \; s:\Number \times \Number \rightarrow \Number =$} \\
%& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Number, y:\Number):\Number$} \\
%& & & \multicolumn{1}{l}{$\mathbf{skip} \;;\; \mathbf{return} \; x + y$} \\
%& \multicolumn{3}{l}{$\mathbf{in}$} \\
%& & \multicolumn{2}{l}{$\mathbf{local} \; x:\Number, y:\Number, z:\String = m(), m()$} \\
%& & \multicolumn{2}{l}{$\mathbf{in} \; s(m(), m())$}
%\end{tabular}
%\end{center}

\begin{verbatim}
  local m:() -> (integer, string) =
    fun () skip ; return 2, "foo"
  in local s:(integer, integer) -> (integer)
       fun (x:integer, y:integer) skip ; return x + y
     in local x:integer, y:integer, z:string = m(), m()
        in s(m(), m())
\end{verbatim}

Optional parameters.

\begin{verbatim}
    local m:(string, string|nil) -> (string) =
      fun (n:string, g:string|nil)
        g = g or "Hello" ; return g .. n
    in m("Lua")
\end{verbatim}

Overloading on the input parameter (another example?).

\begin{verbatim}
  local o:(string, string|integer) -> (string) =
    fun (a:string, b:string|integer)
      if type(b) == "string" then
        return a .. b
      else
        return string["rep"](a, b)
  in o("foo", 2) 
\end{verbatim}

Overloading on the return type (another example?).

\begin{verbatim}
  local d:(integer, integer) -> (integer, integer) | (nil, string) =
    fun (a:integer, b:integer):(integer, integer) | (nil, string)
      if b == 0 then
        return nil, "division by zero"
      else
        local r:integer = a \% b
        in local q:integer = (a - r) / b
           in skip ; return q, r
  in local q:X1, r:X2 = d(2, 2)
     in if q then
          print(a == b * q + r)
        else
          print("ERROR " .. r)
\end{verbatim}

Table type as hash.

\begin{verbatim}
    local t:{string:integer|nil} = { ["foo"] = 1 } in
      local x:integer|nil = t["foo"] in x = t["bar"]
\end{verbatim}

Table type as array.

\begin{verbatim}
    local d:{integer:string|nil} =
      { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" }
    in local x:string|nil = d[1] in x = d[8]
\end{verbatim}

Table type as record (first example).

\begin{verbatim}
    local p:{"firstname":string, "lastname":string} =
      { ["lastname"] = "Reed", ["firstname"] = "Lou" }
    in skip
\end{verbatim}

Table type as record (second example).

\begin{verbatim}
    local p:{"firstname":string,
             "middlename":string|nil,
             "lastname":string} =
      { ["firstname"] = "Lewis",
        ["middlename"] = "Allan",
        ["lastname"] = "Reed" }
    in skip
\end{verbatim}

Table type as record (third example).

\begin{verbatim}
    local p:{"firstname":string,
             "middlename":string|nil,
             "lastname":string} =
      { ["firstname"] = "Lou",
        ["lastname"] = "Reed" }
    in skip
\end{verbatim}

Refinement of table types (first example).

\begin{verbatim}
    local p:{} = {}
    in p["firstname"] <string> = "Lou" ;
       p["lastname"] <string> = "Reed"
\end{verbatim}

Refinement of table types (second example).

\begin{verbatim}
    local p:{} = {}
    in local b:{} = p
       in p["firstname"] <string> = "Lou" ;
          p["lastname"] <string> = "Reed"
\end{verbatim}

Modules (another example?).

\begin{verbatim}
    local m:{} = {}
    in local r:number = 3.14 / 180.0
       in m["deg"] <(number) -> (number)> =
          fun (x:number):(number)
            skip ; return x / r
        ; m["rad"] <(number) -> (number)> =
          fun (x:number):(number)
            skip ; return x * r
        ; m["pow"] <(number, number) -> (number)> =
          fun (x:number, y:number):(number)
            skip ; return x ^ y
\end{verbatim}

Objects.

\begin{verbatim}
    local s:{"x":number, "y":number} = { x = 0., y = 0.0 }
    in s["new"] <(self, number, number) -> (self)> =
       fun (self:self, x:number, y:number):(self)
         local s:{"x":number, "y":number} =
           setmetatable({}, { __index = self })
         in s["x"] = x ; s["y"] = y ; return s
     ; s["move"] <(self, number, number) -> ()> =
       fun (self:self, x:number, y:number):()
         self["x"] = self["x"] + x ;
         self["y"] = self["y"] + y 
\end{verbatim}
