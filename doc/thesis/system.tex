
In the previous chapter we presented an informal overview of Typed Lua.
We showed that programmers can use Typed Lua to combine static and dynamic
typing in the same code, and it allows them to incrementally migrate from
dynamic to static typing.
This is a benefit to programmers that use dynamically typed languages
to build large applications, as static types detect many bugs
during the development phase, and also provide better documentation.

In this chapter we present the formalization of Typed Lua's type system.
Besides its practical contribution, Typed Lua also has some interesting
contributions to the field of optional type systems for scripting
languages.
They are novel type system features that let Typed Lua cover several Lua idioms
and features, such as the refinement of tables, multiple return values,
and optional parameters.

\section{Types}

Our type system uses subtyping \citep{cardelli1984smi,abadi1996to} to order
types and consistent-subtyping \citep{siek2007objects,siek2013mutable}
to allow the interaction between statically and dynamically typed code.
We will explain the subtyping and consistent-subtyping rules along this
section while we introduce each type from our type system.
We will focus the discussion on the definition of subtyping because,
as we mentioned in Chapter \ref{chap:review}, we can combine the
consistency and subtyping relations to achieve consistent-subtyping.
The differences between subtyping and consistent-subtyping are the way
they handle the dynamic type, and the fact that subtyping is transitive,
but consistent-subtyping is not.

\begin{figure}[!ht]
\textbf{Type Language}\\
\dstart
$$
\begin{array}{rlr}
\multicolumn{3}{c}{\textbf{First-level types}}\\
t ::= & \;\; l & \textit{literal types}\\
& | \; b & \textit{base types}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; t \cup t & \textit{disjoint union types}\\
& | \; p \rightarrow r & \textit{function types}\\
& | \; \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed|open|unique} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.t & \textit{recursive types}\\
& | \; \pi_{i}^{x} & \textit{projection types}\\
l ::= & \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} & \\
b ::= & \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String & \\
k ::= & \;\; l \; | \; b \; | \; \Any & \textit{key types}\\
v ::= & \;\; t \; | \; \Const \; t & \textit{value types}\\ 
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{\textbf{Second-level types}}\\
s ::= & \;\; t &\\
& | \; t* & \textit{variadic types}\\
& | \; t \times s & \textit{tuple types}\\
p ::= & \;\; \Void \; | \; s & \textit{parameters list type}\\
r ::= & \;\; \Void \; | \; s \; | \; s \sqcup r & \textit{return types}\\
\end{array}
$$
\dend
\caption{The abstract syntax of Typed Lua types}
\label{fig:typelang}
\end{figure}

Figure \ref{fig:typelang} presents the abstract syntax of the
Typed Lua types.
Typed Lua splits types into two categories:
\emph{first-level types} and \emph{second-level types}.
Typed Lua uses first-level types to represent first-class Lua values and
second-level types to represent tuples of values that appear in 
multiple assignments and function applications.
First-level types include literal types, base types, the type $\Nil$,
the top type $\Value$, the dynamic type $\Any$, the type $\Self$,
union types, function types, table types, recursive types, and
projection types.
Second-level types include the type $\Void$, tuples of first-level
types optionally ending in a variadic type, and unions of these tuples.

Literal types represent the type of literal values.
They can be the boolean values $\False$ and $\True$,
any integer value, any floating point value, and any string value.
We shall see that literal types are important in our treatment of
table types as records.

Our type system also includes the following base types: $\Boolean$,
$\Integer$, $\Number$, and $\String$.
The base types $\Boolean$ and $\String$ represent the values that during
run-time Lua tags as \texttt{boolean} and \texttt{string}, respectively.
Lua 5.3 introduced two internal representations to the tag \texttt{number}:
\texttt{integer} for integer numbers and \texttt{float} for real numbers.
Both \texttt{integer} and \texttt{float} values are subtype of \texttt{number}.
We introduced the base type $\Number$ to represent either the tag
\texttt{number} or \texttt{float} values, and the type $\Integer$ to represent
\texttt{integer} values.

The subtyping rules for literal types and base types include the rules
for defining that literal types are subtypes of their respective base types,
and that $\Integer$ is subtype of $\Number$.
We defined these subtyping rules as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FALSE}\\
\senv \vdash \False \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-TRUE}\\
\senv \vdash \True \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-STRING}\\
\senv \vdash {\it string} \subtype \String
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-INT1}\\
\senv \vdash {\it int} \subtype \Integer
\end{array}
\;
\begin{array}{c}
\mylabel{S-INT2}\\
\senv \vdash {\it int} \subtype \Number
\end{array}
\;
\begin{array}{c}
\mylabel{S-FLOAT}\\
\senv \vdash {\it float} \subtype \Number
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-NUMBER}\\
\senv \vdash \Integer \subtype \Number
\end{array}
\end{array}
\]

The variable $\senv$ is a set of pairs of recursion variables.
We shall notice that we need this set to record the pairs of valid
recursive types.

Subtyping is reflexive, thus, we include reflexive rules for
first-level and second-level types as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIRST}\\
\senv \vdash t \subtype t
\end{array}
\;
\begin{array}{c}
\mylabel{S-SECOND}\\
\senv \vdash s \subtype s
\end{array}
\end{array}
\]

Subtyping is also transitive, and for this reason we could have omitted
the rule \textsc{S-INT2}.
More precisely, we could have defined a transitive rule for first-level
types instead of defining specific rules to transitive cases.
For instance, a transitive rule would allow us to derive that
\[
\dfrac{\senv \vdash 1 \subtype \Integer \;\;\;
       \senv \vdash \Integer \subtype \Number}
      {\senv \vdash 1 \subtype \Number}
\]

However, we are using the subtyping rules as the template for defining
the consistent-subtyping rules, and consistent-subtyping is not
transitive.
More precisely, we want the subtyping and consistent-subtyping rules
to differ only in the way they handle the dynamic type.
Thus, we define the subtyping rules using an algorithmic
way that is close to the implementation, as this way allows us to use
subtyping to formalize consistent-subtyping.

The type $\Nil$ represents the type of the value that during run-time
Lua tags as \texttt{nil}.
In our type system $\Nil$ is not the bottom type, and it is subtype
only of itself through the reflexive rule.
Typed Lua has this behavior because in Lua the tag \texttt{nil}
represents the absence of an useful value.
Thus, making $\Nil$ the bottom type would lead to several expressions
that would pass the type checker, but that would fail during run-time
in the presence of a \texttt{nil} value.

The type $\Value$ is the top type, so any first-level type is a
subtype of $\Value$.
In the next section we will show that this type along with
variadic types help the type system drop extra values on
multiple assignments and function calls, thus preserving the
semantics of Lua in these cases.
Following we show its subtyping rule:
\[
\begin{array}{c}
\mylabel{S-VALUE}\\
\senv \vdash t \subtype \Value
\end{array}
\]

The dynamic type $\Any$ allows programmers to mix static and dynamic typing;
it is neither the bottom nor the top type,
but a separate type that is subtype only of itself through the reflexive rule.

Even though the dynamic type $\Any$ is neutral to subtyping,
it is not to consistent-subtyping:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{C-ANY1}\\
\senv \vdash t \lesssim \Any
\end{array}
\;
\begin{array}{c}
\mylabel{C-ANY2}\\
\senv \vdash \Any \lesssim t
\end{array}
\end{array}
\]

The rules that handle the dynamic type are the only rules that
differ between subtyping and consistent-subtyping.
If we had set the type $\Any$ as both bottom and top types of our
subtyping relation, then all programs would type check without errors.
This would happen due to the transitivity of subtyping, that is,
we would be able to down-cast any type to $\Any$ and then up-cast
$\Any$ to any type.
The rules \textsc{C-ANY1} and \textsc{C-ANY2} are the rules that
allow the dynamic type to interact with other first-level types,
and thus allow dynamically typed code to coexist with statically
typed code.
Because of these two rules consistent-subtyping cannot be transitive.

Typed Lua uses the type $\Self$ to represent the \emph{receiver}
in object-oriented method definitions and method calls.
As we mentioned in Chapter \ref{chap:typedlua}, we need the type
$\Self$ to prevent programmers from indexing a method without
calling it with the correct \emph{receiver}.
The type $\Self$ is subtype only of itself through the reflexive rule.

Union types represent types that can hold a value of several
different, but fixed types.
The subtyping rules for union types are standard:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION1}\\
\dfrac{\senv \vdash t_{1} \subtype t \;\;\;
       \senv \vdash t_{2} \subtype t}
      {\senv \vdash t_{1} \cup t_{2} \subtype t}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION2}\\
\dfrac{\senv \vdash t \subtype t_{1}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION3}\\
\dfrac{\senv \vdash t \subtype t_{2}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\end{array}
\]

The first rule shows that a union type $t_{1} \cup t_{2}$
is subtype of $t$ if both $t_{1}$ and $t_{2}$ are subtypes
of $t$;
and the other rules show that a type $t$ is subtype
of a union type $t_{1} \cup t_{2}$ if $t$ is subtype of
$t_{1}$ or if $t$ is subtype of $t_{2}$.

Union types must be disjoint, that is, the types in the union are not
consistent-subtype of each other.
In the implementation of Typed Lua we use consitent-subtyping to
normalize and simplify union types, but we let them free in the
formalization.
For instance, the union type $\Boolean \;\cup\; \Any$ results the
type $\Any$, because $\Boolean \lesssim \Any$;
and the union type $\Number \;\cup\; \Nil \;\cup\; 1$ results the union
type $\Number \;\cup\; \Nil$ because $1 \lesssim \Number$.

To introduce function types we first need to introduce
second-level types, as they appear on both sides of function types.
Second-level types are tuples of first-level types
that can optionally end with a variadic type.
Our type system needs second-level types because tuples are
not first-class values in Lua, though they may appear on
argument passing, multiple returns, and multiple assignments.
A variadic type $t*$ is a generator for a sequence of values of
type $t \cup \Nil$, and it represents the type of the vararg
expression.
The subtyping rule for tuple types is standard, but the subtyping
rules for variadic types are not obvious:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-TUPLE}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash s_{1} \subtype s_{2}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2} \times s_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-VARARG1}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1}{*} \subtype t_{2}{*}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG2}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2}}
      {\senv \vdash t_{1}{*} \subtype t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG3}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1} \subtype t_{2}{*}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-VARARG4}\\
\dfrac{\senv \vdash t_{1}{*} \subtype t_{2} \;\;\;
       \senv \vdash t_{1}{*} \subtype s_{2}}
      {\senv \vdash t_{1}{*} \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG5}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2}{*} \;\;\;
       \senv \vdash s_{1} \subtype t_{2}{*}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2}{*}}
\end{array}
\end{array}
\]

The subtyping rules for tuple and variadic types show that they are covariant.
While we need just one subtyping rule for tuple types,
we need five different subtyping rules for variadic types
to handle all the cases that they can appear.
The rule \textsc{S-TUPLE1} shows that a tuple type $t_{1} \times s_{1}$
is subtype of another tuple type $t_{2} \times s_{2}$ if
$t_{1}$ is subtype of $t_{2}$ and $s_{1}$ is subtype of $s_{2}$.
The rule \textsc{S-VARARG1} handles the subtyping between two variadic types.
It shows that $t_{1}{*}$ is subtype of $t_{2}{*}$
if $t_{1} \cup \Nil$ is subtype of $t_{2} \cup \Nil$.
This rule explicit includes $\Nil$ in both sides because otherwise
$\Nil{*}$ would not be a subtype of several other variadic types.
For instance, $\Nil{*}$ would not be subtype of $\Number{*}$,
as $\Nil \not\subtype \Number$.
The rules \textsc{S-VARARG2} and \textsc{S-VARARG3} handles the
subtyping between a firt-level type and a variadic type.
The rule \textsc{S-VARARG2} shows that a variadic type $t_{1}{*}$ is
subtype of a firt-level type $t_{2}$ if $t_{1} \cup \Nil$ is subtype of $t_{2}$.
The rule \textsc{S-VARARG3} shows that a firt-level type $t_{1}$
is subtype of a variadic type $t_{2}{*}$ if $t_{1}$ is subtype of $t_{2} \cup \Nil$.
The rules \textsc{S-VARARG4} and \textsc{S-VARARG5} handle the
subtyping between a tuple type and a variadic type.
The rule \textsc{S-VARARG4} shows that a variadic type is subtype of
a tuple type whenever the type of the value that it generates is
subtype of all the elements of the tuple.
The rule \textsc{S-VARARG5} shows that a tuple type is subtype of a
variadic type whenever all the elements of the tuple are subtype of
the type of the value that it generates.
In the next section we will show that we use these subtyping relations
along with the types $\Value$ and $\Nil$ to make our type system reflect
the semantics of Lua on discarding extra parameters and
replacing missing parameters.

Function types have the form $p \rightarrow r$, where
$p$ is the type of the parameter list and $r$ is the return type.
The type of the parameter list can be $\Void$ or a tuple type,
while the return type can be $\Void$, a tuple type, or a union of
tuple types.
The type $\Void$ means an empty tuple.
Our type system includes unions of tuples on the return type because
in Lua it is common to overload the return type to denote error,
as we mentioned in Section \ref{sec:statistics}.

The type $\Void$ and union of tuple types are also second-level types.
The type $\Void$ is subtype only of itself through the reflexive rule.
The subtyping rules for unions of tuple types are similar to the
subtyping rules for unions of first-level types.

The subtyping rule for function types is standard, that is, it is
contravariant on the type of the parameter list and
covariant on the return type:
\[
\begin{array}{c}
\mylabel{S-FUNCTION}\\
\dfrac{\senv \vdash p_{2} \subtype p_{1} \;\;\;
       \senv \vdash r_{1} \subtype r_{2}}
      {\senv \vdash p_{1} \rightarrow r_{1} \subtype p_{2} \rightarrow r_{2}}
\end{array}
\]

Table types represent the various forms that Lua tables can take.
The syntactical form of table types is $\{ k_{i}{:}v_{i}, ..., k_{n}{:}v_{n} \}_{tag}$.
When $n = 0$, then $i = 0$ and it represents the type of an empty table.
When $n > 0$, then $i$ varies from 1 to $n$, each $k_{i}$ represents
the type of a table key, and each $v_{i}$ represents the type of the
value that table keys of type $k_{i}$ map to.
Key types can only be literal types, base types, and the dynamic type.
We made this restriction to the type of the keys because the statistics
that we discussed in Section \ref{sec:statistics} showed that most
of the tables are records, lists, and hashes.
The dynamic type is an option when we need a loose table type.
Value types can be any first-level type, and can optionally include
the $\Const$ attribute to denote immutable values.

We also use the tags \emph{closed}, \emph{open}, and \emph{unique}
to classify table types.
The first tag represents the table types that the type annotations,
interface, and userdata declarations describe.
The second tag represents the table types that we can use field assignment
to add new fields to them.
The third tag represents the table types of table constructors.
We have different subtyping rules for table types according to their
tags.

The subtyping rule between \emph{closed} table types resembles the
standard subtyping rule between records:
\[
\begin{array}{c}
\mylabel{S-TABLE1}\\
\dfrac{\forall i \in 1..n \; \exists j \in 1..m \;\;\;
       \senv \vdash k_{j} \subtype k_{i}' \;\;\;
       \senv \vdash k_{i}' \subtype k_{j} \;\;\;
       \senv \vdash v_{j} \subtype v_{i}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{closed} \subtype \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}}
\end{array}
\]

The rule \textsc{S-TABLE1} allows \emph{closed} table types to
have width subtyping, and depth subtyping on $\Const$ fields.
The subtyping rules for the type of the values stored in a \emph{closed}
table type describe this behavior:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD1}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2} \;\;\;
       \senv \vdash v_{2} \subtype v_{1}}
      {\senv \vdash v_{1} \subtype v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD2}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype \Const \; v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD3}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype \Const \; v_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-FIELD1} handles mutable values invariantly,
while the rule \textsc{S-FIELD2} handles immutable values covariantly.
It is also safe to promote a mutable value to immutable, and the rule
\textsc{S-FIELD3} defines this behavior.
However, it is not safe to promote an immutable value to mutable,
and that is the reason why we do not have a subtying rule for this case.

There is a limitation on \emph{closed} table types that led us to
introduce \emph{unique} table types.
If the table constructor had a \emph{closed} table type, then
programmers would not be able to use it to initialize a variable with
a table type that describe a more general type.
For instance,
\begin{verbatim}
    local t:{"x":integer, "y":integer?} = { x = 1, y = 2 }
\end{verbatim}
whould not type check, as the type of the table constructor would not
be subtype of the type in the annotation.
More precisely,
\[
\{``x":1, ``y":2\}_{closed} \not\subtype \{``x":\Integer, ``y":\Integer \cup \Nil\}_{closed}
\]
Thus, we introduced \emph{unique} table types to represent the type of
the table constructor and avoid this limitation.

We introduced \emph{open} table types to allow the refinement of table types,
an idiom very common in Lua.

Even though \emph{open} and \emph{unique} table types have specific
subtyping rules, we will present them in the next section along with
the typing rules that formalize the refinement of table types.
The presentation of these subtyping rules is easier in the next section,
as they include some unsafe behaviors that the refinement of
table types keeps track to make them safe.

Any table type has to be \emph{well-formed}.
Informally, a table type is well-formed if key types do not overlap.
Formally, a table type is well-formed if it obeys the following rule:
\[
\forall i \not\exists j \; i \not= j \wedge k_{i} \lesssim k_{j}
\]

Well-formed table types avoid ambiguous table types.
For instance, this rule detects that the table type
$\{1:\Number, \Integer:\String, \Any:\Boolean\}$ is ambiguous,
because the type of the value stored by key $1$ can be
$\Number$, $\String$, or $\Boolean$, as $1 \lesssim 1$,
$1 \lesssim \Integer$, and $1 \lesssim \Any$.
Moreover, the type of the value stored by a key of type $\Integer$,
which is not the literal type $1$, can be $\Number$ or $\Boolean$,
as $\Integer \lesssim \Integer$, and $\Integer \lesssim \Any$.

Recursive types have the form $\mu x.t$,
where $t$ is a first-level type with $x$ appearing anywhere this
first-level type could appear.
For instance, $\mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed}$
is a type for singly-linked list of integers.

We use the \emph{Amber rule} \citep{cardelli1986amber} to define
subtyping between recursive types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-ASSUMPTION}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
      {\senv \vdash x_{1} \subtype x_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBER}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-AMBER} needs the rule \textsc{S-ASSUMPTION}
to show that $\mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}$.
The rule \textsc{S-ASSUMPTION} checks if the assumption
$x_{1} \subtype x_{2}$ exists in the set of assumptions $\senv$.
The rule \textsc{S-AMBER} extends the set of assumptions
with the assumption $x_{1} \subtype x_{2}$ to check whether
$t_{1} \subtype t_{2}$ or not.

A recursive type may appear inside a first-level type, and our
type system includes subtyping rules to handle subtyping between
a first-level type and a recursive type:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-AMBERL}\\
\dfrac{\senv \vdash [x \mapsto \mu x.t_{1}]t_{1} \subtype t_{2}}
      {\senv \vdash \mu x.t_{1} \subtype t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBERR}\\
\dfrac{\senv \vdash t_{1} \subtype [x \mapsto \mu x.t_{2}]t_{2}}
      {\senv \vdash t_{1} \subtype \mu x.t_{2}}
\end{array}
\end{array}
\]

For instance, it is the rule \textsc{S-AMBERR} that allows our
type system to type check the example that we presented
in Section \ref{sec:tables}:
\begin{verbatim}
    local interface Element
      info:integer
      next:Element?
    end
    local function insert (e:Element?, v:integer):Element
      return { info = v, next = e }
    end
\end{verbatim}

The interface \texttt{Element} defines the type for singly-linked
list of integers that we just mentioned, and the function
\texttt{insert} inserts an element in the begining of the list.
In this example, the recursive type appears inside the type of
the table constructor.
It type checks because the rule \textsc{S-AMBERR} verifies that
the type of the table constructor is a subtype of \texttt{Element}:
\begin{align*}
\{ & ``info":\Integer, \\
   & ``next":\mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed} \cup \Nil \}_{unique} \subtype \\
& \mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed}
\end{align*}

Projection types have the form $\pi_{i}^{x}$, where $x$ is a variable
that stores an union of tuple types in a special type environment,
and $i$ is an index that indicates how to build a first-level
union type from $x$.
For instance, if $x$ is the union of tuple types
$(\Integer \times \Integer) \sqcup (\Nil \times \String)$,
then $\pi_{1}^{x}$ represents the type $\Integer \cup \Nil$
while $\pi_{2}^{x}$ represents the type $\Integer \cup \String$.
Projection types follow the reflexive subtyping rule.
In the next section we will show in more detail how our type system
uses them as a mechanism for handling unions of tuple types,
when they appear on the right-hand side of the declaration of local variables.
We will also show how this feature allows our type system to constrain
the type of a local variable that depends on the type of another local variable.

\section{Typing rules}

In this section we use a reduced core of Typed Lua to present the
most interesting rules of our type system.
This core limits control flow to if and while statements,
has explicit type annotations, and explicit scope for variables.
It also has explicit method declarations and explicit method calls
instead of treating them as syntactic sugar.
We use this reduced core because it simplifies the presentation
of our type system.
Appendix \ref{app:rules} presents the full set of typing rules.

\begin{figure}[!ht]
\textbf{Abstract Syntax}\\
\dstart
$$
\begin{array}{rl}
s ::= & \;\; \mathbf{skip} \; | \;
s_{1} \; ; \; s_{2} \; | \;
\vec{l} = el \; | \;
m \; | \;
\mathbf{while} \; e \; \mathbf{do} \; s \; | \;
\mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}\\
& | \; \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s \; | \;
\mathbf{rec} \; n{:}t = f \; \mathbf{in} \; s \; | \;
\mathbf{return} \; el \; | \;
e(el)_{s} \; | \;
e{:}n(el)_{s}\\
e ::= & \;\; \mathbf{nil} \; | \;
c \; | \;
{...}_{e} \; | \;
n_{e} \; | \;
e_{1}[e_{2}] \; | \;
{<}t{>} \; n \; | \;
f \; | \;
\{ \} \; | \;
\{ \; \vec{p} \; \} \; | \;
\{ \; {...}_{m} \; \} \; | \;
\{ \; \vec{p},{...}_{m} \; \}\\
& | \; e_{1} + e_{2} \; | \;
e_{1} \; {..} \; e_{2} \; | \;
e_{1} == e_{2} \; | \;
e_{1} < e_{2} \; | \;
e_{1} \; \mathbf{and} \; e_{2} \; | \;
e_{1} \; \mathbf{or} \; e_{2} \\
& | \; \mathbf{not} \; e \; | \;
- e \; | \;
\# \; e \; | \;
e(el)_{e} \; | \;
e{:}n(el)_{e}\\
l ::= & \;\; n_{l} \; | \;
e_{1}[e_{2}] \; | \;
n[c] \; {<}t{>}\\
c ::= & \;\; \mathbf{false} \; | \;
\mathbf{true} \; | \;
{\it int} \; | \;
{\it float} \; | \;
{\it string}\\
p ::= & \;\; [e_{1}] = e_{2}\\
el ::= & \;\; \mathbf{nothing} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{e}, me\\
me ::= & \;\; e(el)_{m} \; | \;
e{:}n(el)_{m} \; | \;
{...}_{m}\\
m ::= & \;\; \mathbf{fun} \; n_{1}{:}n_{2} \; (){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; ({...}{:}t){:}r \; fb\\
& | \; \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
f ::= & \;\; \mathbf{fun} \; (){:}r \; fb \; | \;
\mathbf{fun} \; ({...}{:}t){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
fb ::= & \;\; s \;;\; \mathbf{return} \; el\\
n ::= & \;\; {\it name}\\
\end{array}
$$
\dend
\caption{Typed Lua abstract syntax}
\label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} presents the abstract syntax of core Typed Lua.
It splits the syntactic categories as follows:
$s$ are statements, $e$ are expressions, $l$ are left-hand values,
$el$ are expression lists, $c$ are literal constants, $p$ are expression pairs,
$me$ are expressions with multiple results, $f$ are function declarations,
$m$ are method declarations, $n$ are variable names,
$t$ are first-level types, and $r$ are second-level types.
The notation $\vec{n{:}t}$ denotes the non-empty list
$n_{1}{:}t_{1}, ..., n_{n}{:}t_{n}$.

Our reduced core also splits function application, method application, and
the vararg expression (${...}$) into different syntactic categories.
It uses $e(el)_{s}$ to denote function applications that return no value
because they appear as statements,
$e(el)_{e}$ to denote function applications that return only one value,
and $e(el)_{m}$ to denote function applications that return multiple values.
It uses the same categories for method applications, but only ${...}_{e}$
and ${...}_{m}$, as the vararg expression cannot appear as a statement.

We also included two kinds of type cast in our core language:
the expression ${<}t{>} \;n$ and the left-hand value $n[c] \; {<}t{>}$.
We will show that the first helps allowing safe aliasing between
table types, while the second allows the refinement of table types.
Due to the refinement of table types we also split variable names
into two categories: $n_{e}$ when they appear as expressions and
$n_{l}$ when they appear as left-hand values.

We will present the typing rules as a deduction system for the typing
relations $\env_{1} \vdash s : \env_{2}$ and $\env_{1} \vdash e : t, \env_{2}$. 
We will use the first one for typing statements, and the second one
for typing expressions.
The first relation means that given the type environment $\env_{1}$,
typing the statement $s$ produces the new type environment $\env_{2}$. 
The second relation means that given the type environment $\env_{1}$,
the expression $e$ has type $t$, and produces the new type environment $\env_{2}$.
We need two typing relations because only expressions have types,
though both expressions and statements can modify the environment.
The environment maps variables to types, and we will use $\env_{1}[n \mapsto t]$
for meaning that we extended the environment $\env_{1}$ with the
variable $n$ that maps to type $t$, and this mapping does not affect
the other mappings that existed before.

The most unusual feature of our type system is the refinement of
table types.
The rule \textsc{T-REFINE} allow us to add new keys to \emph{open}
and \emph{unique} table types:
\[
\begin{array}{c}
\mylabel{T-REFINE}\\
\dfrac{\env_{1}(n) = \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n} \}_{open|unique} \;\;\;
       \env_{1} \vdash c:t_{1}, \env_{2} \;\;\;
       \not \exists i \in 1..n \; t_{1} \lesssim k_{i}}
      {\env_{1} \vdash n[c] {<}t{>}:t, \env_{2}[n \mapsto \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, t_{1}{:}t\}_{open|unique}]}
\end{array}
\]

We introduced \emph{open} table types to allow the refinement
of table types, and also to allow programmers to omit optional
fields in the initialization of table types.
To do that, we defined a subtyping rule that allow \emph{open}
table types to omit fields when $\Nil$ is subtype of the type of
the value of the omitted key.
The following subtyping rule show this behavior:
\[
\begin{array}{c}
\mylabel{S-TABLE2}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{c} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{open} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open}}
\end{array}
\]

The rule \textsc{S-TABLE2} introduced the relation $\subtype_{o}$.
It is an auxiliary relation that defines the subtyping relation
on optional fields, and we defined it as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD4}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} v}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD5}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} \Const \; v}
\end{array}
\end{array}
\]

Although \emph{open} table types let programmers omit optional fields,
they do not let programmers initialize optional fields that are
mutable, unless they use the same type of the field in the initialization.
For instance,
\begin{align*}
\{ & ``firstname":\String,\\
   & ``middlename":\String, ``lastname":\String \}_{open} \not \subtype \\
\{ & ``firstname":\String, \\
   & ``middlename":\String \cup \Nil, ``lastname":\String \}_{closed}
\end{align*}

We introduced \emph{unique} table types to solve this problem.
We use \emph{unique} table types to denote the type of the
table constructor.
The following subtyping rule allow programmers to use table constructors
to initialize and omit optional fields:
\[
\begin{array}{c}
\mylabel{S-TABLE3}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{u} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{unique} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open|unique}}
\end{array}
\]

The rule \textsc{S-TABLE3} introduced the relation $\subtype_{u}$.
It is an auxiliary relation that makes \emph{unique} table types
have width and depth subtyping on all fields, and we defined it
as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD6}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD7}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD8}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\end{array}
\]

We restricted the refinement of table types to include only literal
keys because its purpose is to make it easier the construction of
table types that represent records.
For instance,
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{1}{l}{$a[``y"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
uses field assignment to add fields $x$ and $y$ to the local $a$.
After these field assignments $a$ has type
$\{``x":\String, ``y":\Integer\}_{unique}$.

We do not allow the refinement of table types to change the type of
a field that is already present in the table type.
For instance,
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
do not type check, as we are trying to change the type of field
``x" from $\String$ to $\String \cup \Integer$.
More precisely, our type system does not allow the table type to
change towards a type that is not a subtype of the previous type.
In this example,
$\{``x":\String \cup \Integer\}_{unique} \not\subtype \{``x":\String\}_{unique}$.
We have this restriction because this kind of refinement could lead
to fields that have a too general type.

\textit{/* We need to close table types before assigning them to fields. */}
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in} \; a[``x"] \; {<}\{\}_{closed}{>} = \{\}$
\end{tabular}
\end{center}

Lua has multiple assignments, so Typed Lua also has to take this into
consideration while refining table types.
The rule \textsc{T-ASSINGMENT} shows that tuple types make it easy
to use the consistent-subtyping relation to type check multiple assignments:
\[
\begin{array}{c}
\mylabel{T-ASSIGNMENT}\\
\begin{array}{c}
\dfrac{\env_{1} \vdash el:r_{1}, \env_{2} \;\;\;
       \env_{2} \vdash \vec{l}:r_{2}, \env_{3} \;\;\;
       r_{1} \lesssim r_{2}}
      {\env_{1} \vdash \vec{l} = el:\env_{3}}
\end{array}
\end{array}
\]

This rule is so simple because we left the difficult part to the
type checking of expression lists.
The list of left-hand values is also a kind of expression list.
The difficult part is to check whether there is an expression in
the expression list that messes the environment, and the rule
\textsc{T-LHSLIST} captures this intuition:
\[
\begin{array}{c}
\mylabel{T-LHSLIST}\\
\dfrac{\env \vdash l_{k}:t_{k}, \env_{k} \;\;\;
       merge(\env_{1}, ..., \env_{n}) = \env_{m} \;\;\;
       n = |\;\vec{l}\;|}
      {\env \vdash \vec{l}:t_{1} \times ... \times t_{n} \times \Value{*}, \env_{m}}
\end{array}
\]

First, this rule uses the same environment $\env$ to type check each
left-hand side value $l_{k}$, as they can perform different changes
to the environment.
Then, it takes each type $t_{k}$ and builds the tuple type for
the assignment rule.
It places the type $\Value{*}$ in the end to discard extra values.
The rule succeeds if the predicate \emph{merge} can
produce a new environment, which includes all the modifications
of each environment $\env_{k}$.
Intuitively, the predicate \emph{merge} fails when an environment
tries to change the type of a variable towards a type that is not
a subtype of its previous type.

We can also use multiple assignments to refine table types:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>}, a[``y"] \; {<}\Integer{>} = ``foo", 1$}\\
\end{tabular}
\end{center}

This example type checks because all the environment changes are consistent, and
$``foo" \times 1 \times \Nil{*} \lesssim \String \times \Integer \times \Value{*}$.
The type of the expression list includes the type $\Nil{*}$ in the end
because our type system has typing rules to add this type when
the type of the expression list does not end with a variadic type.
Our type system has this behavior to use $\Nil$ in the place of missing
values, like Lua does.
This example uses the rule \textsc{T-EXPLIST2}, which is really close
to the rule \textsc{T-LHSLIST}:
\[
\begin{array}{c}
\mylabel{T-EXPLIST2}\\
\dfrac{\env \vdash e_{k}:t_{k}, \env_{k} \;\;\;
       merge(\env_{1}, ..., \env_{n}) = \env_{m} \;\;\;
       n = |\;\vec{e}\;|}
      {\env \vdash \vec{e}:t_{1} \times ... \times t_{n} \times \Nil{*}, \env_{m}}
\end{array}
\]

The next example does not type check because it tries to add
the same field to $a$, but with different types:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$a[``x"] \; {<}\String{>}, a[``x"] \; {<}\Integer{>} = ``foo", 1$}\\
\end{tabular}
\end{center}

Typed Lua also keeps track whether it is safe or not safe to
change the type of a table, but before discussing this subject,
we will discuss the different table constructors that our
abstract syntax includes, as they will appear in the next
examples.

All the examples that we presented until now use the simplest form of
the table constructor: the empty table $\{\}$.
Its inference rule is straightforward:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR1}\\
\env \vdash \{\}:\{\}_{unique}, \env
\end{array}
\]

Our abstract syntax reduces the more complex uses of the table
constructor into three forms: $\{\;\vec{p}\;\}$, $\{\;{...}_{m}\;\}$,
and $\{\;\vec{p},{...}_{m}\;\}$.
The first one uses a list of expression pairs $[e_{1}] = e_{2}$,
the second one uses just the vararg expression, and the third one uses both.
We did not include in the abstract syntax a table constructor
that uses a list of expressions because we can write it using the first form.
For instance, we can write the table constructor
$\{ [1] = ``x", [2] = ``y", [3] = ``z" \}$ to express $\{ ``x", ``y", ``z" \}$.
We chose to not include this form because its inference rule is similar
to the inference rule of the first form, and just controls the type of
the omitted indices.
For the same reason we did not include table constructors with
multiple expressions, which can return a tuple type that does not end
with a variadic type.
We did include the vararg expression in the last position to show how
our type system can infer a table type that has a record part and
also an array part.

The inference rule \textsc{T-CONSTRUCTOR2} infers a table type for
the first form:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR2}\\
\dfrac{\env_{i} \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{unique}) = t}
      {\env_{1} \vdash \{\;\vec{p}\;\}:t, \env_{n+1}}
\end{array}
\]

This inference rule infers the type of each pair, uses these types
to build a table type, and uses the predicate \emph{wf} to check
whether the table type is well formed.
We gave the definition of this predicate in the last section.

The inference rules for expression pairs would be straightforward
if our table types allowed any type in the keys.
The rules \textsc{T-PAIR1}, \textsc{T-PAIR2}, and \textsc{T-PAIR3}
check if the type of the key is a subtype of $\Boolean$, $\Number$,
or $\String$, respectively:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-PAIR1}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Boolean}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-PAIR2}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Number}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-PAIR3}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \String}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}t_{2}, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-PAIR4} is a fallback for the previous rules,
but it works only if the type of the key does not include $\Nil$:
\[
\begin{array}{c}
\mylabel{T-PAIR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1}}
      {\env_{1} \vdash [e_{1}] = e_{2}: \Any{:}t_{2}, \env_{3}}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR2} along with the rules for expression
pairs allow Typed Lua to type check the following example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\String:\Integer \cup \Nil\}_{closed} = \{ [``x"] = 1, [``y"] = 2 \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\Integer \cup \Nil = a[``x"] \; \mathbf{in} \; b = a[``z"]$}
\end{tabular}
\end{center}

This example type checks because Typed Lua infers the table type
$\{``x":1, ``y":2\}_{unique}$, which is subtype of
$\{\String:\Integer \cup \Nil\}_{closed}$.
Even though the key $``z"$ does not exist in the table $a$,
the two table indexations type check with type $\Integer \cup \Nil$,
which is subtype of the type of $b$.
The rule \textsc{T-INDEX1} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-INDEX1}\\
\dfrac{\env_{1} \vdash e_{1}:\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3} \;\;\;
       \exists i \in 1{..}n \; t \lesssim k_{i}}
      {\env_{1} \vdash e_{1}[e_{2}]:v_{i}, \env_{3}}
\end{array}
\]

Typed Lua handles arrays as hashes that maps integers to some type $t$.
In Lua, programmers often use the vararg expression to initialize arrays.
The rules \textsc{T-CONSTRUCTOR3} and \textsc{T-CONSTRUCTOR4} define
the behavior of the vararg expression for this case:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-CONSTRUCTOR3}\\
\dfrac{\env_{1}({...}) = t}
      {\env_{1} \vdash \{{...}_{m}\}:\{\Integer{:}t \cup \Nil\}_{unique}, \env_{1}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-CONSTRUCTOR4}\\
\dfrac{\begin{array}{c}
       \env_{i} \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       \env_{i+1}({...}) = t_{v}\\
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, \Integer{:}t_{v} \cup \Nil\}_{unique}) = t_{t}
       \end{array}}
      {\env_{1} \vdash \{\;\vec{p},\;{...}_{m}\;\}:t_{t}, \env_{n+1}}
\end{array}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR3} type checks the case where we use
only the vararg expression inside a table constructor to initialize
an array.
If we assume that the $...$ is in the environment and has type $\String$,
the following example type checks through this rule:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\Integer:\String \cup \Nil\}_{closed} = \{ {...}_{m} \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\String \cup \Nil = t[1] \; \mathbf{in} \; b = t[5]$}
\end{tabular}
\end{center}

The rule \textsc{T-CONSTRUCTOR4} type checks the case where we use
the table constructor as a record that includes an array part.
If we assume that the $...$ is in the environment and has type $\String$,
the following example type checks through this rule:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\Integer, ``y":\Boolean, \Integer:\String \cup \Nil\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = \mathbf{true}, {...}_{m} \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; a[``x"] = ``bar"$}
\end{tabular}
\end{center}
but the next example does not type check because the record part
includes fields that the key types are subtype of the array part:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{1:\String, 10:\Boolean, \Integer:\String \cup \Nil\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [1] = ``foo", [10] = \mathbf{true}, {...}_{m} \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; a[``x"] = ``bar"$}
\end{tabular}
\end{center}

Making the inference rules of the table constructor infer an \emph{unique}
table type also allow us to use them for initializing record types that
have optional fields.
We can include the optional field in the initialization
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = ``bar", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}
and we can also omit it in the initialization
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}

After discussing the inference rules of the table constructor,
we can get back to the discussion about the refinement of table types.

Besides allowing the refinement of table types through field assignment,
Typed Lua also keeps track whether it is safe or not safe to change the
type of a table.
To do that, our type system always promotes an \emph{open}
table to \emph{closed} and an \emph{unique} table to \emph{open}
when they appear as expressions, or when they enter in a scope that is
not its declaration scope.
The order matters, as going from \emph{unique} to \emph{open}
before going from \emph{open} to \emph{closed} closes \emph{unique} table types.

The rule \textsc{T-IDREAD} uses the predicate \emph{close} to do
this promotion before we use a local variable:
\[
\begin{array}{c}
\mylabel{T-IDREAD}\\
\dfrac{\env_{1}(n) = t}
      {\env_{1} \vdash n_{e}:close(t), \env_{1}}
\end{array}
\]

This rule does not change the type of the local variable because it
just need to ensure that an alias will not get the same type.
For instance, it makes this unsafe example not type check:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{``x":\String \cup \Nil\}_{closed} = \{ [``x"] = ``foo" \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String \}_{unique} = \{ [``x"] = ``foo" \} \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a = b \;;\; a[``x"] = \mathbf{nil} \;;\; b[``x"] = b[``x"] \;{..}\; ``bar"$}
\end{tabular}
\end{center}

The assignment $a = b$ is not valid because the aliasing changed the
type of $b$ from $\{``x":\String\}_{unique}$ to $\{``x":\String\}_{open}$,
which is not subtype of $\{``x":\String \cup \Nil\}_{closed}$.

However, sometimes we want to use \emph{unique} table types to initialize
\emph{closed} table types, as they allow us to initialize optional fields.
To do that, Typed Lua includes a cast expression that allow us
to use an \emph{unique} table type before it becomes \emph{open}.
The rule \textsc{T-CAST} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-CAST}\\
\dfrac{t \subtype \env_{1}(n)}
      {\env_{1} \vdash {<}t{>} \; n:t, \env_{1}[n \mapsto t]}
\end{array}
\]

The rule \textsc{T-CAST} allow us to type check the following example:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{ \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{2}{l}{$a[``y"] \; {<}\String{>} = ``bar";$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String, ``y":\String \cup \Nil \}_{closed} =$}\\
& & \multicolumn{1}{l}{${<}\{``x":\String, ``y":\String \cup \Nil\}_{open}{>} \; a \; \mathbf{in} \; a[``z"] \; {<}\Integer{>} = 1$}
\end{tabular}
\end{center}

We can use $a$ to initialize $b$ because the cast expression converts
the type of $a$ from $\{``x":\String, ``y":\String\}_{unique}$ to
$\{``x":\String, ``y":\String \cup \Nil\}_{open}$, which is subtype of
$\{``x":\String, ``y":\String \cup \Nil\}_{closed}$.
We can continue to refine the type of $a$ after the aliasing,
as it still holds an \emph{open} table.
At the end of this example, $a$ has type
$\{``x":\String, ``y":\String \cup \Nil, ``z":\Integer\}_{open}$.

Even though the rule \textsc{T-CAST} handles the case that we assign
an alias to a variable, we still have to close this variable due to
safety.
The rule \textsc{T-LOCAL} is one example where we handle this case:
\[
\begin{array}{c}
\mylabel{T-LOCAL}\\
\dfrac{\env_{1} \vdash el:r_{1}, \env_{2} \;\;\;
       r_{1} \lesssim \vec{t} \;\;\;
       closeset(\env_{2}[\vec{n} \mapsto \vec{t}], fav(\mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s)) \vdash s:\env_{3}}
      {\env_{1} \vdash \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s:\env_{3} - \{\vec{n} \mapsto \vec{t}\}}
\end{array}
\]

This rule prevents the following unsafe example to type check:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}

We cannot add the field $``x"$ to $b$ because its type is \emph{closed},
and thus do not allow changing the value that is stored in the field $``x"$
of local $a$.

We also need to make sure to close all \emph{open} table types before we
type check another scope.
The rule \textsc{T-FUNCTION3} shows this case:
\[
\begin{array}{c}
\mylabel{T-FUNCTION3}\\
\dfrac{closeall(\env_{1}[\vec{n} \mapsto \vec{t}, \ret \mapsto r]) \vdash s:\env_{2}}
      {\env_{1} \vdash \mathbf{fun} \; (\vec{n{:}t}){:}r \; s:\vec{t} \rightarrow r, closeset(\env_{1}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))}
\end{array}
\]

This rule prevents the following unsafe example to type check:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{local} \; b:\Integer \times \Integer \rightarrow \Integer =$}\\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$}\\
& & & \multicolumn{1}{l}{$a[``z"] \; {<}\Integer{>} = 1; \; \mathbf{return} \; x + y$}\\
& \multicolumn{3}{l}{$\mathbf{in} \; a[``z"] \; {<}\String{>} = ``foo"$}
\end{tabular}
\end{center}

Typed Lua uses the refinement of table types to allow programmers to
build modules and objects.
It also allows Typed Lua to type check an object-oriented idiom that
programmers often use it.
\[
\begin{array}{c}
\mylabel{T-METHOD3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n_{1}) = \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{unique|open} \;\;\;
       \env_{1} \vdash n_{2} : l \;\;\;
       \not \exists i \in 1..n \; l \lesssim k_{i}\\
       closeall(\env_{1}[self \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed}, \vec{n} \mapsto \vec{t}, \ret \mapsto r]) \vdash s:\env_{2}
       \end{array}}
      {\begin{array}{c}
       \env_{1} \vdash \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; s:\\
       closeset(\env_{1}[n_{1} \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}, l{:}\Const \; \Self \times \vec{t} \rightarrow r\}_{unique|closed}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))
       \end{array}}
\end{array}
\]

The rule \textsc{T-METHOD3} allow our type system to type check the
following example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{open} = \{ [``x"] = 0.0, [``y"] = 0.0 \}$}\\
\multicolumn{4}{l}{$\mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; s{:}new (x:\Number, y:\Number):\Self$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{closed} =$}\\
& & & \multicolumn{1}{l}{$setmetatable(\{\}, \{ [``\string_\string_index"] = self \})$}\\
& & \multicolumn{2}{l}{$\mathbf{in} \; s[``x"] = x; \; s[``y"] = y; \; \mathbf{return} \; s$}\\
; & \multicolumn{3}{l}{$\mathbf{fun} \; s{:}move (x:\Number, y:\Number):\Void$}\\
& & \multicolumn{2}{l}{$self[``x"] = self[``x"] + x;$}\\
& & \multicolumn{2}{l}{$self[``y"] = self[``y"] + y$}
\end{tabular}
\end{center}

This example uses the type $\{``x":\Number, ``y":\Number\}_{open}$ to
initialize the local variable $s$, which represents the type of the class
that we are defining.
Then, we use two method definitions to include $new$ and $move$ into
our class that now has type
\begin{align*}
\{ & ``x":\Number, ``y":\Number,\\
   & ``new":\Self \times \Number \times \Number \rightarrow \Self,\\
   & ``move":\Self \times \Number \times \Number \rightarrow \Void \}_{open}
\end{align*}

Inside the definition of the method \emph{new} we use \emph{setmetatable}
to initialize the local $s$ with the type of $\Self$.
The rule \textsc{T-SETMETATABLE} express this idea:
\[
\begin{array}{c}
\mylabel{T-SETMETATABLE}\\
\dfrac{\env_{1} \vdash e:t, \env_{2} \;\;\;
       t \subtype \{\}_{open}}
      {\env_{1} \vdash setmetatable(\{\}, \{[``\string_\string_index"] = e\}):close(t), \env_{2}}
\end{array}
\]

After we define our class, we can use it to create object instances
of this class and call its methods.
The next example assumes the object $o$ is in the environment as
has the type of the class we just defined:
\begin{center}
\begin{tabular}{l}
$o{:}move(10, 10)_{s}$
\end{tabular}
\end{center}

This method call type checks through the rule \textsc{T-INVOKESTM1}.
This rule uses the inference rule \textsc{T-INVOKE1} and discards the results.
We defined the rule \textsc{T-INVOKE1} as follows:
\[
\begin{array}{c}
\mylabel{T-INVOKE1}\\
\dfrac{\env_{1} \vdash e:t, \env_{2} \;\;\;
       \env_{2} \vdash e[n]:p_{1} \rightarrow r, \env_{3} \;\;\;
       \env_{3} \vdash el:p_{2}, \env_{4} \;\;\;
       \Self \times p_{2} \lesssim p_{1}}
      {\env_{1} \vdash e{:}n(el)_{m}:[\Self \mapsto t]r, \env_{4}}
\end{array}
\]

Multiple assignments and multiple return values can also appear in
function applications, as the following example shows:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; m:\Void \rightarrow \Integer \times \String =$} \\
& \multicolumn{3}{l}{$\mathbf{fun} \; ():\Integer \times \String$} \\
& & \multicolumn{2}{l}{$\mathbf{return} \; 2, ``foo"$} \\
\multicolumn{4}{l}{$\mathbf{in}$} \\
& \multicolumn{3}{l}{$\mathbf{local} \; s:\Integer \times \Integer \rightarrow \Integer =$} \\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$} \\
& & & \multicolumn{1}{l}{$\mathbf{return} \; x + y$} \\
& \multicolumn{3}{l}{$\mathbf{in} \; s(m()_{e}, m()_{m})_{s}$}
\end{tabular}
\end{center}

This example does not type check because we are trying to call
$s$ with $\Integer \times \Integer \times \String$,
but its input parameter has type $\Integer \times \Integer$.
Lua drops extra values in function calls, and Typed Lua can also
have this behavior.
If we change the input type of $s$ to $\Integer \times \Integer \times \Value{*}$,
this example type checks.
Typed Lua also has to adjust function calls to use $\Nil$ in the
place of missing parameters, otherwise it would not be able to
type check function calls that have optional parameters.

\textit{/* I guess we should have different typing rules for strict and default. */}

Typed Lua includes four typing rules to handle the $\mathbf{or}$
logical operator and its common idioms:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR1}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \Nil \not\lesssim t \;\;\;
       \False \not\lesssim t}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR2}\\
\dfrac{\env_{1} \vdash e_{1}:\Nil, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-OR3}\\
\dfrac{\env_{1} \vdash e_{1}:\False, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-OR1} is the rule that implements the short circuit.
We use the consistent-subtyping relation in this rule to guarantee that
the type system checks the second expression when the first one
has the dynamic type, as it can be hiding a false value.

The rules \textsc{T-OR2} and \textsc{T-OR3} guarantee that the final
result is the type of the second expression, because the first one
is certainly a false value.

The rule \textsc{T-OR4} is the most general rule, but it is also
the rule that handles the common $\mathbf{or}$ idioms.
It uses the predicate \emph{filter} to filter possible false values
that might be part of the type of the first expression.
We can use pattern matching to the define the recursive predicate
\emph{filter} as follows:
\begin{align*}
filter(t_{1} \cup t_{2}, t_{1}) & = filter(t_{2}, t_{1})\\
filter(t_{1} \cup t_{2}, t_{2}) & = filter(t_{1}, t_{2})\\
filter(t_{1} \cup t_{2}, t_{3}) & = filter(t_{1}, t_{3}) \cup filter(t_{2}, t_{3})\\
filter(t_{1}, t_{2}) & = t_{1}
\end{align*}

Using these typing rules our type system can type check the following
example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\String \cup \Nil = \mathbf{nothing} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

Without the \emph{filter} predicate,
the expression $x \; \mathbf{or} \; ``Hello"$ would have type
$\String \cup \Nil \cup ``Hello"$.
The \emph{filter} predicate removes the type $\Nil$ from the result,
leaving type $\String \cup ``Hello"$.
At the end of the evaluation, the expression has type $\String$
because unions are disjoint and $``Hello" \subtype \String$.

\textit{/* The following example does not type check */}
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\Nil \cup \False = \mathbf{false} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

\textit{/* Should we define the following rules? */}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \cup \False \subtype t_{1} \;\;\;
       t_{1} \subtype \Nil \cup \False}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR5}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR6}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \Nil) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR7}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR8}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{1} \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

\textit{/* Or who writes this kind of code deserves a type error? */}

Another common idiom that programmers use in Lua is to overload
the input parameter of functions, and use the function \texttt{type}
to execute different actions according to their types.
\[
\begin{array}{c}
\mylabel{T-IF2}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = t\\
       closeall(\env_{1}[n \mapsto \String]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[n \mapsto filter(t, \String)) \vdash s_{2}:\env_{3}
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; type(n) == ``string" \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:closeset(\env_{1}[n \mapsto t], fav(s_{1}) \cup fav(s_{2}))}

\end{array}
\]

Using the rule \textsc{T-IF2}, Typed Lua can type check the following example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; o:\String \times \String \cup \Integer \rightarrow \String =$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; (a:\String, b:\String \cup \Integer):\String$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; r:\String = ``" \; \mathbf{in}$}\\
& & & \multicolumn{1}{l}{$\mathbf{if} \; type(b) == ``string" \; \mathbf{then} \; r = a \;{..}\;b \; \mathbf{else} \; r = rep(a, b)_{e}\; ;$}\\
& & & \multicolumn{1}{l}{$\mathbf{return} \; r$}\\
\multicolumn{4}{l}{$\mathbf{in} \; o(``foo", 2)_{s}$}
\end{tabular}
\end{center}

We are assuming that the function \emph{rep} is in the environment and has type
$\String \times \Integer \times \String \cup \Nil \rightarrow \String$.

Typed Lua also includes similar rules to handle the tags \texttt{nil},
\texttt{boolean}, and \texttt{number}.
There is also a similar rule for handling the type $\Integer$, but
it works only with Lua 5.3, as it depends on the function \texttt{math.type}.
This function appears only in Lua 5.3 and it returns the string $``integer"$
when its input parameter is a number that has an integer representation,
the string $``float"$ when its input parameter is a number that has a
floating point representation, or $\Nil$ otherwise.

Lua programmers also overload the return type of functions to denote
errors, and Typed Lua also handles this case with the rule \textsc{T-IF3}:
\[
\begin{array}{c}
\mylabel{T-IF3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = \pi_{i}\\
       closeall(\env_{1}[\pi \mapsto fpt(\env_{1}(\pi), \Nil, i)]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[\pi \mapsto gpt(\env_{1}(\pi), \Nil, i)) \vdash s_{2}:\env_{3}
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; n \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:closeset(\env_{1}, fav(s_{1}) \cup fav(s_{2}))}

\end{array}
\]

\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; q:\pi_{1}, r:\pi_{2} = idiv(1, 2)_{m} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{if} \; q \; \mathbf{then} \; print(q + r)_{s} \; \mathbf{else} \; print(``ERROR: " \; .. \; r)_{s}$}
\end{tabular}
\end{center}

\textit{/* How should we write the typing rule of the local declaration? */}

\textit{/* How this is valid if projection types do not have subtyping rules? */}

We are assuming that functions \emph{idiv} and \emph{print} are in
the environment with the respective types
$\Integer \times \Integer \rightarrow \Integer \times \Integer \sqcup \Nil \times \String$
and
$\Value{*} \rightarrow \Void$.

Lua has operator overloading, and allows the programmers to redefine
the behavior of some operations.
For instance, programmers can use metatables to redefine the
behavior of arithmetic operations.
Even though Typed Lua does not support operator overloading yet,
it includes typing rules that allow programmers to use the
dynamic type when they are using overloaded operations.
The following typing rules show how Typed Lua uses the dynamic type
to handle the overloading of arithmetic operations:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-ARITH5}\\
\dfrac{\env_{1} \vdash e_{1}:\Any, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-ARITH6}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:\Any, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-ARITH5} allows type checking the following
example:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Any = 1 \; \mathbf{in} \; x = x + 1$
\end{tabular}
\end{center}

This example is safe, but the following it is not:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Integer, \;y{:}\Any = 1 \; \mathbf{in} \; x = x + y$
\end{tabular}
\end{center}

Although this last example is not safe, it shows that optional
type systems still preserve the flexibility of dynamically
typed languages along with the benefits of static type checking.
