
In the previous chapter we presented an informal overview of Typed Lua.
We showed that programmers can use Typed Lua to combine static and dynamic
typing in the same code, and it allows them to incrementally migrate from
dynamic to static typing.
This is a benefit to programmers that use dynamically typed languages
to build large applications, as static types detect many bugs
during the development phase, and also provide better documentation.

In this chapter we present the formalization of Typed Lua's type system.
Besides its practical contribution, Typed Lua also has some interesting
contributions to the field of optional type systems for scripting
languages.
They are novel type system features that let Typed Lua cover several Lua idioms
and features, such as refinement of tables, multiple return values,
and optional parameters.

\section{Types}
\label{sec:types}

\begin{figure}[!ht]
\textbf{Type Language}\\
\dstart
$$
\begin{array}{rlr}
t ::= & & \textsc{first-level types:}\\
& \;\; l & \textit{literal types}\\
& | \; b & \textit{base types}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; t \cup t & \textit{disjoint union types}\\
& | \; s \rightarrow s & \textit{function types}\\
& | \; \{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{closed|open|unique} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.t & \textit{recursive types}\\
& | \; \pi_{i}^{x} & \textit{projection types}\\
%\multicolumn{3}{c}{}\\
l ::= & & \textsc{{\small literal types:}}\\
& \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} &\\
%\multicolumn{3}{c}{}\\
b ::= & & \textsc{{\small base types:}}\\
& \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String &\\
%\multicolumn{3}{c}{}\\
k ::= & & \textsc{{\small key types:}}\\
& \;\; l \; | \; b \; | \; \Value &\\
%\multicolumn{3}{c}{}\\
v ::= & & \textsc{{\small value types:}}\\
& \;\; t \; | \; \Const \; t &\\ 
%\multicolumn{3}{c}{}\\
s ::= & & \textsc{second-level types:}\\
& \;\; p & \textit{tuple types}\\
& | \; s \sqcup s & \textit{unions of tuple types}\\
%\multicolumn{3}{c}{}\\
p ::= & & \textsc{{\small tuple types:}}\\
& \;\; \Void & \textit{void type}\\
& | \; t* & \textit{variadic types}\\
& | \; t \times p & \textit{pair types}
\end{array}
$$
\dend
\caption{The abstract syntax of Typed Lua types}
\label{fig:typelang}
\end{figure}

Figure \ref{fig:typelang} presents the abstract syntax of
Typed Lua types.
Typed Lua splits types into two categories:
\emph{first-level types} and \emph{second-level types}.
First-level types represent first-class Lua values and
second-level types represent tuples of values that appear in 
assignments and function applications.
First-level types include literal types, base types, the type $\Nil$,
the top type $\Value$, the dynamic type $\Any$, the type $\Self$,
union types, function types, table types, recursive types, and
projection types.
Second-level types include the type $\Void$, variadic types,
tuple types, and unions of tuple types.
Types are ordered by a subtype relationship that we introduce
in Section \ref{sec:subtyping}, so Lua values may belong to
several distinct types.

Literal types represent the type of literal values.
They can be the boolean values $\False$ and $\True$,
an integer value, a floating point value, or a string value.
We will see that literal types are important in our treatment of
table types as records.

Typed Lua includes four base types: $\Boolean$, $\Integer$, $\Number$, and $\String$.
The base types $\Boolean$ and $\String$ represent the values that during
run-time Lua tags as \texttt{boolean} and \texttt{string}, respectively.
Lua 5.3 introduced two internal representations to the tag \texttt{number}:
\texttt{integer} for integer numbers and \texttt{float} for real numbers.
Lua does automatic promotion of \texttt{integer} values to \texttt{float}
values as needed.
We introduced the base type $\Number$ to represent \texttt{float} values,
and the base type $\Integer$ to represent \texttt{integer} values.
In the next section we will show that $\Integer$ is subtype of $\Number$.
This allows programmers to keep using \texttt{integer} values where
\texttt{float} values are expected.

The type $\Nil$ is the type of \texttt{nil}, the value that Lua uses for
undefined variables, missing parameters, and missing table keys.

The type $\Value$ is the top type, which represents any Lua value.
In Section \ref{sec:rules} we will show that this type,
along with variadic types, helps the type system to drop extra values
on assignments and function calls, thus preserving the
semantics of Lua in these cases.

Typed Lua uses the type $\Self$ to represent the \emph{receiver}
in object-oriented method definitions and method calls.
As we mentioned in Section \ref{sec:oop}, we need the type
$\Self$ to prevent programs from indexing a method without
calling it with the correct receiver.

Union types $t_{1} \cup t_{2}$ represent types that can hold a value
of two different types.

Function types have the form $s \rightarrow s$ and represent Lua functions,
where $s$ is a second-level type.

Second-level types are tuples of first-level types that can end
with either an empty tuple or with a variadic type, and
unions of tuple types.
Typed Lua needs second-level types because tuples are not first-class
values in Lua, only appearing on argument passing, multiple returns,
and multiple assignments.
The type $\Void$ is the type of an empty tuple.
A variadic type $t*$ represents a sequence of values of type $t \cup \Nil$;
it is the type of a vararg expression.
Second-level types include unions of tuples because Lua programs
usually overload the return type of functions to denote error,
as we mentioned in Section \ref{sec:statistics}.
For clarity, we use the symbol $\sqcup$ to represent the union between
two different tuple types.
Note that $\cup$ represents the union between two first-level types,
while $\sqcup$ represents the union between two tuple types.

Back to first-level types, table types represent the various forms
that Lua tables can take.
The syntactical form of table types is $\{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n} \}_{tag}$,
where each $k_{i}$ represents the type of a table key,
and each $v_{i}$ represents the type of the value that table keys of type $k_{i}$ map to.
Key types can only be literal types, base types, or the top type.
We made this restriction to the type of the keys because the statistics
that we discussed in Section \ref{sec:statistics} showed that most
of the tables are records, lists, and hashes.
The type $\Value$ is an option when we need a loose table type.
For instance, $\{\Value:\Value\}_{closed}$ represents the type of a
table that both indices and values can have any type.
Value types can be any first-level type, and can optionally include
the $\Const$ type to denote immutable values.

We also use the tags \emph{closed}, \emph{open}, and \emph{unique}
to classify table types.
The tag \emph{unique} represents tables that have no keys that do not
inhabit one of the table's key types, and that have no alias.
In particular, the type of the table constructor has this tag.
The tag \emph{open} represents \emph{unique} table types that
have at least one alias.
The tag \emph{closed} represents table types that do not provide
any guarantees about keys with types not listed in the table type.
In particular, in the concrete syntax, type annotations, interface
declarations, and userdata declarations always describe \emph{closed} table types.
In the next sections we explain in more detail why we need
different table types.

Any table type has to be \emph{well-formed}.
Informally, a table type is well-formed if key types do not overlap.
In Section \ref{sec:rules} we formalize the definition of well-formed table types.
We delay the proper formalization of well-formed table types because we use
consistent-subtyping in this formalization.

Recursive types have the form $\mu x.t$,
where $t$ is a first-level type that $x$ represents.
For instance, $\mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed}$
is a type for singly-linked lists of integers.
In Section \ref{sec:alias} we mentioned that we can use the following
interface declaration as an alias to this type:
\begin{verbatim}
    local interface Element
      info:integer
      next:Element?
    end
\end{verbatim}

Typed Lua includes projection types as a way to project
unions of tuple types into unions of first-level types,
as we mentioned in Section \ref{sec:unions}.
In Section \ref{sec:rules} we show in more detail how our type system
uses them as a mechanism for handling unions of tuple types,
when they appear on the right-hand side of the declaration of local variables.
We also show how this feature allows our type system to constrain
the type of a local variable that depends on the type of another local variable.

Typed Lua includes the dynamic type $\Any$ for allowing programmers
to mix static and dynamic typing.

\section{Subtyping}
\label{sec:subtyping}

Our type system uses subtyping \citep{cardelli1984smi,abadi1996to} to order
types and consistent-subtyping \citep{siek2007objects,siek2013mutable}
to allow the interaction between statically and dynamically typed code.
We explain the subtyping and consistent-subtyping rules along this section.
However, we focus the discussion on the definition of subtyping because,
as we mentioned in Section \ref{sec:gradual}, we can combine the
consistency and subtyping relations to achieve consistent-subtyping.
The differences between subtyping and consistent-subtyping are the way
they handle the dynamic type, and the fact that subtyping is transitive,
but consistent-subtyping is not.

We present the subtyping rules as a deduction system for the
subtyping relation $\senv \vdash t_{1} \subtype t_{2}$.
The variable $\senv$ is a set of pairs of recursion variables.
We need this set to record the hypotheses that we assume when checking
recursive types.

The subtyping rules for literal types and base types include the rules
for defining that literal types are subtypes of their respective base types,
and that $\Integer$ is subtype of $\Number$:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FALSE}\\
\senv \vdash \False \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-TRUE}\\
\senv \vdash \True \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-STRING}\\
\senv \vdash {\it string} \subtype \String
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-INT1}\\
\senv \vdash {\it int} \subtype \Integer
\end{array}
\;
\begin{array}{c}
\mylabel{S-INT2}\\
\senv \vdash {\it int} \subtype \Number
\end{array}
\;
\begin{array}{c}
\mylabel{S-FLOAT}\\
\senv \vdash {\it float} \subtype \Number
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-NUMBER}\\
\senv \vdash \Integer \subtype \Number
\end{array}
\end{array}
\]

Subtyping is reflexive and transitive;
therefore, we could have omitted the rule \textsc{S-INT2}.
More precisely, we could have defined a transitive rule for first-level
types instead of defining specific rules for transitive cases.
For instance, a transitive rule would allow us to derive that
\[
\dfrac{\senv \vdash 1 \subtype \Integer \;\;\;
       \senv \vdash \Integer \subtype \Number}
      {\senv \vdash 1 \subtype \Number}
\]

However, we are using the subtyping rules as the template for defining
the consistent-subtyping rules, and consistent-subtyping is not
transitive.
More precisely, we want the subtyping and consistent-subtyping rules
to differ only in the way they handle the dynamic type.
Thus, we define the subtyping rules using an algorithmic
way that is close to the implementation, as this way allows us to use
subtyping to easily formalize consistent-subtyping.

Our type system includes the top type $\Value$,
so any first-level type is a subtype of $\Value$:
\[
\begin{array}{c}
\mylabel{S-VALUE}\\
\senv \vdash t \subtype \Value
\end{array}
\]

Many programming languages include a bottom type to represent
an empty value that programmers can use as a default expression,
and we could have used the type $\Nil$ for this role.
However, making $\Nil$ the bottom type would lead to several expressions
that would pass the type checker, but that would fail during run-time
in the presence of a \texttt{nil} value.
Thus, our type system does not have a bottom type, and $\Nil$ is a
subtype only of itself and of $\Value$.

Another type that is only a subtype of itself and of the type $\Value$
is the type $\Self$.

The subtyping rules for union types are standard:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION1}\\
\dfrac{\senv \vdash t_{1} \subtype t \;\;\;
       \senv \vdash t_{2} \subtype t}
      {\senv \vdash t_{1} \cup t_{2} \subtype t}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION2}\\
\dfrac{\senv \vdash t \subtype t_{1}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION3}\\
\dfrac{\senv \vdash t \subtype t_{2}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\end{array}
\]

The first rule shows that a union type $t_{1} \cup t_{2}$
is subtype of $t$ if both $t_{1}$ and $t_{2}$ are subtypes
of $t$;
and the other rules show that a type $t$ is subtype
of a union type $t_{1} \cup t_{2}$ if $t$ is subtype of
either $t_{1}$ or $t_{2}$.

The subtyping rule for function types is also standard:
\[
\begin{array}{c}
\mylabel{S-FUNCTION}\\
\dfrac{\senv \vdash s_{2} \subtype s_{1} \;\;\;
       \senv \vdash r_{1} \subtype r_{2}}
      {\senv \vdash s_{1} \rightarrow s_{1} \subtype s_{2} \rightarrow r_{2}}
\end{array}
\]

The rule \textsc{S-FUNCTION} shows that subtyping between
function types is contravariant on the type of the parameter list
and covariant on the return type.
In the previous section we explained why our type system uses
second-level types to represent the type of the parameter list
and the return type.
Now, we explain their subtyping rules.

The simplest tuple type is the type $\Void$ that is the type of an
empty tuple and it is subtype only of itself.

The subtyping rule for pair types is standard, but the subtyping rules
for variadic types are not so obvious:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-PAIR}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash s_{1} \subtype s_{2}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG1}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1}{*} \subtype t_{2}{*}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-VARARG2}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2}}
      {\senv \vdash t_{1}{*} \subtype t_{2} \times \Void}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG3}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1} \times \Void \subtype t_{2}{*}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-VARARG4}\\
\dfrac{\senv \vdash t_{1}{*} \subtype t_{2} \times \Void \;\;\;
       \senv \vdash t_{1}{*} \subtype s_{2}}
      {\senv \vdash t_{1}{*} \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-VARARG5}\\
\dfrac{\senv \vdash t_{1} \times \Void \subtype t_{2}{*} \;\;\;
       \senv \vdash s_{1} \subtype t_{2}{*}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2}{*}}
\end{array}
\end{array}
\]

The subtyping rules for pair and variadic types show that they are covariant.
While we need just one subtyping rule for pair types,
we need five different subtyping rules for variadic types
to handle all the cases where they can appear.
The rule \textsc{S-VARARG1} handles the case that both tuple types end
with variadic types, while the other rules handle the cases that only
one tuple type ends with a variadic type.
Note that the case where both tuple types end with the type $\Void$ does
not require any special rule.
The rule \textsc{S-VARARG1} shows that $t_{1}{*}$ is subtype of $t_{2}{*}$
if $t_{1} \cup \Nil$ is subtype of $t_{2} \cup \Nil$.
This rule explicit includes $\Nil$ in both sides because otherwise
$\Nil{*}$ would not be a subtype of several other variadic types.
For instance, $\Nil{*}$ would not be subtype of $\Number{*}$,
as $\Nil \not\subtype \Number$.
In the next section we will show that we use these subtyping relations,
along with the types $\Value$ and $\Nil$, to make our type system reflect
the semantics of Lua on discarding extra parameters, and
replacing missing parameters.

The subtyping rules for unions of tuple types are similar to the
subtyping rules for unions of first-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION4}\\
\dfrac{\senv \vdash s_{1} \subtype s \;\;\;
       \senv \vdash s_{2} \subtype s}
      {\senv \vdash s_{1} \sqcup s_{2} \subtype s}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION5}\\
\dfrac{\senv \vdash s \subtype s_{1}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION6}\\
\dfrac{\senv \vdash s \subtype s_{2}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\end{array}
\]

Back to the subtyping rules between first-level types,
the subtyping rule between \emph{closed} table types resembles the
standard subtyping rule between records:
\[
\begin{array}{c}
\mylabel{S-TABLE1}\\
\dfrac{\forall i \in 1..n \; \exists j \in 1..m \;\;\;
       \senv \vdash k_{j} \subtype k_{i}' \;\;\;
       \senv \vdash k_{i}' \subtype k_{j} \;\;\;
       \senv \vdash v_{j} \subtype_{c} v_{i}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{closed} \subtype \{k_{1}'{:}v_{1}', ..., k_{n}'{:}v_{n}'\}_{closed}} \; m \ge n
\end{array}
\]

The rule \textsc{S-TABLE1} allows width subtyping between \emph{closed}
table types, and introduced the auxiliary relation $\subtype_{c}$ to
handle depth subtyping on the type of the values stored in the table fields.
We need an auxiliary relation because the subtyping of the
type of the values stored in the table fields changes according to
the tags of the table types.
We define the relation $\subtype_{c}$ as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD1}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2} \;\;\;
       \senv \vdash v_{2} \subtype v_{1}}
      {\senv \vdash v_{1} \subtype_{c} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD2}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD3}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{c} \Const \; v_{2}}
\end{array}
\end{array}
\]

These rules allow closed table types to have depth subtyping on $\Const$ fields.
The rule \textsc{S-FIELD1} defines that mutable fields are invariant,
while the rule \textsc{S-FIELD2} defines that immutable fields are covariant.
The rule \textsc{S-FIELD3} defines that it is safe to promote fields
from mutable to immutable.
We do not include a rule that allows promoting fields from immutable
to mutable because this would be unsafe due to variance.

There is a limitation on \emph{closed} table types that led us to
introduce \emph{open} and \emph{unique} table types.
If the table constructor had a \emph{closed} table type, then
programmers would not be able to use it to initialize a variable with
a table type that describes a more general type.
For instance,
\begin{verbatim}
    local t:{"x":integer, "y":integer?} = { x = 1, y = 2 }
\end{verbatim}
would not type check, as the type of the table constructor would not
be subtype of the type in the annotation.
More precisely,
\[
\{``x":1, ``y":2\}_{closed} \not\subtype \{``x":\Integer, ``y":\Integer \cup \Nil\}_{closed}
\]

Simply promoting the type of each table value to its supertype would
not overcome this limitation, as it still would give to the table constructor
a closed table type without covariant mutable fields.
Thus, programmers would not be able to use the table constructor to
initialize a variable with a table type that includes an optional field.
Using the previous example,
\begin{align*}
& \{``x":\Integer, ``y":\Integer\}_{closed} \not\subtype \\
& \{``x":\Integer, ``y":\Integer \cup \Nil\}_{closed}
\end{align*}

We introduced \emph{unique} table types to avoid this limitation,
as they represent the type of the tables that have no keys that do not
inhabit one of the table's key types, and that have no alias.
In particular, this is the case of the table constructor.
The following subtyping rule defines the subtyping relation among
\emph{unique} table types and other table types:
\[
\begin{array}{c}
\mylabel{S-TABLE2}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{u} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{unique} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open|unique}}
\end{array}
\]

Unlike the rule \textsc{S-TABLE1}, the rule \textsc{S-TABLE2} allows
covariant keys and do not allow width subtyping.
We allow this behavior to \emph{unique} table types because we also
want to use them as a way to join table fields.
For instance, we may want to use the table constructor to initialize
a variable with a table type that describes a hash.

The rule \textsc{S-TABLE2} introduced the auxiliary relations
$\subtype_{u}$ and $\subtype_{o}$.
The first allows depth subtyping on all fields,
while the second allows the omission of optional fields.
We define them as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FIELD4}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD5}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash \Const \; v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD6}\\
\dfrac{\senv \vdash v_{1} \subtype v_{2}}
      {\senv \vdash v_{1} \subtype_{u} \Const \; v_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD7}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} v}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD8}\\
\dfrac{\senv \vdash \Nil \subtype v}
      {\senv \vdash \Nil \subtype_{o} \Const \; v}
\end{array}
\end{array}
\]

We also do not allow width and depth subtyping between \emph{open}
table types or between \emph{open} and \emph{closed} table types:
\[
\begin{array}{c}
\mylabel{S-TABLE3}\\
\dfrac{\forall i \in 1..m \; \senv \vdash k_{i} \subtype k_{i}' \;\;\;
       \senv \vdash v_{i} \subtype_{c} v_{i}' \;\;\;
       \forall j \in m+1..n \; \senv \vdash \Nil \subtype_{o} v_{j}'}
      {\senv \vdash \{k_{1}{:}v_{1}, ..., k_{m}{:}v_{m}\}_{open} \subtype
                    \{k_{1}'{:}v_{1}', ..., k_{m}'{:}v_{m}', ..., k_{n}'{:}v_{n}'\}_{closed|open}}
\end{array}
\]

The rule \textsc{S-TABLE3} uses the same rules from
\textsc{S-TABLE1} for handling the type of the values of each key, and
it uses the same rules from \textsc{S-TABLE2} to allow joining fields plus
omitting optional fields.

In the next section we will show in more detail how our type system
handles \emph{open} and \emph{unique} table types to allow the refinement of
table types.

We use the \emph{Amber rule} \citep{cardelli1986amber} to define
subtyping between recursive types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-AMBER}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-ASSUMPTION}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
      {\senv \vdash x_{1} \subtype x_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-AMBER} also uses the rule \textsc{S-ASSUMPTION}
to check whether $\mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}$.
Both rules use the set of assumptions $\senv$,
where each assumption is a pair of recursion variables.
The rule \textsc{S-AMBER} extends $\senv$ with the assumption
$x_{1} \subtype x_{2}$ to check whether $t_{1} \subtype t_{2}$.
The rule \textsc{S-ASSUMPTION} allows the rule \textsc{S-AMBER}
to check whether an assumption is valid.

A recursive type may appear inside a first-level type, and our
type system includes subtyping rules to handle subtyping between
recursive types and other first-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNFOLDR}\\
\dfrac{\senv \vdash t_{1} \subtype [x \mapsto \mu x.t_{2}]t_{2}}
      {\senv \vdash t_{1} \subtype \mu x.t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNFOLDL}\\
\dfrac{\senv \vdash [x \mapsto \mu x.t_{1}]t_{1} \subtype t_{2}}
      {\senv \vdash \mu x.t_{1} \subtype t_{2}}
\end{array}
\end{array}
\]

As an example, the rule \textsc{S-UNFOLDR} allows our type system to
type check the function \texttt{insert} from Section \ref{sec:alias}:
\begin{verbatim}
    local function insert (e:Element?, v:integer):Element
      return { info = v, next = e }
    end
\end{verbatim}
that is, the type checker uses the rule \textsc{S-UNFOLDR} to verify whether
the type of the table constructor is a subtype of \texttt{Element}:
\begin{align*}
\{ & ``info":\Integer, \\
   & ``next":\mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed} \cup \Nil \}_{unique} \subtype \\
& \mu x.\{``info":\Integer, ``next":x \;\cup\; \Nil\}_{closed}
\end{align*}

Projection types are subtypes only of themselfs and of $\Value$.
More precisely, a projection type $\pi_{i}^{x}$ is a subtype of the
same projection type $\pi_{i}^{x}$, which shares the same union of
tuples $x$ and the same index $i$, and it is also a subtype of $\Value$.

The dynamic type $\Any$ is neither the bottom nor the top type,
but a separate type that is subtype only of itself and of $\Value$.

Even though the dynamic type $\Any$ does not interact with subtyping,
it does interact with consistent-subtyping.
We present the consistent-subtyping rules as a deduction system for
the consistent-subtyping relation $\senv \vdash t_{1} \lesssim t_{2}$.
Like in the subtyping relation, $\senv$ is also a set of pairs of
recursion variables.
We define the consistent-subtyping rules for the dynamic type $\Any$
as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{C-ANY1}\\
\senv \vdash t \lesssim \Any
\end{array}
\;
\begin{array}{c}
\mylabel{C-ANY2}\\
\senv \vdash \Any \lesssim t
\end{array}
\end{array}
\]

If we had set the type $\Any$ as both bottom and top types of our
subtyping relation, then any type $t_{1}$ would be subtype of
any other type $t_{2}$.
The consequence of this is that all programs would type check without errors.
This would happen due to the transitivity of subtyping, that is,
we would be able to down-cast any type $t_{1}$ to $\Any$ and then up-cast
$\Any$ to any other type $t_{2}$.
The rules \textsc{C-ANY1} and \textsc{C-ANY2} are the rules that
allow the dynamic type to interact with other first-level types,
and thus allow dynamically typed code to coexist with statically
typed code.
Because of these two rules, consistent-subtyping cannot be transitive.
These two rules are the only rules that differ between
subtyping and consistent-subtyping, if we implement the subtyping rules
as we do in this section.

In the implementation of Typed Lua we also use consistent-subtyping to
normalize and simplify union types, though we let them free in the
formalization.
For instance, the union type \texttt{boolean|any} results in the
type \texttt{any}, because \texttt{boolean} is consistent-subtype
of \texttt{any}.
Another example is the union type \texttt{number|nil|1} that
results in the union type \texttt{number|nil}, because
\texttt{1} is consistent-subtype of \texttt{number}.

\section{Typing rules}
\label{sec:rules}

In this section we use a reduced core of Typed Lua to present the
most interesting rules of our type system.
This core limits control flow to if and while statements,
has explicit type annotations, and explicit scope for variables.
It also has explicit method declarations and explicit method calls
instead of treating them as syntactic sugar.
We use this reduced core because it simplifies the presentation
of our type system.
Appendix \ref{app:rules} presents the full set of typing rules.

\begin{figure}[!ht]
\textbf{Abstract Syntax}\\
\dstart
$$
\begin{array}{rl}
s ::= & \;\; \mathbf{skip} \; | \;
s_{1} \; ; \; s_{2} \; | \;
\vec{l} = el \; | \;
m \; | \;
\mathbf{while} \; e \; \mathbf{do} \; s \; | \;
\mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}\\
& | \; \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s \; | \;
\mathbf{rec} \; n{:}t = f \; \mathbf{in} \; s \; | \;
\mathbf{return} \; el \; | \;
e(el)_{s} \; | \;
e{:}n(el)_{s}\\
e ::= & \;\; \mathbf{nil} \; | \;
c \; | \;
{...}_{e} \; | \;
n_{e} \; | \;
e_{1}[e_{2}] \; | \;
{<}t{>} \; n \; | \;
f \; | \;
\{ \} \; | \;
\{ \; \vec{p} \; \} \; | \;
\{ \; {...}_{m} \; \} \; | \;
\{ \; \vec{p},{...}_{m} \; \}\\
& | \; e_{1} + e_{2} \; | \;
e_{1} \; {..} \; e_{2} \; | \;
e_{1} == e_{2} \; | \;
e_{1} < e_{2} \; | \;
e_{1} \; \mathbf{and} \; e_{2} \; | \;
e_{1} \; \mathbf{or} \; e_{2} \\
& | \; \mathbf{not} \; e \; | \;
- e \; | \;
\# \; e \; | \;
e(el)_{e} \; | \;
e{:}n(el)_{e}\\
l ::= & \;\; n_{l} \; | \;
e_{1}[e_{2}] \; | \;
n[c] \; {<}t{>}\\
c ::= & \;\; \mathbf{false} \; | \;
\mathbf{true} \; | \;
{\it int} \; | \;
{\it float} \; | \;
{\it string}\\
p ::= & \;\; [e_{1}] = e_{2}\\
el ::= & \;\; \mathbf{nothing} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{e}, me\\
me ::= & \;\; e(el)_{m} \; | \;
e{:}n(el)_{m} \; | \;
{...}_{m}\\
m ::= & \;\; \mathbf{fun} \; n_{1}{:}n_{2} \; (){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; ({...}{:}t){:}r \; fb\\
& | \; \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
f ::= & \;\; \mathbf{fun} \; (){:}r \; fb \; | \;
\mathbf{fun} \; ({...}{:}t){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t}){:}r \; fb \; | \;
\mathbf{fun} \; (\vec{n{:}t},{...}{:}t){:}r \; fb\\
fb ::= & \;\; s \;;\; \mathbf{return} \; el\\
n ::= & \;\; {\it name}\\
\end{array}
$$
\dend
\caption{Typed Lua abstract syntax}
\label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} presents the abstract syntax of core Typed Lua.
It splits the syntactic categories as follows:
$s$ are statements, $e$ are expressions, $l$ are left-hand values,
$el$ are expression lists, $c$ are literal constants, $p$ are expression pairs,
$me$ are expressions with multiple results, $f$ are function declarations,
$m$ are method declarations, $n$ are variable names,
$t$ are first-level types, and $r$ are second-level types.
The notation $\vec{n{:}t}$ denotes the non-empty list
$n_{1}{:}t_{1}, ..., n_{n}{:}t_{n}$.

Our reduced core also splits function application, method application, and
the vararg expression (${...}$) into different syntactic categories.
It uses $e(el)_{s}$ to denote function applications that return no value
because they appear as statements,
$e(el)_{e}$ to denote function applications that return only one value,
and $e(el)_{m}$ to denote function applications that return multiple values.
It uses the same categories for method applications, but only ${...}_{e}$
and ${...}_{m}$, as the vararg expression cannot appear as a statement.

We also include two kinds of type cast in our core language:
the expression ${<}t{>} \;n$ and the left-hand value $n[c] \; {<}t{>}$.
We will show that the first helps allowing safe aliasing between
table types, while the second allows the refinement of table types.
Due to the refinement of table types we also split variable names
into two categories: $n_{e}$ when they appear as expressions and
$n_{l}$ when they appear as left-hand values.

We will present the typing rules as a deduction system for the typing
relations $\env_{1} \vdash s : \env_{2}$ and $\env_{1} \vdash e : t, \env_{2}$. 
We will use the first one for typing statements, and the second one
for typing expressions.
The first relation means that given the type environment $\env_{1}$,
typing the statement $s$ produces the new type environment $\env_{2}$. 
The second relation means that given the type environment $\env_{1}$,
the expression $e$ has type $t$, and produces the new type environment $\env_{2}$.
We need two typing relations because only expressions have types,
though both expressions and statements can modify the environment.
The environment maps variables to types, and we will use $\env_{1}[n \mapsto t]$
for meaning that we extended the environment $\env_{1}$ with the
variable $n$ that maps to type $t$, and this mapping does not affect
the other mappings that existed before.

We start with the rule that defines the most unusual feature of
our type system: the refinment of table types.
The rule \textsc{T-REFINE} allow us to add new keys to \emph{open}
and \emph{unique} table types:
\[
\begin{array}{c}
\mylabel{T-REFINE}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n} \}_{open|unique}\\
       \env_{1} \vdash c:t_{1}, \env_{2} \;\;\;
       \not \exists i \in 1..n \; t_{1} \lesssim k_{i} \;\;\;
       \Nil \not\lesssim t_{1} \;\;\;
       t_{2} = close(t)
       \end{array}}
      {\env_{1} \vdash n[c] {<}t{>}:t, \env_{2}[n \mapsto \{ k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, t_{1}{:}t_{2}\}_{open|unique}]}
\end{array}
\]

We restricted the refinement of table types to include only literal
keys, because its purpose is to make it easier the construction of
table types that represent records.

We use the refinement of table types to handle global variables.
In Lua, the assignment \texttt{v = v + 1} translates to
\texttt{\string_ENV["v"] = \string_ENV["v"] + 1} when \texttt{v}
is not a local variable, where \texttt{\string_ENV} is a table
that stores the global environment.
For this reason, Typed Lua treats accesses to global variables as field accesses
to an open table in the top-level scope.
For instance,
\[
\string_ENV[``x"] \; {<}\String{>} = ``foo" \;;\; \string_ENV[``y"] \; {<}\Integer{>} = 1
\]
uses field assignment to add fields $``x"$ and $``y"$ to $\string_ENV$.
In all the examples we assume that $\string_ENV$ is in the environment and
has type $\{\}_{open}$.
Therefore, after these field assignments $\string_ENV$ has type
$\{``x":\String, ``y":\Integer\}_{open}$.

We do not allow the refinement of table types to change the type of
a field that is already present in the table type.
For instance,
\[
\string_ENV[``x"] \; {<}\String{>} = ``foo" \;;\; \string_ENV[``x"] \; {<}\Integer{>} = 1
\]
do not type check, as we are trying to add a field that already exists
in $\string_ENV$.
We could have used union types to allow the refinement of existing fields,
but this could lead to fields that have a too general type, which could
decrease the ammount of static type checking.
This means that our type system does not allow the table type to change
towards a type that is not a subtype of the previous type.
In this example,
\[
\{``x":\String \cup \Integer\}_{open} \not\subtype \{``x":\String\}_{open}
\]

We also do not allow the refinement of table types to introduce
\emph{open} or \emph{unique} table fields.
For instance,
\begin{center}
\begin{tabular}{l}
$\string_ENV[``x"] \; {<}\{\}_{unique}{>} = \{\}$
\end{tabular}
\end{center}
refines the type of $\string_ENV$ from $\{\}_{open}$ to $\{``x":\{\}_{closed}\}_{open}$,
though we are trying to refine to $\{``x":\{\}_{unique}\}_{open}$.
We made this restriction because we still need to prove that the refinement
of table types is safe.

Lua has multiple assignments, so Typed Lua also has to take this into
consideration while refining table types.
The rule \textsc{T-ASSINGMENT} shows that tuple types make it easy
to use the consistent-subtyping relation to type check multiple assignments:
\[
\begin{array}{c}
\mylabel{T-ASSIGNMENT}\\
\begin{array}{c}
\dfrac{\env_{1} \vdash el:r_{1}, \env_{2} \;\;\;
       \env_{2} \vdash \vec{l}:r_{2}, \env_{3} \;\;\;
       r_{1} \lesssim r_{2}}
      {\env_{1} \vdash \vec{l} = el:\env_{3}}
\end{array}
\end{array}
\]

This rule is so simple because we left the difficult part to the
type checking of expression lists.
The list of left-hand values is also a kind of expression list.
The difficult part is to check whether there is an expression in
the expression list that messes the environment, and the rule
\textsc{T-LHSLIST} captures this intuition:
\[
\begin{array}{c}
\mylabel{T-LHSLIST}\\
\dfrac{\env \vdash l_{k}:t_{k}, \env_{k} \;\;\;
       \env_{m} = merge(\env_{1}, ..., \env_{n}) \;\;\;
       n = |\;\vec{l}\;|}
      {\env \vdash \vec{l}:t_{1} \times ... \times t_{n} \times \Value{*}, \env_{m}}
\end{array}
\]

First, this rule uses the same environment $\env$ to type check each
left-hand side value $l_{k}$, as they can perform different changes
to the environment.
Then, it takes each type $t_{k}$ and builds the tuple type for
the assignment rule.
It places the type $\Value{*}$ in the end to discard extra values.
The rule succeeds if the predicate \emph{merge} can
produce a new environment, which includes all the modifications
of each environment $\env_{k}$.
Intuitively, the predicate \emph{merge} fails when an environment
tries to change the type of a variable towards a type that is not
a subtype of its previous type.

We can also use multiple assignments to refine table types:
\[
\string_ENV[``x"] \; {<}\String{>}, \string_ENV[``y"] \; {<}\Integer{>} = ``foo", 1
\]

This example type checks because all the environment changes are consistent, and
$``foo" \times 1 \times \Nil{*} \lesssim \String \times \Integer \times \Value{*}$.
The type of the expression list includes the type $\Nil{*}$ in the end
because our type system has typing rules to add this type,
when the type of the expression list does not end with a variadic type.
Our type system has this behavior to use $\Nil$ in the place of missing
values, like Lua does.
This example uses the rule \textsc{T-EXPLIST2}, which is really close
to the rule \textsc{T-LHSLIST}:
\[
\begin{array}{c}
\mylabel{T-EXPLIST2}\\
\dfrac{\env \vdash e_{k}:t_{k}, \env_{k} \;\;\;
       \env_{m} = merge(\env_{1}, ..., \env_{n}) \;\;\;
       n = |\;\vec{e}\;|}
      {\env \vdash \vec{e}:t_{1} \times ... \times t_{n} \times \Nil{*}, \env_{m}}
\end{array}
\]

The next example does not type check because it tries to add
the same field to $\string_ENV$, but with different types:
\[
\string_ENV[``x"] \; {<}\String{>}, \string_ENV[``x"] \; {<}\Integer{>} = ``foo", 1
\]

Typed Lua also keeps track whether it is safe or not safe to
change the type of a table, but before discussing this subject,
we will discuss the different table constructors that our
abstract syntax includes, as they will appear in the next
examples.

Using \emph{unique} table types to represent the type of the table
constructor allows our type system to type check the previous example.
More precisely,
\[
\{``x":1, ``y":2\}_{unique} \subtype \{``x":\Integer, ``y":\Integer \cup \Nil\}_{closed}
\]

Even though \emph{unique} table types overcome our limitation.
The covariance on mutable fields could allow programs that create unsafe
aliases to pass the type checker.
For instance,
\begin{verbatim}
    local t1 = { foo = 5 }
    local t2:{"foo":integer?} = t1
    t2.foo = nil
\end{verbatim}
does not type check, as the last line is erasing the field \texttt{foo}
from \texttt{t1}.
This program would type checks as it is, because our implementation uses
local type inference to assign static types to unannotated locals.
In this example, the type of \texttt{t1} would be subtype of the type of \texttt{t2}.
More precisely,
\[
\{``foo":\Integer\}_{unique} \subtype \{``foo":\Integer \cup \Nil\}_{closed}
\]

In the next section we will show in more detail that this example
does not type check, because our type system promotes an alias
expression from \emph{unique} to \emph{closed}, and promotes the
aliased variable from \emph{unique} to \emph{open}.
This means that the previous example does not type check because
the type of the expression \texttt{t1} is not subtype of the type
of the variable \texttt{t2}.
More precisely,
\[
\{``foo":\Integer\}_{closed} \not\subtype \{``foo":\Integer \cup \Nil\}_{closed}
\]

Thus, we introduced \emph{open} table types to handle the aliasing of table types.

The simplest form of the table constructor is the empty table $\{\}$.
Its inference rule is straightforward:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR1}\\
\env \vdash \{\}:\{\}_{unique}, \env
\end{array}
\]

Our abstract syntax reduces the more complex uses of the table
constructor into three forms: $\{\;\vec{p}\;\}$, $\{\;{...}_{m}\;\}$,
and $\{\;\vec{p},{...}_{m}\;\}$.
The first one uses a list of expression pairs $[e_{1}] = e_{2}$,
the second one uses just the vararg expression, and the third one uses both.
We did not include in the abstract syntax a table constructor
that uses a list of expressions because we can write it using the first form.
For instance, we can write the table constructor
$\{ [1] = ``x", [2] = ``y", [3] = ``z" \}$ to express $\{ ``x", ``y", ``z" \}$.
We chose to not include this form because its inference rule is similar
to the inference rule of the first form, and just controls the type of
the omitted indices.
For the same reason we did not include table constructors with
multiple expressions, which can return a tuple type that does not end
with a variadic type.
We did include the vararg expression in the last position to show how
our type system can infer a table type that has a record part and
also an array part.

The inference rule \textsc{T-CONSTRUCTOR2} infers a table type for
the first form:
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR2}\\
\dfrac{\env_{i} \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       t = wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{unique})}
      {\env_{1} \vdash \{\;\vec{p}\;\}:t, \env_{n+1}}
\end{array}
\]

This inference rule infers the type of each pair, uses these types
to build a table type, and uses the predicate \emph{wf} to check
whether the table type is well formed.
Formally, a table type is well-formed if it obeys the following rule:
\[
\forall i \not\exists j \; i \not= j \wedge k_{i} \lesssim k_{j}
\]

Well-formed table types avoid ambiguous table types.
For instance, this rule detects that the table type
$\{1:\Number, \Integer:\String, \Any:\Boolean\}$ is ambiguous,
because the type of the value stored by key $1$ can be
$\Number$, $\String$, or $\Boolean$, as $1 \lesssim 1$,
$1 \lesssim \Integer$, and $1 \lesssim \Any$.
Moreover, the type of the value stored by a key of type $\Integer$,
which is not the literal type $1$, can be $\Number$ or $\Boolean$,
as $\Integer \lesssim \Integer$, and $\Integer \lesssim \Any$.

The inference rules for expression pairs would be straightforward
if our table types allowed any type in the keys.
The rules \textsc{T-PAIR1}, \textsc{T-PAIR2}, and \textsc{T-PAIR3}
check if the type of the key is a subtype of $\Boolean$, $\Number$,
or $\String$, respectively:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-PAIR1}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Boolean}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}close(t_{2}), \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-PAIR2}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \Number}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}close(t_{2}), \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-PAIR3}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       t_{1} \subtype \String}
      {\env_{1} \vdash [e_{1}] = e_{2}: t_{1}{:}close(t_{2}), \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-PAIR4} is a fallback for the previous rules,
but it works only if the type of the key does not include $\Nil$:
\[
\begin{array}{c}
\mylabel{T-PAIR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1}}
      {\env_{1} \vdash [e_{1}] = e_{2}: \Any{:}close(t_{2}), \env_{3}}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR2} along with the rules for expression
pairs allow Typed Lua to type check the following example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\String:\Integer \cup \Nil\}_{closed} = \{ [``x"] = 1, [``y"] = 2 \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\Integer \cup \Nil = a[``x"] \; \mathbf{in} \; b = a[``z"]$}
\end{tabular}
\end{center}

This example type checks because Typed Lua infers the table type
$\{``x":1, ``y":2\}_{unique}$, which is subtype of
$\{\String:\Integer \cup \Nil\}_{closed}$.
Even though the key $``z"$ does not exist in the table $a$,
the two table indexations type check with type $\Integer \cup \Nil$,
which is subtype of the type of $b$.
The rule \textsc{T-INDEX1} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-INDEX1}\\
\dfrac{\env_{1} \vdash e_{1}:\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3} \;\;\;
       \exists i \in 1{..}n \; t \lesssim k_{i}}
      {\env_{1} \vdash e_{1}[e_{2}]:v_{i}, \env_{3}}
\end{array}
\]

Typed Lua handles arrays as hashes that maps integers to some type $t$.
In Lua, programmers often use the vararg expression to initialize arrays.
The rules \textsc{T-CONSTRUCTOR3} and \textsc{T-CONSTRUCTOR4} define
the behavior of the vararg expression for this case:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-CONSTRUCTOR3}\\
\dfrac{\env_{1}({...}) = t}
      {\env_{1} \vdash \{{...}_{m}\}:\{\Integer{:}t \cup \Nil\}_{unique}, \env_{1}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-CONSTRUCTOR4}\\
\dfrac{\begin{array}{c}
       \env_{i} \vdash p_{i}:k_{i}{:}v_{i}, \env_{i+1} \;\;\;
       n = |\;\vec{p}\;| \;\;\;
       \env_{i+1}({...}) = t_{v}\\
       wf(\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}, \Integer{:}t_{v} \cup \Nil\}_{unique}) = t_{t}
       \end{array}}
      {\env_{1} \vdash \{\;\vec{p},\;{...}_{m}\;\}:t_{t}, \env_{n+1}}
\end{array}
\end{array}
\]

The rule \textsc{T-CONSTRUCTOR3} type checks the case where we use
only the vararg expression inside a table constructor to initialize
an array.
If we assume that the $...$ is in the environment and has type $\String$,
the following example type checks through this rule:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{\Integer:\String \cup \Nil\}_{closed} = \{ {...}_{m} \} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; b:\String \cup \Nil = t[1] \; \mathbf{in} \; b = t[5]$}
\end{tabular}
\end{center}

The rule \textsc{T-CONSTRUCTOR4} type checks the case where we use
the table constructor as a record that includes an array part.
If we assume that the $...$ is in the environment and has type $\String$,
the following example type checks through this rule:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\Integer, ``y":\Boolean, \Integer:\String \cup \Nil\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = \mathbf{true}, {...}_{m} \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; a[``x"] = ``bar"$}
\end{tabular}
\end{center}
but the next example does not type check because the record part
includes fields that the key types are subtype of the array part:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{1:\String, 10:\Boolean, \Integer:\String \cup \Nil\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [1] = ``foo", [10] = \mathbf{true}, {...}_{m} \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; a[``x"] = ``bar"$}
\end{tabular}
\end{center}

Making the inference rules of the table constructor infer an \emph{unique}
table type also allow us to use them for initializing record types that
have optional fields.
We can include the optional field in the initialization
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``y"] = ``bar", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}
and we can also omit it in the initialization
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; a:\{``x":\String, ``y":\String \cup \Nil, ``z":\String\}_{closed} =$}\\
& \multicolumn{1}{l}{$\{ [``x"] = ``foo", [``z"] = ``baz" \}$}\\
\multicolumn{2}{l}{$\mathbf{in} \; \mathbf{skip}$}
\end{tabular}
\end{center}

After discussing the inference rules of the table constructor,
we can get back to the discussion about the refinement of table types.

Besides allowing the refinement of table types through field assignment,
Typed Lua also keeps track whether it is safe or not safe to change the
type of a table.
%To do that, our type system always promotes an \emph{open}
%table to \emph{closed} and an \emph{unique} table to \emph{open}
%when they appear as expressions, or when they enter in a scope that is
%not its declaration scope.
%The order matters, as going from \emph{unique} to \emph{open}
%before going from \emph{open} to \emph{closed} closes \emph{unique} table types.
In the last section we mentioned that aliasing \emph{unique} table
types is unsafe.
To avoid unsafe aliasing of \emph{unique} table types, the rule \textsc{T-IDREAD1}
always promotes them to \emph{closed}, and updates the variable in the
environment to \emph{open}:
\[
\begin{array}{c}
\mylabel{T-IDREAD1}\\
\dfrac{\env_{1}(n) = \{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{unique}}
      {\env_{1} \vdash n_{e}:\{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{closed}, \env_{1}[n \mapsto \{k_{1}{:}v_{1}, ..., k_{n}{:}v_{n}\}_{open}]}
\end{array}
\]

This is the rule that makes the unsafe example from last section to
not type check:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{``foo":\Integer\}_{unique} = \{ [``foo"] = 5 \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``foo":\Integer \cup \Nil \}_{closed} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$b[``foo"] = \mathbf{nil}$}
\end{tabular}
\end{center}

This examples does not type check because aliasing $a$ produces the
type $\{``foo":\Integer\}_{closed}$ that is not subtype of
$\{``foo":\Integer \cup \Nil\}_{closed}$, the type of $b$.

However, sometimes we want to use \emph{unique} table types to initialize
\emph{closed} table types, as they allow us to initialize optional fields.
To do that, Typed Lua includes a cast expression that allow us
to use an \emph{unique} table type before it becomes \emph{open}.
The rule \textsc{T-CAST} describes this behavior:
\[
\begin{array}{c}
\mylabel{T-CAST}\\
\dfrac{\env_{1}(n) \subtype t}
      {\env_{1} \vdash {<}t{>} \; n:t, \env_{1}[n \mapsto t]}
\end{array}
\]

The rule \textsc{T-CAST} allow us to type check the following example:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{ \} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{2}{l}{$a[``y"] \; {<}\String{>} = ``bar";$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{``x":\String, ``y":\String \cup \Nil \}_{closed} =$}\\
& & \multicolumn{1}{l}{${<}\{``x":\String, ``y":\String \cup \Nil\}_{open}{>} \; a \; \mathbf{in} \; a[``z"] \; {<}\Integer{>} = 1$}
\end{tabular}
\end{center}

We can use $a$ to initialize $b$ because the cast expression converts
the type of $a$ from $\{``x":\String, ``y":\String\}_{unique}$ to
$\{``x":\String, ``y":\String \cup \Nil\}_{open}$, which is subtype of
$\{``x":\String, ``y":\String \cup \Nil\}_{closed}$.
We can continue to refine the type of $a$ after the aliasing,
as it still holds an \emph{open} table.
At the end of this example, $a$ has type
$\{``x":\String, ``y":\String \cup \Nil, ``z":\Integer\}_{open}$.

We should also keep tracking of \emph{open} locals, as they can
also be unsafe like in the next example:
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}

We cannot add the field $``x"$ to $b$ because its type is \emph{closed},
and thus do not allow changing the value that is stored in the field $``x"$
of local $a$.

We also need to make sure to close all \emph{open} table types before we
type check another scope.
The rule \textsc{T-FUNCTION3} shows this case:
\[
\begin{array}{c}
\mylabel{T-FUNCTION3}\\
\dfrac{closeall(\env_{1}[\vec{n} \mapsto \vec{t}, \ret \mapsto r]) \vdash s:\env_{2}}
      {\env_{1} \vdash \mathbf{fun} \; (\vec{n{:}t}){:}r \; s:\vec{t} \rightarrow r, closeset(\env_{1}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))}
\end{array}
\]

This rule prevents the following unsafe example to type check:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{local} \; b:\Integer \times \Integer \rightarrow \Integer =$}\\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$}\\
& & & \multicolumn{1}{l}{$a[``z"] \; {<}\Integer{>} = 1; \; \mathbf{return} \; x + y$}\\
& \multicolumn{3}{l}{$\mathbf{in} \; a[``z"] \; {<}\String{>} = ``foo"$}
\end{tabular}
\end{center}

Typed Lua uses the refinement of table types to allow programmers to
build modules and objects.
It also allows Typed Lua to type check an object-oriented idiom that
programmers often use it.
\[
\begin{array}{c}
\mylabel{T-METHOD3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n_{1}) = \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{unique|open} \;\;\;
       \env_{1} \vdash n_{2} : l \;\;\;
       \not \exists i \in 1..n \; l \lesssim k_{i}\\
       closeall(\env_{1}[self \mapsto \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}\}_{closed}, \vec{n} \mapsto \vec{t}, \ret \mapsto r]) \vdash s:\env_{2}\\
       t_{m} = \{k_{i}{:}v_{i}, ..., k_{n}{:}v_{n}, l{:}\Const \; \Self \times \vec{t} \rightarrow r\}_{unique|open}
       \end{array}}
      {\begin{array}{c}
       \env_{1} \vdash \mathbf{fun} \; n_{1}{:}n_{2} \; (\vec{n{:}t}){:}r \; s:\\
       closeset(\env_{1}[n_{1} \mapsto t_{m}, fav(\mathbf{fun} \; (\vec{n{:}t}){:}r \; s))
       \end{array}}
\end{array}
\]

The rule \textsc{T-METHOD3} allow our type system to type check the
following example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{open} = \{ [``x"] = 0.0, [``y"] = 0.0 \}$}\\
\multicolumn{4}{l}{$\mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; s{:}new (x:\Number, y:\Number):\Self$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; s:\{``x":\Number, ``y":\Number\}_{closed} =$}\\
& & & \multicolumn{1}{l}{$setmetatable(\{\}, \{ [``\string_\string_index"] = self \})$}\\
& & \multicolumn{2}{l}{$\mathbf{in} \; s[``x"] = x; \; s[``y"] = y; \; \mathbf{return} \; s$}\\
; & \multicolumn{3}{l}{$\mathbf{fun} \; s{:}move (x:\Number, y:\Number):\Void$}\\
& & \multicolumn{2}{l}{$self[``x"] = self[``x"] + x;$}\\
& & \multicolumn{2}{l}{$self[``y"] = self[``y"] + y$}
\end{tabular}
\end{center}

This example uses the type $\{``x":\Number, ``y":\Number\}_{open}$ to
initialize the local variable $s$, which represents the type of the class
that we are defining.
Then, we use two method definitions to include $new$ and $move$ into
our class that now has type
\begin{align*}
\{ & ``x":\Number, ``y":\Number,\\
   & ``new":\Self \times \Number \times \Number \rightarrow \Self,\\
   & ``move":\Self \times \Number \times \Number \rightarrow \Void \}_{open}
\end{align*}

Inside the definition of the method \emph{new} we use \emph{setmetatable}
to initialize the local $s$ with the type of $\Self$.
The rule \textsc{T-SETMETATABLE} express this idea:
\[
\begin{array}{c}
\mylabel{T-SETMETATABLE}\\
\dfrac{\env_{1} \vdash e:t, \env_{2} \;\;\;
       t \subtype \{\}_{open}}
      {\env_{1} \vdash setmetatable(\{\}, \{[``\string_\string_index"] = e\}):close(t), \env_{2}}
\end{array}
\]

After we define our class, we can use it to create object instances
of this class and call its methods.
The next example assumes the object $o$ is in the environment as
has the type of the class we just defined:
\begin{center}
\begin{tabular}{l}
$o{:}move(10, 10)_{s}$
\end{tabular}
\end{center}

This method call type checks through the rule \textsc{T-INVOKESTM1}.
This rule uses the inference rule \textsc{T-INVOKE1} and discards the results.
We defined the rule \textsc{T-INVOKE1} as follows:
\[
\begin{array}{c}
\mylabel{T-INVOKE1}\\
\dfrac{\env_{1} \vdash e:t, \env_{2} \;\;\;
       \env_{2} \vdash e[n]:p_{1} \rightarrow r, \env_{3} \;\;\;
       \env_{3} \vdash el:p_{2}, \env_{4} \;\;\;
       \Self \times p_{2} \lesssim p_{1}}
      {\env_{1} \vdash e{:}n(el)_{m}:[\Self \mapsto t]r, \env_{4}}
\end{array}
\]

Multiple assignments and multiple return values can also appear in
function applications, as the following example shows:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; m:\Void \rightarrow \Integer \times \String =$} \\
& \multicolumn{3}{l}{$\mathbf{fun} \; ():\Integer \times \String$} \\
& & \multicolumn{2}{l}{$\mathbf{return} \; 2, ``foo"$} \\
\multicolumn{4}{l}{$\mathbf{in}$} \\
& \multicolumn{3}{l}{$\mathbf{local} \; s:\Integer \times \Integer \rightarrow \Integer =$} \\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer, y:\Integer):\Integer$} \\
& & & \multicolumn{1}{l}{$\mathbf{return} \; x + y$} \\
& \multicolumn{3}{l}{$\mathbf{in} \; s(m()_{e}, m()_{m})_{s}$}
\end{tabular}
\end{center}

This example does not type check because we are trying to call
$s$ with $\Integer \times \Integer \times \String$,
but its input parameter has type $\Integer \times \Integer$.
Lua drops extra values in function calls, and Typed Lua can also
have this behavior.
If we change the input type of $s$ to $\Integer \times \Integer \times \Value{*}$,
this example type checks.
Typed Lua also has to adjust function calls to use $\Nil$ in the
place of missing parameters, otherwise it would not be able to
type check function calls that have optional parameters.

\textit{/* I guess we should have different typing rules for strict and default. */}

Typed Lua includes four typing rules to handle the $\mathbf{or}$
logical operator and its common idioms:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR1}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \Nil \not\lesssim t \;\;\;
       \False \not\lesssim t}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR2}\\
\dfrac{\env_{1} \vdash e_{1}:\Nil, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-OR3}\\
\dfrac{\env_{1} \vdash e_{1}:\False, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-OR1} is the rule that implements the short circuit.
We use the consistent-subtyping relation in this rule to guarantee that
the type system checks the second expression when the first one
has the dynamic type, as it can be hiding a false value.

The rules \textsc{T-OR2} and \textsc{T-OR3} guarantee that the final
result is the type of the second expression, because the first one
is certainly a false value.

The rule \textsc{T-OR4} is the most general rule, but it is also
the rule that handles the common $\mathbf{or}$ idioms.
It uses the predicate \emph{filter} to filter possible false values
that might be part of the type of the first expression.
We can use pattern matching to the define the recursive predicate
\emph{filter} as follows:
\begin{align*}
filter(t_{1} \cup t_{2}, t_{1}) & = filter(t_{2}, t_{1})\\
filter(t_{1} \cup t_{2}, t_{2}) & = filter(t_{1}, t_{2})\\
filter(t_{1} \cup t_{2}, t_{3}) & = filter(t_{1}, t_{3}) \cup filter(t_{2}, t_{3})\\
filter(t_{1}, t_{2}) & = t_{1}
\end{align*}

Using these typing rules our type system can type check the following
example:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\String \cup \Nil = \mathbf{nothing} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

Without the \emph{filter} predicate,
the expression $x \; \mathbf{or} \; ``Hello"$ would have type
$\String \cup \Nil \cup ``Hello"$.
The \emph{filter} predicate removes the type $\Nil$ from the result,
leaving type $\String \cup ``Hello"$.
At the end of the evaluation, the expression has type $\String$
because unions are disjoint and $``Hello" \subtype \String$.

\textit{/* The following example does not type check */}
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; x:\Nil \cup \False = \mathbf{false} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{local} \; y:\String = x \; \mathbf{or} \; ``Hello"$}
\end{tabular}
\end{center}

\textit{/* Should we define the following rules? */}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-OR4}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \cup \False \subtype t_{1} \;\;\;
       t_{1} \subtype \Nil \cup \False}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR5}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(filter(t_{1}, \Nil), \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR6}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \Nil) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR7}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:filter(t_{1}, \False) \cup t_{2}, \env_{3}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-OR8}\\
\dfrac{\env_{1} \vdash e_{1}:t_{1}, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t_{2}, \env_{3} \;\;\;
       \Nil \not\subtype t_{1} \;\;\;
       \False \not\subtype t_{1}}
      {\env_{1} \vdash e_{1} \; \mathbf{or} \; e_{2}:t_{1} \cup t_{2}, \env_{3}}
\end{array}
\end{array}
\]

\textit{/* Or who writes this kind of code deserves a type error? */}

Another common idiom that programmers use in Lua is to overload
the input parameter of functions, and use the function \texttt{type}
to execute different actions according to their types.
\[
\begin{array}{c}
\mylabel{T-IF2}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = t\\
       closeall(\env_{1}[n \mapsto \String]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[n \mapsto filter(t, \String)) \vdash s_{2}:\env_{3}\\
       \env_{4} = closeset(\env_{1}[n \mapsto t], fav(s_{1}) \cup fav(s_{2}))
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; type(n) == ``string" \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:\env_{4}}

\end{array}
\]

Using the rule \textsc{T-IF2}, Typed Lua can type check the following example:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; o:\String \times \String \cup \Integer \rightarrow \String =$}\\
& \multicolumn{3}{l}{$\mathbf{fun} \; (a:\String, b:\String \cup \Integer):\String$}\\
& & \multicolumn{2}{l}{$\mathbf{local} \; r:\String = ``" \; \mathbf{in}$}\\
& & & \multicolumn{1}{l}{$\mathbf{if} \; type(b) == ``string" \; \mathbf{then} \; r = a \;{..}\;b \; \mathbf{else} \; r = rep(a, b)_{e}\; ;$}\\
& & & \multicolumn{1}{l}{$\mathbf{return} \; r$}\\
\multicolumn{4}{l}{$\mathbf{in} \; o(``foo", 2)_{s}$}
\end{tabular}
\end{center}

We are assuming that the function \emph{rep} is in the environment and has type
$\String \times \Integer \times \String \cup \Nil \rightarrow \String$.

Typed Lua also includes similar rules to handle the tags \texttt{nil},
\texttt{boolean}, and \texttt{number}.
There is also a similar rule for handling the type $\Integer$, but
it works only with Lua 5.3, as it depends on the function \texttt{math.type}.
This function appears only in Lua 5.3 and it returns the string $``integer"$
when its input parameter is a number that has an integer representation,
the string $``float"$ when its input parameter is a number that has a
floating point representation, or $\Nil$ otherwise.

Lua programmers also overload the return type of functions to denote
errors, and Typed Lua also handles this case with the rule \textsc{T-IF3}:
\[
\begin{array}{c}
\mylabel{T-IF3}\\
\dfrac{\begin{array}{c}
       \env_{1}(n) = \pi_{i}\\
       closeall(\env_{1}[\pi \mapsto fpt(\env_{1}(\pi), \Nil, i)]) \vdash s_{1}:\env_{2} \\
       closeall(\env_{1}[\pi \mapsto gpt(\env_{1}(\pi), \Nil, i)) \vdash s_{2}:\env_{3}
      \end{array}}
      {\env_{1} \vdash \mathbf{if} \; n \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}:closeset(\env_{1}, fav(s_{1}) \cup fav(s_{2}))}

\end{array}
\]

\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; q:\pi_{1}, r:\pi_{2} = idiv(1, 2)_{m} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$\mathbf{if} \; q \; \mathbf{then} \; print(q + r)_{s} \; \mathbf{else} \; print(``ERROR: " \; .. \; r)_{s}$}
\end{tabular}
\end{center}

\textit{/* How should we write the typing rule of the local declaration? */}

We are assuming that functions \emph{idiv} and \emph{print} are in
the environment with the respective types
$\Integer \times \Integer \rightarrow \Integer \times \Integer \sqcup \Nil \times \String$
and
$\Value{*} \rightarrow \Void$.

Lua has operator overloading, and allows the programmers to redefine
the behavior of some operations.
For instance, programmers can use metatables to redefine the
behavior of arithmetic operations.
Even though Typed Lua does not support operator overloading yet,
it includes typing rules that allow programmers to use the
dynamic type when they are using overloaded operations.
The following typing rules show how Typed Lua uses the dynamic type
to handle the overloading of arithmetic operations:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-ARITH5}\\
\dfrac{\env_{1} \vdash e_{1}:\Any, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:t, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\;
\begin{array}{c}
\mylabel{T-ARITH6}\\
\dfrac{\env_{1} \vdash e_{1}:t, \env_{2} \;\;\;
       \env_{2} \vdash e_{2}:\Any, \env_{3}}
      {\env_{1} \vdash e_{1} + e_{2}:\Any, \env_{3}}
\end{array}
\end{array}
\]

The rule \textsc{T-ARITH5} allows type checking the following
example:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Any = 1 \; \mathbf{in} \; x = x + 1$
\end{tabular}
\end{center}

This example is safe, but the following it is not:
\begin{center}
\begin{tabular}{l}
$\mathbf{local} \; x{:}\Integer, \;y{:}\Any = 1 \; \mathbf{in} \; x = x + y$
\end{tabular}
\end{center}

Although this last example is not safe, it shows that optional
type systems still preserve the flexibility of dynamically
typed languages along with the benefits of static type checking.
