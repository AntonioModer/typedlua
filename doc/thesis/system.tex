
In the previous chapter we presented an informal overview of Typed Lua.
We showed that programmers can use Typed Lua to combine static and dynamic
typing in the same code, and it allows them to incrementally migrate from
dynamic to static typing.
This is a benefit to programmers that use dynamically typed languages
to build large applications, as static types detect many bugs
during the development phase, and also provide better documentation.

In this chapter we present the formalization of Typed Lua.
Besides its practical contribution, Typed Lua also has some interesting
contributions on the field of optional type systems for scripting
languages.
Namely, it is a simple type system that covers several Lua idioms
and features, such as the refinement of tables, multiple return values,
and optional parameters.
We use typing rules to explain how we implemented the features of Typed Lua.

\section{Types}

Our type system uses subtyping \citep{cardelli1984smi,abadi1996to} to order
types and consistent-subtyping \citep{siek2007objects,siek2013mutable}
to allow the interaction between statically and dynamically typed code.
We will explain the subtyping and consistent-subtyping rules along this
section while we introduce each type from our type system.
We will focus the discussion on the definition of subtyping because,
as we mentioned in Chapter \ref{chap:review}, we achieve the definition of
consistent-subtyping combining consistency and subtyping.
The differences between subtyping and consistent-subtyping are the way
they handle the dynamic type, and the fact that subtyping is transitive,
but consistent-subtyping is not.

\begin{figure}[!ht]
\textbf{Type Language}\\
\dstart
$$
\begin{array}{rlr}
\multicolumn{3}{c}{\textbf{First-level types}}\\
t ::= & \;\; l & \textit{literal types}\\
& | \; b & \textit{base types}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; t \cup t & \textit{disjoint union types}\\
& | \; p \rightarrow r & \textit{function types}\\
& | \; \{v_{i}, ..., v_{n}\}_{closed|open|unique} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.t & \textit{recursive types}\\
& | \; \pi_{i} & \textit{projection types}\\
l ::= & \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} & \\
b ::= & \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String & \\
v ::= & \;\; k:t \; | \; \Const \; k:t & \textit{field types}\\ 
k ::= & \;\; l \; | \; b \; | \; \Any & \textit{key types}\\
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{\textbf{Second-level types}}\\
s ::= & \;\; t &\\
& | \; t* & \textit{variadic types}\\
& | \; t \times s & \textit{tuple types}\\
p ::= & \;\; \Void \; | \; s & \textit{parameters list type}\\
r ::= & \;\; \Void \; | \; s \; | \; s \sqcup r & \textit{return types}\\
\end{array}
$$
\dend
\caption{The abstract syntax of Typed Lua types}
\label{fig:typelang}
\end{figure}

Figure \ref{fig:typelang} presents the abstract syntax of the
Typed Lua types.
Typed Lua splits types into two categories:
\emph{first-level types} and \emph{second-level types}.
Typed Lua uses first-level types to represent Lua values and
second-level types to represent expression lists, and it also
uses them to type multiple assignments and function applications.
First-level types include literal types, base types, the type $\Nil$,
the top type $\Value$, the dynamic type $\Any$, the type $\Self$,
union types, function types, table types, recursive types, and
projection types.
Second-level types include the type $\Void$, tuples of first-level
types optionally ending in a variadic type, and union of these tuples.

Literal types represent the type of literal constants.
They can be the boolean values $\False$ and $\True$,
any integer value, any floating point value, and any string value.
We shall see that literal types are important to type tables as records.

Our type system also includes the following base types: $\Boolean$,
$\Integer$, $\Number$, and $\String$.
The base types $\Boolean$ and $\String$ represent the values that
during run-time Lua tags as \texttt{boolean} and \texttt{string},
respectively;
while the base types $\Integer$ and $\Number$ represent the values
that during run-time Lua tags as \texttt{number}.
We introduced two different base types to represent Lua numbers
because Lua introduced integers recently.

The subtyping rules for literal types include a reflexive rule
and the rules for defining that literal types are subtypes of
their respective base types;
the subtyping rules for base types include a reflexive rule
and another rule for defining that $\Integer$ is subtype of
$\Number$.
We defined these subtyping rules as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-LITERAL}\\
\senv \vdash l \subtype l
\end{array}
\;
\begin{array}{c}
\mylabel{S-FALSE}\\
\senv \vdash \False \subtype \Boolean
\end{array}
\;
\begin{array}{c}
\mylabel{S-TRUE}\\
\senv \vdash \True \subtype \Boolean
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-INT1}\\
\senv \vdash {\it int} \subtype \Integer
\end{array}
\;
\begin{array}{c}
\mylabel{S-INT2}\\
\senv \vdash {\it int} \subtype \Number
\end{array}
\;
\begin{array}{c}
\mylabel{S-FLOAT}\\
\senv \vdash {\it float} \subtype \Number
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-STRING}\\
\senv \vdash {\it string} \subtype \String
\end{array}
\begin{array}{c}
\mylabel{S-BASE}\\
\senv \vdash b \subtype b
\end{array}
\;
\begin{array}{c}
\mylabel{S-NUMBER}\\
\senv \vdash \Integer \subtype \Number
\end{array}
\end{array}
\]

The variable $\senv$ is a set of pairs of recursion variables.
We shall notice that we need this set to record the pairs of valid
recursive types.

Since subtyping is reflexive and transitive,
we could have omitted the reflexive rules \textsc{S-LITERAL} and
\textsc{S-BASE}, as well as the rule \textsc{S-INT2}.
More precisely, we could have used subsumption rules that define
the reflexiveness and transitiveness of subtyping.
In the case of \textsc{S-INT2}, we would not need this rule because
we could use the transitive subsumption rule to derive that
\[
\dfrac{\senv \vdash 1 \subtype \Integer \;\;\;
       \senv \vdash \Integer \subtype \Number}
      {\senv \vdash 1 \subtype \Number}
\]

However, we are using the subtyping rules as the template for defining
the consistent-subtyping rules, and consistent-subtyping is not
transitive.
More precisely, we want the subtyping and consistent-subtyping rules
to differ only in the way they handle the dynamic type.
Thus, we define the subtyping rules using an algorithmic
way that is close to the implementation, as this way allows us to use
subtyping to formalize consistent-subtyping.

The type $\Nil$ represents the type of values that during run-time
Lua tags as \texttt{nil}.
It is a separated type because in our type system $\Nil$ is
not the bottom type.
Typed Lua has this behavior because in Lua the tag \texttt{nil}
represents the absence of an useful value.
Thus, making $\Nil$ the bottom type would severally reduce the
amount of type safety in our type system.
The next subtyping rule shows this behavior:
\[
\begin{array}{c}
\mylabel{S-NIL}\\
\senv \vdash \Nil \subtype \Nil
\end{array}
\]

The type $\Value$ is the top type, so any first-level type is a
subtype of $\Value$.
We shall see that this type along with variadic types help to
preserve the semantics of Lua to drop extra values on multiple
assignments, and function calls.
Following we show its subtyping rule:
\[
\begin{array}{c}
\mylabel{S-VALUE}\\
\senv \vdash t \subtype \Value
\end{array}
\]

The dynamic type $\Any$ is the type that allows programmers to mix
static and dynamic typing.
The type $\Any$ is neither the bottom nor the top type, but a
separated typed that is a subtype only of itself:
\[
\begin{array}{c}
\mylabel{S-ANY}\\
\senv \vdash \Any \subtype \Any
\end{array}
\]

Even though the dynamic type $\Any$ is neutral to subtyping,
it is not to consistent-subtyping:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{C-ANY1}\\
\senv \vdash t \lesssim \Any
\end{array}
\;
\begin{array}{c}
\mylabel{C-ANY2}\\
\senv \vdash \Any \lesssim t
\end{array}
\end{array}
\]

The rules that handle the dynamic type are the only rules that
differ between subtyping and consistent-subtyping.
If we set the type $\Any$ as both bottom and top types of our
subtyping relation, then all programs would type check without errors.
This would happen due to the transitivity of subtyping, that is,
we would be able to down-cast any type to $\Any$ and then up-cast
$\Any$ to any type.
While the rule \textsc{S-ANY} is neutral and makes transitivity
not be a problem, the rules \textsc{C-ANY1} and \textsc{C-ANY2}
are the rules that allow the dynamic type to interact with other
first-level types, and thus allow dynamically typed code coexist
with statically typed code.
Consistent-subtyping cannot be transitive because of these rules,
as transitivity combined with them would make all programs compile
without type errors.

Typed Lua uses the type $\Self$ to represent \emph{objects}.
As we mentioned in Chapter \ref{chap:typedlua}, we need the type
$\Self$ to prevent programmers from indexing a method without
calling it with the correct receiver.
The type $\Self$ is only a subtype of itself:
\[
\begin{array}{c}
\mylabel{S-SELF}\\
\senv \vdash \Self \subtype \Self
\end{array}
\]

Union types represent types that can hold a value of several
different, but fixed types.
Next we show the subtyping rules for union types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-UNION1}\\
\dfrac{\senv \vdash t_{1} \subtype t \;\;\;
       \senv \vdash t_{2} \subtype t}
      {\senv \vdash t_{1} \cup t_{2} \subtype t}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION2}\\
\dfrac{\senv \vdash t \subtype t_{1}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION3}\\
\dfrac{\senv \vdash t \subtype t_{2}}
      {\senv \vdash t \subtype t_{1} \cup t_{2}}
\end{array}
\end{array}
\]

The first rule shows that a union type $t_{1} \cup t_{2}$
is subtype of $t$ if both $t_{1}$ and $t_{2}$ are subtypes
of $t$;
and the other rules show that a type $t$ is subtype
of a union type $t_{1} \cup t_{2}$ if $t$ is subtype of
$t_{1}$ or if $t$ is subtype of $t_{2}$.

Union types are disjoint, that is, the types in the union are not
consistent-subtype of any other type in the same union.
For instance, the union type $\Boolean \;\cup\; \Any$ results the
type $\Any$, because $\Boolean$ is consistent-subtype of $\Any$.
The union type $\Number \;\cup\; \Nil \;\cup\; 1$ results the union
type $\Number \;\cup\; \Nil$ because $1 \subtype \Number$.

\emph{/* Explain how Typed Lua refine union types */}

To introduce function types we first need to introduce
second-level types, as they appear on both sides of function types.
Basically, second-level types are tuples of first-level types
that can optionally end with a variadic type.
Our type system needs second-level types because tuples are
not first-class values in Lua, though they may appear on
argument passing, multiple returns, and multiple assignments.
A variadic type $t*$ is a generator for a sequence of values of
type $t \cup \Nil$, and it represents the type of the vararg
expression.
Next we show their subtyping rules:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VARARG}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \cup \Nil}
      {\senv \vdash t_{1}* \subtype t_{2}*}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE1}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash s_{1} \subtype s_{2}}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2} \times s_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-TUPLE2}\\
\dfrac{\senv \vdash t_{1} \cup \Nil \subtype t_{2} \;\;\;
       \senv \vdash t_{1}* \subtype s_{2}}
      {\senv \vdash t_{1}* \subtype t_{2} \times s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-TUPLE3}\\
\dfrac{\senv \vdash t_{1} \subtype t_{2} \cup \Nil \;\;\;
       \senv \vdash s_{1} \subtype t_{2}*}
      {\senv \vdash t_{1} \times s_{1} \subtype t_{2}*}
\end{array}
\end{array}
\]

The subtyping rules for variadic and tuple types show that
these types are covariant.
The subtyping rule for variadic types is straightforward:
it shows that a variadic type $t_{1}*$ is subtype of another
variadic type $t_{2}*$ if $t_{1} \cup \Nil$ is subtype of
$t_{2} \cup \Nil$.
The first rule for tuple types shows that a tuple type
$t_{1} \times s_{1}$ is subtype of another tuple type
$t_{2} \times s_{2}$ if $t_{1}$ is subtype of $t_{2}$
and $s_{1}$ is subtype of $s_{2}$.
As we mentioned, a tuple can optionally end with a variadic
type, and the second and third rules for tuple types handle
this case.
The second rule shows that a variadic type is subtype of
a tuple whenever the type of the value that it generates is subtype
of all the elements of the tuple.
The third rule shows that a tuple is subtype of a variadic
type whenever all the elements of the tuple are subtype of the
type of the value that it generates.
We shall see that these subtyping relations along with the
types $\Value$ and $\Nil$ allow our type system to reflect
the semantics of Lua on discarding extra parameters and
replacing missing parameters.

In our type system function types have the form $p \rightarrow r$,
where $p$ is the type of the parameters list and $r$ is the
return type.
The type of the parameters list can be $\Void$ or a tuple type,
while the return type can be $\Void$, a tuple type, or a union of tuples.
The type $\Void$ means an empty tuple.
Our type system includes union of tuples on the return type because
in Lua it is common to overload the return type to denote error,
as we mentioned in Section \ref{sec:statistics}.

The type $\Void$ and union of tuple types are also second-level types.
The type $\Void$ is subtype only of itself.
The subtyping rules for union of tuple types are similar to the
subtyping rules for union of first-level types.
Next we show the subtyping rules for these second-level types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-VOID}\\
\senv \vdash \Void \subtype \Void
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-UNION4}\\
\dfrac{\senv \vdash s_{1} \subtype s \;\;\;
       \senv \vdash s_{2} \subtype s}
      {\senv \vdash s_{1} \sqcup s_{2} \subtype s}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION5}\\
\dfrac{\senv \vdash s \subtype s_{1}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UNION6}\\
\dfrac{\senv \vdash s \subtype s_{2}}
      {\senv \vdash s \subtype s_{1} \sqcup s_{2}}
\end{array}
\end{array}
\]

The subtyping rule for function types is standard, that is, it is
contravariant on the type of the parameters list and
covariant on the return type:
\[
\begin{array}{c}
\mylabel{S-FUNCTION}\\
\dfrac{\senv \vdash p_{2} \subtype p_{1} \;\;\;
       \senv \vdash r_{1} \subtype r_{2}}
      {\senv \vdash p_{1} \rightarrow r_{1} \subtype p_{2} \rightarrow r_{2}}
\end{array}
\]

Our type system includes table types to represent Lua tables.
The syntactical form of table types is $\{ v_{i}, ..., v_{n} \}_{tag}$.
When $n = 0$, then $i = 0$ and it represents the type of an empty table.
When $n > 0$, then $i$ varies from 1 to $n$, and each $v_{i}$
represents the type of a table field.
Table fields represent maps from keys to values, and we restricted
the type of keys to literal types, base types, and the dynamic type;
but we can use any first-level type to represent the type of values.
We made this restriction to the type of keys because the statistics
that we discussed in Section \ref{sec:statistics} showed that most
of the tables are records, lists, and hashes.
The dynamic type is an option when we need a more loosen table type.

We also use the tags \emph{closed}, \emph{open}, and \emph{unique}
to classify table types, though they have only one syntactical form.
The first tag represents the table types that the type annotations,
interface, and userdata declarations describe.
The second tag represents the table types that we can use field assignment
to add new fields to them.
The third tag represents the table types of table constructors.
We have different subtyping rules for table types according to their
tags.
We will discuss these subtyping rules in the next paragraphs to
explain why we needed different tags.

The following subtyping rules show that \emph{closed} table types
have width subtyping, and depth subtyping on $\Const$ fields:

\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-TABLE1}\\
\dfrac{\forall i \in 1..n \; \exists j \in 1..m \;\;\;
       \senv \vdash v_{j} \subtype v_{i}}
      {\senv \vdash \{v_{1}, ..., v_{m}\}_{closed} \subtype \{v_{1}, ..., v_{n}\}_{closed}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD1}\\
\dfrac{\senv \vdash k_{2} \subtype k_{1} \;\;\;
       \senv \vdash t_{1} \subtype t_{2} \;\;\;
       \senv \vdash t_{2} \subtype t_{1}}
      {\senv \vdash k_{1}:t_{1} \subtype k_{2}:t_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD2}\\
\dfrac{\senv \vdash k_{2} \subtype k_{1} \;\;\;
       \senv \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \Const \; k_{1}:t_{1} \subtype \Const \; k_{2}:t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD3}\\
\dfrac{\senv \vdash k_{2} \subtype k_{1} \;\;\;
       \senv \vdash t_{1} \subtype t_{2}}
      {\senv \vdash k_{1}:t_{1} \subtype \Const \; k_{2}:t_{2}}
\end{array}
\end{array}
\]

First, we had only \emph{closed} table types.
However, programmers often define tables that include optional fields,
and the subtyping rules we introduced do not let programmers to use
the table constructor to initialize table types that include optional
fields.
For instance, consider the table type we introduced in
Chapter 3:
\begin{align*}
\{ & ``firstname":\String, \\
   & ``middlename":\String \cup \Nil,\\
   & ``lastname":\String \}_{closed}
\end{align*}
Following we show a table type that Typed Lua could assign to a
table constructor that does not include the field $``middlename"$,
but such table type is not subtype of the above table type:
\begin{align*}
\{ ``firstname":\String, ``lastname":\String \}_{closed}
\end{align*}

We introduced \emph{open} table types to allow the refinement
of table types, and also to allow programmers to omit optional
fields in the initialization of table types.
To do that, we defined new subtyping rules that allow \emph{open}
table types to omit fields when $\Nil$ is subtype of the of type
of the value of the omitted key.
The following subtyping rules show this behavior:

\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-TABLE2}\\
\dfrac{\forall i \in 1..m \; \senv \vdash v_{i}' \subtype v_{i}}
      {\senv \vdash \{v_{1}, ..., v_{m}\}_{open} \subtype \{v_{1}', ..., v_{m}', ..., v_{n}'\}_{open|closed}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-TABLE3}\\
\dfrac{\forall i \in 1..m \; \senv \vdash v \subtype v_{i}}
      {\senv \vdash \{v_{1}, ..., v_{m}\}_{open} \subtype \{v\}_{open|closed}} 
\end{array}
\end{array}
\]

However, we still had the that
\begin{align*}
\{ & ``firstname":\String, \\
   & ``middlename":\String,\\
   & ``lastname":\String \}_{open} \not \subtype \\
\{ & ``firstname":\String, \\
   & ``middlename":\String \cup \Nil,\\
   & ``lastname":\String \}_{closed}
\end{align*}

We introduced \emph{unique} table types to solve this problem.
We use \emph{unique} table types only to denote the type of the
table constructor.
The following subtyping rules allow us to use table constructors
that initialize optional fields:

\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-TABLE4}\\
\dfrac{\forall i \in 1..m \; \senv \vdash v_{i}' \subtype_{n} v_{i}}
      {\senv \vdash \{v_{1}, ..., v_{m}\}_{unique} \subtype \{v_{1}', ..., v_{m}', ..., v_{n}'\}_{unique|open|closed}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-TABLE5}\\
\dfrac{\forall i \in 1..m \; \senv \vdash v \subtype_{n} v_{i}}
      {\senv \vdash \{v_{1}, ..., v_{m}\}_{unique} \subtype \{v\}_{unique|open|closed}} 
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD4}\\
\dfrac{\senv \vdash k_{2} \subtype k_{1} \;\;\;
       \senv \vdash t_{1} \subtype t_{2}}
      {\senv \vdash k_{1}:t_{1} \subtype_{n} k_{2}:t_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FIELD5}\\
\dfrac{\senv \vdash k_{2} \subtype k_{1} \;\;\;
       \senv \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \Const \; k_{1}:t_{1} \subtype_{n} \Const \; k_{2}:t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FIELD6}\\
\dfrac{\senv \vdash k_{2} \subtype k_{1} \;\;\;
       \senv \vdash t_{1} \subtype t_{2}}
      {\senv \vdash k_{1}:t_{1} \subtype_{n} \Const \; k_{2}:t_{2}}
\end{array}
\end{array}
\]

Notice that we introduced a special subtyping rule to check the
subtyping of \emph{unique} table fields.
The difference is that \emph{unique} table types have width and
depth subtyping on all fields.

Even though \emph{unique} table types solve the problem of using
table constructors to initialize tables that contain optional fields,
we still have the problem when we try to use a local variable that
holds an \emph{open} table to initialize another table that contains
optional fields.

\emph{/* Do we really need closed, open, and unique? */}

\emph{/* Also, can we make these subtyping rules for tables more clear? */}

Table types can be ambiguous.
For instance, $\{1:\Number, \Number:\String\}$ is an ambiguous
table type because the type of the value stored by key $1$ can be
$\Number$ or $\String$, as $1 \subtype 1$ and
$1 \subtype \Number$.
Table types can get even more ambiguous when we use the dynamic
type in the type of table keys.
For instance, the table type $\{1:\Number, \Number:\String, \Any:\Boolean\}$
is ambiguous because the type of the value stored by key $1$ can be
$\Number$, or $\String$, or $\Boolean$, as $1 \subtype 1$,
$1 \subtype \Number$, and $1 \lesssim \Any$.
The type of the value stored by a key of type $\Number$,
which is not the literal type $1$, can be $\Number$ or $\Boolean$,
as $\Number \subtype \Number$, and $\Number \lesssim \Any$.

To avoid ambiguous table types we use the following rule to check
whether a table type is well formed:
\[
\forall i \not\exists j \; i \not= j \wedge k_{i} \lesssim k_{j}
\]

\emph{/* Can we use this well formed rule to allow $k$ to be $t$? */}

Our type system also includes recursive types: $\mu x.t$,
where $t$ is a function or table type with $x$ appearing anywhere
a function or table type could appear.
For instance, $\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}$
represents the type of single linked lists of numbers.

We use the \emph{Amber rule} from the Amber language
\citep{cardelli1986amber} to define the subtyping rule for
recursive types:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-ASSUMPTION}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
      {\senv \vdash x_{1} \subtype x_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBER}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash t_{1} \subtype t_{2}}
      {\senv \vdash \mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}}
\end{array}
\end{array}
\]

The rule \textsc{S-AMBER} needs the rule \textsc{S-ASSUMPTION}
to show that $\mu x_{1}.t_{1} \subtype \mu x_{2}.t_{2}$.
The rule \textsc{S-ASSUMPTION} checks if the assumption
$x_{1} \subtype x_{2}$ exists in the set of assumptions $\senv$.
The rule \textsc{S-AMBER} extends the set of assumptions
with the assumption $x_{1} \subtype x_{2}$ to check whether
$t_{1} \subtype t_{2}$ or not.

\emph{/* Where should we handle the following case? */}
\begin{align*}
\{ & ``info":\Number, \\
   & ``next":\mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\} \cup \Nil \} \subtype \\
& \mu x.\{``info":\Number, ``next":x \;\cup\; \Nil\}
\end{align*}

\emph{/* Should we also have the following subtyping rules? */}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-AMBERL}\\
\dfrac{\senv \vdash [x \mapsto \mu x.t_{1}]t_{1} \subtype t_{2}}
      {\senv \vdash \mu x.t_{1} \subtype t_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-AMBERR}\\
\dfrac{\senv \vdash t_{1} \subtype [x \mapsto \mu x.t_{2}]t_{2}}
      {\senv \vdash t_{1} \subtype \mu x.t_{2}}
\end{array}
\end{array}
\]

\emph{/* Or having the unfolding typing rule is enough? */}

Our type system also introduces projection types, but they do not
appear on the subtyping and consistent-subtyping rules.
They are just a mechanism that the type system uses for handling
union of tuple types, when they appear on the right-hand side of
the declaration of local variables.
That is the reason why we do not need to define subtyping and
consistent-subtyping rules for them.
We will see projection types in more detail in the next section.

\section{Typing rules}

In this section we will use a reduced core of Typed Lua to present
its typing rules in an easier way.
It is a reduced core of the Lua language with explicit type annotations,
without syntactic sugar, with only if and while control flow statements,
and making variable scope explicit.

\begin{figure}[!ht]
\textbf{Abstract Syntax}\\
\dstart
$$
\begin{array}{rl}
s ::= & \;\; \mathbf{skip} \; | \;
s_{1} \; ; \; s_{2} \; | \;
\vec{l} = el  \; | \;
\mathbf{while} \; e \; \mathbf{do} \; s \; | \;
\mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}\\
& | \; \mathbf{local} \; \vec{n{:}t} = el \; \mathbf{in} \; s \; | \;
\mathbf{rec} \; n{:}t = f \; \mathbf{in} \; s \; | \;
\mathbf{return} \; el \; | \;
a\\
e ::= & \;\; \mathbf{nil} \; | \;
\mathbf{false} \; | \;
\mathbf{true} \; | \;
{\it int} \; | \;
{\it float} \; | \;
{\it string} \; | \;
{...} \; | \;
f \; | \;
\{ \; cl \; \} \\
& | \; e_{1} + e_{2} \; | \;
e_{1} \; {..} \; e_{2} \; | \;
e_{1} == e_{2} \; | \;
e_{1} < e_{2} \; | \;
e_{1} \; \mathbf{and} \; e_{2} \; | \;
e_{1} \; \mathbf{or} \; e_{2} \\
& | \; \mathbf{not} \; e \; | \;
- e \; | \;
\# \; e \; | \;
a \; | \;
l \; | \;
{<}t{>} \; n\\
l ::= & \;\; n \; | \;
e_{1}[e_{2}]\\
el ::= & \;\; \mathbf{nothing} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{e}, me\\
cl ::= & \;\; \mathbf{nothing} \; | \;
\vec{c} \; | \;
\vec{e} \; | \;
me \; | \;
\vec{c}, \vec{e} \; | \;
\vec{c}, me \; | \;
\vec{c}, \vec{e}, me \; | \;
\vec{e}, me\\
me ::= & \;\; a \; | \;
{...}\\
a ::= & \;\; e_{1}(\vec{e_{2}}) \; | \;
e_{1}{:}n(\vec{e_{2}})\\
f ::= & \;\; \mathbf{fun} \; (){:}r \; s \; ; \; \mathbf{return} \; el \; | \;
\mathbf{fun} \; ({...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
& | \; \mathbf{fun} \; (\vec{n{:}t}){:}r \; s \; ; \; \mathbf{return} \; el \; | \;
\mathbf{fun} \; (\vec{n{:}t},{...}{:}t){:}r \; s \; ; \; \mathbf{return} \; el\\
c ::= & \;\; [e_{1}] = e_{2}\\
n ::= & \;\; {\it name}\\
\end{array}
$$
\dend
\caption{Typed Lua abstract syntax}
\label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} presents the abstract syntax of core Typed Lua.
It splits the syntactic categories as follows:
$s$ are statements, $e$ are expressions, $l$ are left-hand values,
$el$ are expression lists, $c$ are constructor fields, $cl$ are lists of
constructor fields, $me$ are multiple expressions, $a$ are function
applications, $f$ are function declarations, $n$ are variable names,
$t$ are first-level types, and $r$ are second-level types.
The notation $\vec{n{:}t}$ denotes the non-empty list
$n_{1}{:}t_{1}, ..., n_{n}{:}t_{n}$.

We will present the typing rules as a deduction system for the typing
relations $\env_{1} \vdash s : \env_{2}$ and $\env_{1} \vdash e : t, \env_{2}$. 
We will use the first one for typing statements, and the sencond one
for typing expressions. 
The first relation means that given the type environment $\env_{1}$,
typing the statement $s$ produces the new type environment $\env_{2}$. 
The sencond relation means that given the type environment $\env_{1}$,
the expression $e$ has type $t$, and produces the new type environment $\env_{2}$.
We need two typing relations because only expressions have types,
though both expressions and statements can modify the environment.
The environment maps variables to types, and we will use $\env_{1}[n \mapsto t]$
for meaning that we extended the environment $\env_{1}$ with the
variable $n$ that maps to type $t$, and this mapping does not affect
the other mappings that extisted before.
