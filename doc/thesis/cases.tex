
Categories:
\begin{enumerate}
\item Easy to type, because the current type system is enough.
\item Not easy to type, because it requires polymorphism.
\item Hard to type, because neither the current type system nor
      polymorphism are enough.
\end{enumerate}

\section{Lua standard libraries}

\subsection{Basic functions}

\begin{enumerate}
\item assert (v [, message]) :
\begin{verbatim}
(any, string?) -> (any, string?) | (nil)
\end{verbatim}
Category 2?
\\
When \textbf{v} is $\Nil$ or $\False$, \textbf{assert}
shows the error \textbf{message}.
Otherwise, \textbf{assert} returns \textbf{v} and all the extra
parameters.
\item collectgarbage ([opt [, arg]]) :
\begin{verbatim}
(string?, number?) -> (number) | (number, number) | (boolean)
\end{verbatim}
Category 3.
\\
The return type depends on the type of \textbf{opt}:
\begin{verbatim}
() -> (number)
("collect") -> (number)
("stop") -> (number)
("restart") -> (number)
("count") -> (number, number)
("step") -> (boolean)
("setpause") -> (number)
("setstepmul") -> (number)
("isrunning") -> (boolean)
("generational") -> (number)
("incremental") -> (number)
\end{verbatim}
\item dofile ([filename]) :
\begin{verbatim}
(string?) -> (any*)
\end{verbatim}
Category 3?
\item error (message [, level]) :
\begin{verbatim}
(string, number?) -> ()
\end{verbatim}
Category 1.
\item \_G :
\begin{verbatim}
{string:any}
\end{verbatim}
Category 3?
\item getmetatable (object) :
\begin{verbatim}
(any) -> (any?)
\end{verbatim}
Category 3.
\item ipairs (t) :
\begin{verbatim}
({any}) -> ((any*) -> (any*)
\end{verbatim}
Category 3.
\\
\begin{itemize}
\item What happens when \textbf{t} has a metamethod \textbf{\_\_ipairs}?
\item Will \texttt{\{"tag":string, number:any\}} type check?
\item In fact, \textbf{ipairs} and \textbf{pairs} return three values.
Need to check this.
\end{itemize}
\item load (ld [, source [, mode [, env]]]) :
\begin{verbatim}
(string|(any*) -> (any*), string?, string?, any?) ->
((any*) -> (any*))?
\end{verbatim}
Category 3?
\\
I guess the proper type should be:
\begin{verbatim}
(string|(any*) -> (any*)) |
(string|(any*) -> (any*), string) |
(string|(any*) -> (any*), string, string, any?) ->
((any*) -> (any*))?
\end{verbatim}
\item loadfile ([filename [, mode [, env]]]) :
\begin{verbatim}
(string?, string?, any?) -> ((any*) -> (any*))?
\end{verbatim}
Category 3?
\\
I guess the proper type should be:
\begin{verbatim}
() | (string) | (string, string) | (string, string, any?) ->
((any*) -> (any*))?
\end{verbatim}
\item next (table [, index]) :
\begin{verbatim}
({any:any}, any?) -> (any, any) | (nil)
\end{verbatim}
Category 2.
\item pairs (t) :
\begin{verbatim}
({any}) -> ((any*) -> (any*)
\end{verbatim}
Category 3.
\item pcall (f [, arg1, ···]) :
\begin{verbatim}
((any*) -> (any*), any*) -> (true, any*) | (false, string)
\end{verbatim}
Category 3?
\item print (···) :
\begin{verbatim}
(value*) -> ()
\end{verbatim}
Category 1.
\item rawequal (v1, v2) :
\begin{verbatim}
(value, value) -> (boolean)
\end{verbatim}
Category 2.
\item rawget (table, index) :
\begin{verbatim}
({}, any) -> (any)
\end{verbatim}
Category 2.
\item rawlen (v) :
\begin{verbatim}
({}|string) -> (number)
\end{verbatim}
Category 1.
\item rawset (table, index, value) :
\begin{verbatim}
({any:any}, any, any) -> ({any:any})
\end{verbatim}
Category 3.
\\
In fact, \textbf{index} cannot be $\Nil$ or \texttt{NaN}.
\item select (index, ···) :
\begin{verbatim}
(number, any*) -> (any*)
\end{verbatim}
Category 3.
\\
When \textbf{index} is the string ``\texttt{\#}", the typing is:
\begin{verbatim}
(string, any*) -> (number)
\end{verbatim}
\item setmetatable (table, metatable) :
\begin{verbatim}
({any:any}, {any:any}|nil) -> ({any:any}) 
\end{verbatim}
Category 3.
\\
Even though \textbf{metatable} can be $\Nil$, it is not optional.
This function is a primitive in the type system.
\item tonumber (e [, base]) :
\begin{verbatim}
(value, number|string?) -> (number) | (nil)
\end{verbatim}
Category 3.
\\
The type of \textbf{base} depends on the type of \textbf{e}:
\begin{verbatim}
(value) -> (number) | (nil)
(string, number|string) -> (number) | (nil)
\end{verbatim}
\item tostring (v) :
\begin{verbatim}
(value) -> (string)
\end{verbatim}
Category 1.
\item type (v) :
\begin{verbatim}
(value) ->
("nil"|"number"|"string"|"boolean"|"table"|"function"|"thread"|"userdata")
\end{verbatim}
Category 1.
\\
This function is a primitive in the type system.
\item \_VERSION :
\begin{verbatim}
string
\end{verbatim}
Category 1.
\item xpcall (f, msgh [, arg1, ···]) :
\begin{verbatim}
((any*) -> (any*), any, any*) -> (true, any*) | (false, string)
\end{verbatim}
Category 3?
\end{enumerate}

\subsection{Coroutine manipulation}

\begin{enumerate}
\item coroutine.create (f) :
$(\TopStar \rightarrow \TopStar) \times \TopStar \rightarrow Thread \times \NilStar$
\item coroutine.resume (co [, val1, ···]) :
$Thread \times
\TopStar \rightarrow
(\True \times \AnyStar) \cup
(\False \times \String \times \NilStar)$
\item coroutine.running () :
$\TopStar \rightarrow Thread \times \Boolean \times \NilStar$
\item coroutine.status (co) :
$Thread \times \TopStar \rightarrow \String \times \NilStar$
\item coroutine.wrap (f) :
$(\TopStar \rightarrow \TopStar) \times
\TopStar \rightarrow
(\TopStar \rightarrow \TopStar) \times
\NilStar$ 
\item coroutine.yield (···) :
$\TopStar \rightarrow \NilStar$
\end{enumerate}

\subsection{Modules}

\begin{enumerate}
\item require (modname) :
$\String \times \TopStar \rightarrow \{\Any:\Any\} \times \NilStar$
\\
The function \textbf{require} returns exactly the same value that is
returned by loading \textbf{modname}.
However, if the returned value is $\Nil$, this value is
converted to $\True$.
\item package.config : $\String$
\item package.cpath : $\String$
\item package.loaded : $\{\String:\{\Any:\Any\}\}$
\item package.loadlib (libname, funcname) :
$\String \times
\String \times
\TopStar \rightarrow
(\True \times \NilStar) \cup
(\Nil \times \String \times \NilStar)$
\item package.path : $\String$
\item package.preload : $\{\String:\{\Any:\Any\}\}$
\item package.searchers : $\{\Number:\TopStar \rightarrow \TopStar\}$
\item package.searchpath (name, path [, sep [, rep]]) :
$\String \times
\String \times
(\String \cup \Nil) \times
(\String \cup \Nil) \times
\TopStar \rightarrow
(\String \times \NilStar) \cup
(\Nil \times \String \times \NilStar)$
\end{enumerate}

\subsection{String Manipulation}

\begin{enumerate}
\item string.byte (s [, i [, j]]) :
\begin{verbatim}
(string, number?, number?) -> (number*)
\end{verbatim}
Category 1.
\\
I guess the proper type should be:
\begin{verbatim}
(string) |
(string, number, number?) -> (number*)
\end{verbatim}
\item string.char (···) :
\begin{verbatim}
(number*) -> (string)
\end{verbatim}
Category 1.
\item string.dump (function) :
\begin{verbatim}
((value*) -> (value*)) -> (string)
\end{verbatim}
Category 3?
\item string.find (s, pattern [, init [, plain]]) :
\begin{verbatim}
(string, string, number?, true?) -> (number, number) | (nil)
\end{verbatim}
Category 1.
\\
I guess the proper type should be:
\begin{verbatim}
(string, string) |
(string, string, number, true?) -> (number, number) | (nil)
\end{verbatim}
\item string.format (formatstring, ···) :
\begin{verbatim}
(string, any*) -> (string)
\end{verbatim}
Category 1.
\item string.gmatch (s, pattern) :
\begin{verbatim}
(string, string) -> ((any*) -> (any*))
\end{verbatim}
Category 3.
\\
This function actually returns an iterator,
so I still need to confirm its return type.
\item string.gsub (s, pattern, repl [, n]) :
\begin{verbatim}
(string, string, string|{}|(any*) -> (any*), number?) ->
(string, number)
\end{verbatim}
Category 1.
\item string.len (s) :
\begin{verbatim}
(string) -> (number)
\end{verbatim}
Category 1.
\item string.lower (s) :
\begin{verbatim}
(string) -> (string)
\end{verbatim}
Category 1.
\item string.match (s, pattern [, init]) :
\begin{verbatim}
(string, string, number?) -> (string, string*) | (nil)
\end{verbatim}
Category 1.
\item string.rep (s, n [, sep]) :
\begin{verbatim}
(string, number, string?) -> (string)
\end{verbatim}
Category 1.
\item string.reverse (s) :
\begin{verbatim}
(string) -> (string)
\end{verbatim}
Category 1.
\item string.sub (s, i [, j]) :
\begin{verbatim}
(string, number, number?) -> (string)
\end{verbatim}
Category 1.
\item string.upper (s) :
\begin{verbatim}
(string) -> (string)
\end{verbatim}
Category 1.
\end{enumerate}

\subsection{Table Manipulation}

\begin{enumerate}
\item table.concat (list [, sep [, i [, j]]]) :
\begin{verbatim}
({string|number}, string?, number?, number?) -> (string)
\end{verbatim}
Category 1.
\\
I guess the proper type should be:
\begin{verbatim}
({string|number}) |
({string|number}, string) |
({string|number}, string, number?) -> (string)
\end{verbatim}
\item table.insert (list, [pos,] value) :
\begin{verbatim}
({any}, any) -> ()
\end{verbatim}
Category 2.
\\
This function does not accept/discard extra parameters.
Perhaps due to the fact that the parameter \textbf{pos} is optional.
If \textbf{value} is $\TopStar$, the function inserts \textbf{pos}
in the \textbf{list}, that is, the input type is
\texttt{(\{any\}, any) -> ()}.
If \textbf{value} is $\Nil$, the function does not insert \textbf{pos}
in the \textbf{list}, that is, the input type is
\texttt{(\{any\}, number, any) -> ()},
but the element is not inserted in the list because \textbf{value}
is actually $\Nil$.
I guess the proper type should be:
\begin{verbatim}
({any}, any) | ({any}, number, any) -> ()
\end{verbatim}
\item table.pack (···) :
\begin{verbatim}
(any*) -> ({number:any, "n":number})
\end{verbatim}
Category 2.
\\
Even though \textbf{table.pack} gets any number of parameters of
any type, the $\Nil$ type generates a hole in the returned table.
\item table.remove (list [, pos]) :
\begin{verbatim}
({any}, number?) -> (any)
\end{verbatim}
Category 2.
\\
The return type depends on the type of the element that is removed
from the list.
\item table.sort (list [, comp]) :
\begin{verbatim}
({any}, any?) -> ()
\end{verbatim}
Category 2.
\\
The proper type should be:
\begin{verbatim}
({any}, (any, any) -> (boolean)?) -> ()
\end{verbatim}
But there is a syntactic conflict for defining optional function types
that should be fixed in the parser.
\item table.unpack (list [, i [, j]]) :
\begin{verbatim}
({any}, number?, number?) -> (any*)
\end{verbatim}
Category 2.
\\
The return type depends on the type of the elements that are stored in
the list.
I guess the proper type should be:
\begin{verbatim}
({any}) | ({any}, number, number?) -> (any*)
\end{verbatim}
\end{enumerate}

\subsection{Mathematical Functions}

\begin{enumerate}
\item math.abs (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.acos (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.asin (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.atan (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.atan2 (y, x) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item math.ceil (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.cos (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.cosh (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.deg (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.exp (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.floor (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.fmod (x, y) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item math.frexp (x) :
\begin{verbatim}
(number) -> (number, number)
\end{verbatim}
Category 1.
\item math.huge :
\begin{verbatim}
number
\end{verbatim}
Category 1.
\item math.ldexp (m, e) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item math.log (x [, base]) :
\begin{verbatim}
(number, number?) -> (number)
\end{verbatim}
Category 1.
\item math.max (x, ···) :
\begin{verbatim}
(number, number*) -> (number)
\end{verbatim}
Category 1.
\item math.min (x, ···) :
\begin{verbatim}
(number, number*) -> (number)
\end{verbatim}
Category 1.
\item math.modf (x) :
\begin{verbatim}
(number) -> (number, number)
\end{verbatim}
Category 1.
\item math.pi :
\begin{verbatim}
number
\end{verbatim}
Category 1.
\item math.pow (x, y) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item math.rad (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.random ([m [, n]]) :
\begin{verbatim}
(number?, number?) -> (number)
\end{verbatim}
Category 1.
\\
This function does not accept $\Nil$ as its only parameter,
although the parameter passing is optional.
This function does not accept/discard extra parameters.
I guess the proper type should be:
\begin{verbatim}
() | (number, number?) -> (number)
\end{verbatim}
\item math.randomseed (x) :
\begin{verbatim}
(number) -> ()
\end{verbatim}
Category 1.
\item math.sin (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.sinh (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.sqrt (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.tan (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item math.tanh (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\end{enumerate}

\subsection{Bitwise Operations}

\begin{enumerate}
\item bit32.arshift (x, disp) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item bit32.band (···) :
\begin{verbatim}
(number*) -> (number)
\end{verbatim}
Category 1.
\item bit32.bnot (x) :
\begin{verbatim}
(number) -> (number)
\end{verbatim}
Category 1.
\item bit32.bor (···) :
\begin{verbatim}
(number*) -> (number)
\end{verbatim}
Category 1.
\item bit32.btest (···) :
\begin{verbatim}
(number*) -> (number)
\end{verbatim}
Category 1.
\item bit32.bxor (···) :
\begin{verbatim}
(number*) -> (number)
\end{verbatim}
Category 1.
\item bit32.extract (n, field [, width]) :
\begin{verbatim}
(number, number, number?) -> (number)
\end{verbatim}
Category 1.
\\
Should it be?
\begin{verbatim}
(number, 0|...|31, 1|...|32|nil) -> (number)
\end{verbatim}
\item bit32.replace (n, v, field [, width]) :
\begin{verbatim}
(number, number, number, number?) -> (number)
\end{verbatim}
Category 1.
\\
Should it be?
\begin{verbatim}
(number, number, 0|...|31, 1|...|32|nil) -> (number)
\end{verbatim}
\item bit32.lrotate (x, disp) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item bit32.lshift (x, disp) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item bit32.rrotate (x, disp) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\item bit32.rshift (x, disp) :
\begin{verbatim}
(number, number) -> (number)
\end{verbatim}
Category 1.
\end{enumerate}

\subsection{Input and Output facilities}

\begin{enumerate}
\item io.close ([file]) :
$(Userdata \cup \Nil) \times
\TopStar \rightarrow
(\Boolean \times \NilStar) \cup
(\Nil \times \String \times \NilStar) \cup
((\True \cup \Nil) \times \String \times \Number \times \NilStar)$
\\
Returns $((\True \cup \Nil) \times \String \times \Number \times \NilStar)$
when the file handle was created with \textbf{io.popen}.
\item io.flush () :
$\TopStar \rightarrow \Boolean \times \NilStar$
\item io.input ([file]) :
$(\String \cup Userdata \cup \Nil) \times
\TopStar \rightarrow
Userdata \times
\NilStar$
\item io.lines ([filename ···]) :
$(\String \cup Userdata \cup \Nil) \times
\TopStar \rightarrow
(\String \times \NilStar) \cup
(\Nil \times \NilStar)$
\\
In fact, this function returns an iterator. Need to check the return type.
\item io.open (filename [, mode]) :
$\String \times
(``r" \cup ``w" \cup ``a" \cup
``r+" \cup ``w+" \cup ``a+" \cup
``rb" \cup ``wb" \cup ``ab" \cup
``r+b" \cup ``w+b" \cup ``a+b" \cup
\Nil) \times
\TopStar \rightarrow
(Userdata \times \NilStar) \cup
(\Nil \times \String \times \Number \times \NilStar)$
\item io.output ([file]) :
$(\String \cup Userdata \cup \Nil) \times
\TopStar \rightarrow
Userdata \times
\NilStar$
\item io.popen (prog [, mode]) :
$\String \times
(``r" \cup ``w" \cup \Nil) \times
\TopStar \rightarrow
(Userdata \times \NilStar) \cup
(\Nil \times \String \times \Number \times \NilStar)$
\item io.read (···) :
$(``*n" \cup ``*a" \cup ``*l" \cup ``*L" \cup \Number){*} \rightarrow
(\String \cup \Number){*}
$
\item io.tmpfile () :
$\TopStar \rightarrow Userdata \times \NilStar$
\item io.type (obj) :
$\Top \times \TopStar \rightarrow (``file" \cup ``closed\;file" \cup \Nil) \times \NilStar$
\item io.write (···) :
$(\String \cup \Number){*} \rightarrow
(Userdata \times \NilStar) \cup
(\Nil \times \String \times \Number \times \NilStar)$
\item file:close () : ?
\item file:flush () : ?
\item file:lines (···) : ?
\item file:read (···) : ?
\item file:seek ([whence [, offset]]) : ?
\item file:setvbuf (mode [, size]) : ?
\item file:write (···) : ?
\end{enumerate}

\subsection{Operating System facilities}

\begin{enumerate}
\item os.clock () :
$\TopStar \rightarrow \Number \times \NilStar$
\item os.date ([format [, time]]) :
$(\String \cup \Nil) \times
(\Number \cup \Nil) \times
\TopStar \rightarrow
(\String \times \NilStar) \cup
(\{``year":\Number,\;
   ``month":\Number,\;
   ``day":\Number,\;
   ``hour":\Number,\;
   ``min":\Number,\;
   ``sec":\Number,\;
   ``wday":\Number,\;
   ``yday":\Number,\;
   ``isdst":\Boolean \} \times \NilStar)$
\\
Returns a table when \textbf{format} contains ``\textbf{*t}''.
\item os.difftime (t2, t1) :
$\Number \times
(\Number \cup \Nil) \times
\TopStar \rightarrow
\Number \times
\NilStar$
\\
Returns \textbf{t2} when \textbf{t1} is $\Nil$.
\item os.execute ([command]) :
$(\String \cup \Nil) \times
\TopStar \rightarrow
(\Boolean \times \NilStar) \cup
((\True \cup \Nil) \times \String \times \Number \times \NilStar)$
\\
Returns just a Boolean when \textbf{command} is $\Nil$.
This Boolean means whether there is a shell available.
Returns $\True \times \String \times \Number \times \NilStar$ when
\textbf{command} terminated successfully.
Returns $\Nil \times \String \times \Number \times \NilStar$ when
\textbf{command} did not terminate sucessfully.
\item os.exit ([code [, close]]) :
$(\Number \cup \Boolean \cup \Nil) \times
\Top \times
\TopStar \rightarrow
\NilStar$
\item os.getenv (varname) :
$\String \times
\TopStar \rightarrow
(\String \times \NilStar) \cup
(\Nil \times \NilStar)$
\item os.remove (filename) :
$\String \times
\TopStar \rightarrow
(\True \times \NilStar) \cup
(\Nil \times \String \times \Number \NilStar)$
\item os.rename (oldname, newname) :
$\String \times
\String \times
\TopStar \rightarrow
(\True \times \NilStar) \cup
(\Nil \times \String \times \Number \NilStar)$
\item os.setlocale (locale [, category]) :
$(\String \cup \Nil) \times
(``all" \cup
``collate" \cup
``ctype" \cup
``monetary" \cup
``numeric" \cup
``time" \cup
\Nil) \times
\TopStar \rightarrow
(\String \times \NilStar) \cup
(\Nil \times \NilStar)$
\item os.time ([table]) :
$(\{``year":\Number,\;
   ``month":\Number,\;
   ``day":\Number,\;
   ``hour":(\Number \cup \Nil),\;
   ``min":(\Number \cup \Nil),\;
   ``sec":(\Number \cup \Nil),\;
   ``wday":(\Number \cup \Nil),\;
   ``yday":(\Number \cup \Nil),\;
   ``isdst":(\Boolean \cup \Nil) \} \cup \Nil) \times
\TopStar \rightarrow
\Number \times
\NilStar$
\item os.tmpname () :
$\TopStar \rightarrow \String \times \NilStar$
\end{enumerate}

\subsection{The debug library}

\begin{enumerate}
\item debug.debug () : ?
\item debug.gethook ([thread]) : ?
\item debug.getinfo ([thread,] f [, what]) : ?
\item debug.getlocal ([thread,] f, local) : ?
\item debug.getmetatable (value) : ?
\item debug.getregistry () : ?
\item debug.getupvalue (f, up) : ?
\item debug.getuservalue (u) : ?
\item debug.sethook ([thread,] hook, mask [, count]) : ?
\item debug.setlocal ([thread,] level, local, value) : ?
\item debug.setmetatable (value, table) : ?
\item debug.setupvalue (f, up, value) : ?
\item debug.setuservalue (udata, value) : ?
\item debug.traceback ([thread,] [message [, level]]) : ?
\item debug.upvalueid (f, n) : ?
\item debug.upvaluejoin (f1, n1, f2, n2) : ?
\end{enumerate}
