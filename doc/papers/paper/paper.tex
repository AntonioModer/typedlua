\documentclass[preprint]{sigplanconf}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{url}
\usepackage{color}
\usepackage{multirow}

\newcommand{\Value}{\mathbf{value}}
\newcommand{\Any}{\mathbf{any}}
\newcommand{\Nil}{\mathbf{nil}}
\newcommand{\Self}{\mathbf{self}}
\newcommand{\False}{\mathbf{false}}
\newcommand{\True}{\mathbf{true}}
\newcommand{\Boolean}{\mathbf{boolean}}
\newcommand{\Integer}{\mathbf{integer}}
\newcommand{\Number}{\mathbf{number}}
\newcommand{\String}{\mathbf{string}}
\newcommand{\Void}{\Nil{*}}
\newcommand{\Const}{\mathbf{const}}

\newcommand{\mylabel}[1]{\; (\textsc{#1})}
\newcommand{\env}{\Gamma}
\newcommand{\penv}{\Pi}
\newcommand{\senv}{\Sigma}
\newcommand{\subtype}{<:}
\newcommand{\ret}{\rho}
\newcommand{\self}{\sigma}

\def\dstart{\hbox to \hsize{\vrule depth 4pt\hrulefill\vrule depth 4pt}}
\def\dend{\hbox to \hsize{\vrule height 4pt\hrulefill\vrule height 4pt}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{DLS '15}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\doi{nnnnnnn.nnnnnnn}

\titlebanner{Draft}
\preprintfooter{A Formalization of Typed Lua}

\title{A Formalization of Typed Lua}

\authorinfo{AndrÃ© Murbach Maidl}
           {PUC-Rio}
           {amaidl@inf.puc-rio.br}
\authorinfo{Fabio Mascarenhas}
           {UFRJ}
           {fabiom@dcc.ufrj.br}
\authorinfo{Roberto Ierusalimschy}
           {PUC-Rio}
           {roberto@inf.puc-rio.br}

\maketitle

\begin{abstract}
Programmers often migrate from a dynamically typed
to a statically typed language when their simple scripts
evolve into complex programs. Optional type systems are
one way of having both static and dynamic typing
in the same language, while keeping its dynamically typed
semantics. This makes evolving a program from dynamic to
static typing a matter of describing the implied types that
it it using and adding annotations to make those types explicit.
Designing an optional type system for
an existing dynamically typed language is challenging, as its types should feel natural to programmers that are already familiar with
this language.

In this work, we give a formal description of Typed Lua, an
optional type system for Lua, with a focus on two of its novel type system features: incremental evolution of record and object types via imperative update that does not sacrifice width subtyping, and combining flow typing with multiple assignment and with functions that return multiple values. While our type system is tailored to the features and idioms of Lua, its features can be adapted to other imperative scripting languages.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}
\label{sec:intro}

Dynamically typed languages forgo static type checking
in favor of using run-time {\em type tags} to classify
the values they compute, so its operations can use these
tags to perform run-time (or dynamic) checks and signal
errors in case of invalid operands~\cite{pierce2002tpl}.
The lack of static types allows programmers to write code
that might have required a complex type system to statically
type, at the cost of hiding defects that will only be caught
after deployment if the programmers do not properly
test their code.

In contrast, statically typed languages help programmers
detect defects during development, and also provide
a conceptual framework that helps programmers define modules
and interfaces that can be combined to structure the development
of large programs.

The early error detection and better tools for structuring
programs are two advantages of statically typed languages that
lead programmers to migrate their code from a dynamically
typed to a statically typed language when their scripts
evolve into complex programs~\cite{tobin-hochstadt2006ims}.
This migration from dynamic to static typing usually involves
different languages that have distinct syntax and semantics,
requiring a complexe rewrite of existing programs instead of
incremental evolution.

Ideally, programming languages should offer programmers the
option to choose between static and dynamic typing.
\emph{Optional type systems}~\cite{bracha2004pluggable} and
\emph{gradual typing}~\cite{siek2006gradual} are two 
approaches for blending static and dynamic typing in the same
language. Their aim is to offer programmers the option
of adding type annotations where static typing is needed,
allowing the incremental migration from dynamic to static
typing. The difference between these two approaches is the
way they treat the runtime semantics of the language:
optional type systems preserve the original semantics
of a dynamically typed language, at the cost of runtime
safety, while gradual typing changes the semantics to
include more extensive runtime checking. These extra checks
ensure that
dynamically typed portions of the program do not violate
the type safety of statically typed portions.

A key feature in optional type systems is usability.
Optional type systems retrofitted to an existing
language should fit the language's idioms, adding
static type safety to them. If the system is too
simple it may require too much of a change in the way
programmers use the language. On the other hand,
if it is too complex it may overload the programmers
with types and error messages that are hard to
understand. The most challenging aspect of designing optional type systems is to find the right amount of complexity for a type system that feels natural to the programmers.

Lua is a small imperative language with lexically-scoped first-class functions where the only data structuring
mechanism is the \emph{table}, an associative array. Lua prefers to provide mechanisms instead of fixed policies due
to its primary use as an embedded language for configuration and
extension of other applications.
This means that even features such as a module system and
object orientation are a matter of convention on how
programs use the syntactic sugar and metaprogramming
facilities of tables, instead of
built-in language constructs. Tables can efficiently represent arrays, records, maps, modules,
objects, etc. 

The result is a fragmented ecosystem of libraries, and different
ideas among Lua programmers on how they should use the language
features or on how they should structure programs. One example
of this fragmentation is the proliferation of object systems.

Typed Lua~\cite{maidl2014tl} is an optional type system for
Lua that is rich enough to preserve some of the idioms
that Lua programmers are already familiar with, while
helping programmers structure large Lua programs and
catch errors at compile-time. 

In this paper, we give a formal basis to an updated version of Typed Lua's original design, with a focus on two novel type system
features that Typed Lua uses to type some tricky Lua idioms.
The lack of standard policies is a challenge for the design of
an optional type system for Lua. For this reason, the design
of Typed Lua has been informed by a mostly automated survey
of Lua idioms used by a large corpus of Lua libraries.
This paper also presents the methodology of this survey and
a summary of its results.

The first idioms that we focus on this paper is the use of assignment to build records and objects one field at a time, as in
the Lua fragment in Figure~\ref{fig:newpoint}, where the {\tt newpoint} function
is a constructor for objects with {\tt x} and {\tt y}
fields and a {\tt move} method.

\begin{figure}[t]
\label{fig:newpoint}
\begin{verbatim}
  function new_point(x, y)
    local point = {}
    point.x = x
    point.y = y
    function point:move(dx, dy)
      self.x = self.x + dx
      self.y = self.y + dy
      return self
    end
    return point
  end
\end{verbatim}
\caption{Building an object piece-by-piece}
\end{figure}

The {\tt newpoint} function builds the object piece-by-piece,
from an initially empty table. Typed Lua
lets record and object types evolve incrementally 
via assignment while not sacrificing width subtyping.

The other idiom that we focus on combines overloading on the return values of a function, multiple return values, multiple assignment
to decompose multiple return values,
and tag checks to discriminate several returned values
by checking just one of them. The Lua fragment in Figure~\ref{fig:over} shows a function with overloaded multiple
returns, and how a caller of this function can discriminate
which list of multiple values the function returned.

\begin{figure}[t]
\label{fig:over}
\begin{verbatim}
  function idiv(x, y)
    if y == 0 then
      return nil, "division by zero"
    else
      return x // y, x % y
    end 
  end
  
  local q, r = idiv(a, b)
  if q then
    assert(a == q*b + r)
  else
    error(r)
  end
\end{verbatim}
\caption{Overloading on multiple returns}
\end{figure}

In the {\bf then} branch it is guaranteed that both {\tt q}
and {\tt r} are integers, and in the {\bf else} branch it is
guaranteed that {\tt q} is {\tt nil} and {\tt r} is a string.
In Typed Lua, the return type of {\tt idiv} can be a union of
tuples describing the possible return values. Typed Lua deconstructs unions of tuples in a way that the dependencies between the types of each value in the tuple can be tracked.

The remainder of the paper is organized as follows:
Section \ref{sec:statistics} presents the methodology and results of
our survey of Lua idioms;
Section \ref{sec:types} presents the types of Typed Lua's
type system; Section~\ref{sec:subtyping} presents
their subtyping and consistent-subtyping relations;
Section \ref{sec:rules} presents the typing rules
for the two idioms that we focus on this paper;
Section \ref{sec:related} reviews related work;
Section \ref{sec:conclusion} presents our conclusions,
and outlines plans for future work.

\section{A Survey of Lua Idioms}
\label{sec:statistics}

In order to find out how Lua is used in practice, to inform
the design of Typed Lua, we did a survey of existing Lua
libraries. Our corpus is the repository for the LuaRocks
package manager~\cite{hisham2013luarocks}, downloaded on
February 1st, 2014. We did not survey all of the Lua
scripts in the repository: scripts that were not compatible
with Lua 5.2 (the version of Lua at that time) were ignored,
and we also ignored machine-generated scripts and test scripts,
as those could skew the result towards non-idiomatic uses
of Lua. This left 2,598 scripts out of a total of 3,928, from
262 different projects. The scripts were parsed, and their
abstract syntax trees analysed to collect the data that we
show in the rest of this section.

Tables are the core data structure of Lua programs, and
the language has features that let tables be used as
tuples, lists, maps, records, abstract data types, classes,
objects, modules, etc. We performed several analyses to
quantify the different ways that Lua programs use tables.

Our first analysis surveyed table constructors (expressions
that create and initialize a table) to find out how a table
begins its life. Of all of the 23,185 table constructors of
our corpus, 36\% of them create a record (a table with string
keys such as \texttt{\{x = 1, y = 2\}}), 29\% of them create
a list or a tuple (a table with consecutive integer keys such as \texttt{\{"one", "two", "three", "four"\}}), 26\% of them create an empty table, and 8\% of them create a table with
both a record part and a list part. The remaining 1\% of them create a table with non-literal keys.

We also analysed expressions that access a table (130,448 instances), either to read a value out of it (86\% of such expressions) or to write a 
value into it (14\% of such expressions). Most of the expressions
that read a value out of a table use a literal key,
either a literal string (89\% of the reads) or a literal
number (4\% of the reads). Lua has syntactic sugar that
turns field accesses using ``dot'' notation into table
accesses through literal string keys.

In 45\% of the expressions that read a value out of a table,
its value is immediately called. These calls are split almost
evenly between function calls and method calls (25\% of reads
are function calls, 20\% of reads are method calls).
These results show that the use of tables as a namespacing
mechanism for modules, as objects, and as records, 
is prevalent.

Expressions that write into a table also mostly use
literal keys (69\% of them use a literal string, 2\%
of them use a literal number), although a large 29\%
of writes use non-literal keys, in contrast to only 7\% of
reads.

In order to gauge how frequently tables are used as
collections, we looked for the presence of code that
iterates over tables, and found out that 23\% of the
scripts in our corpus iterate over a map at least once,
and 27\% of the scripts iterate over a list at least once.

Besides measuring the number of method calls, we also
measured other kinds of expressions and statements to gauge
how frequently Lua programmers use the object-oriented paradigm.
Our corpus has 24,858 function declarations, and 23\% of these
are method declarations. Of the 262 projects in our corpus,
63\% use {\em metatables}, a metaprogramming mechanism that
lets the program extend the behavior of tables and is mostly
used for implementing prototype-based inheritance.

Typed Lua's table types, described in the next section,
reflect the way Lua programmers use Lua tables in practice,
according to the results above. A table type can express
records, tuples, maps, lists, objects, or a combination of
those.

Lua modules are tables containing the modules' exports.
The current idiomatic way to define a module is to populate
an initially empty table with the members the module wishes
to export, and return this table at the end of the script
that defines the module. Around two-thirds of the modules
in our corpus use this idiom. The other third uses a
deprecated idiom, where a call to the {\tt module} function
at the top of the script installs a new global environment,
and the exported members are global variables assigned to
in the rest of the module.

The global environment is a also a table, so the two idioms
are equivalent in terms of how Typed Lua deals with module
definitions. Modules in Typed Lua make extensive use of Typed
Lua's rules for evolution of table types
(Section~\ref{sec:tables}).

In order to gauge how common is the use of dynamic type
checking as a way to define overloaded functions, we
measured how many of the functions inspect the
tags of their input parameters, and found out that 9\%
of the functions in our corpus do this, split evenly
between using the tag in an assertion, as a form of
type checking, and using the tag to decide which code
to execute, as a form of overloading. While Typed Lua
supports both union types and flow typing, general
support for overloaded functions still has to improve.

A Lua idiom that is specially problematic for static type
systems is overloading on the number and types and
multiple return values. Around 6\% of functions use
this idiom as a way to signal errors: in case of errors,
the function returns either {\tt nil} or {\tt false} plus
either an error message or error object instead of its usual
return values or throwing an exception. The caller then
tests the first returned value to check if an error occured
or not. Standard union types and flow typing cannot deal
with this, and Typed Lua introduces {\em projection types},
a way of tracking dependencies between types in a union of
tuples after a destructuring assignment.

\section{Types}
\label{sec:types}

\begin{figure*}[t]
$$
\begin{array}{rlr}
T ::= & & \textsc{first-level types:}\\
& \;\; F & \textit{first-class types}\\
& | \; \phi(F_{1},F_{2}) & \textit{filter types}\\
& | \; \pi_{i}^{x} & \textit{projection types}\\
F ::= & & \textsc{{\small first-class types:}}\\
& \;\; L & \textit{literal types}\\
& | \; B & \textit{base types}\\
& | \; \mathbf{void} & \textit{void type}\\
& | \; \Nil & \textit{nil type}\\
& | \; \Value & \textit{top type}\\
& | \; \Any & \textit{dynamic type}\\
& | \; \Self & \textit{self type}\\
& | \; F_{1} \cup F_{2} & \textit{union types}\\
& | \; S_{1} \rightarrow S_{2} & \textit{function types}\\
& | \; \{K_{1}{:}V_{1}, ..., K_{n}{:}V_{n}\}_{unique|open|fixed|closed} & \textit{table types}\\
& | \; x & \textit{type variables}\\
& | \; \mu x.F & \textit{recursive types}\\
%\multicolumn{3}{c}{}\\
L ::= & & \textsc{{\small literal types:}}\\
& \;\; \False \; | \; \True \; | \; {\it int} \; | \; {\it float} \; | \; {\it string} &\\
%\multicolumn{3}{c}{}\\
B ::= & & \textsc{{\small base types:}}\\
& \;\; \Boolean \; | \; \Integer \; | \; \Number \; | \; \String &\\
%\multicolumn{3}{c}{}\\
K ::= & & \textsc{{\small key types:}}\\
& \;\; L \; | \; B \; | \; \Value &\\
%\multicolumn{3}{c}{}\\
V ::= & & \textsc{{\small value types:}}\\
& \;\; F \; | \; \Const \; F &\\ 
%\multicolumn{3}{c}{}\\
S ::= & & \textsc{second-level types:}\\
& \;\; P & \textit{tuple types}\\
& | \; S_{1} \sqcup S_{2} & \textit{unions of tuple types}\\
%\multicolumn{3}{c}{}\\
P ::= & & \textsc{{\small tuple types:}}\\
%& \;\; \Void & \textit{void type}\\
& | \; F{*} & \textit{variadic types}\\
& | \; T \times P & \textit{pair types}
\end{array}
$$
\caption{Type Language}
\label{fig:typelang}
\end{figure*}

Figure \ref{fig:typelang} presents the abstract syntax of
Typed Lua types. They are split into two categories:
\emph{first-level types} and \emph{second-level types}.
First-level types represent first-class Lua values and
second-level types represent tuples of values that appear in 
assignments and function applications. 

First-level types are
themselves split into {\em first-class types}, which can be
used in type annotations and most type constructors, and
{\em filter types} and {\em projection types}, special
types that only appear in support of flow typing.
Typed Lua includes projection types as a way to project
unions of tuple types into unions of first-level types,
and we detailt their use in Section~\ref{sec:projections} .

Types are ordered by a subtype relationship, so Lua values may belong to several distinct types. The details of the subtyping
relationship are given later in this section.

Literal types represent the type of literal boolean, number
and string values. Their main application is the formation in record and tuple types.

The base types represent values that Lua tags as booleans,
strings, or numbers during runtime. Prior to version Lua 5.3 all Lua numbers were double-precision floating point numbers.
Lua 5.3 introduced the possiblity of having 64-bit integers
as numbers, with automatic promotion of integer values to
floating-point representation as needed. As automatic
promotion makes integers essentialy subtypes of floating-point numbers, Typed Lua uses $\Number$ as the type of floating-point numbers, and $\Integer$ as the type of integers.

The type {\bf void} is a type with no values, used by the
type system as a way to detect branches that are unreacheable
due to flow typing. This type is neutral with regards to
the type union operator: ${\bf void} \cup T = T \cup {\bf void} = T$ for any type $T$.

The type $\Nil$ is the type of {\tt nil}, the value that Lua uses for undefined variables, missing parameters, and missing table keys.
Many programming languages include a bottom type to represent
an empty value that programmers can use as a default expression.
We could have used the type $\Nil$ for this role, but
this would lead to reduced static type safety. Typed Lua's
type system does not have a bottom type.

The type $\Value$ is the top type, which represents any Lua value.
Its main purpose is to be able to easily express function types
that silently ignore extra arguments, as well as easily ignoring extra r-values in multiple assignment, preserving the semantics of Lua for these operations, as they do not sacrifice type safety.

The type $\Self$ is the receiver in object-oriented method
definitions and method calls, and lets Typed Lua have objects
as regular table types with methods as regular function types
with an explicit receiver parameter.

Table types represent some of the forms that Lua
tables can take. What a particular table type denotes
depends on its {\em tag}: the {\em unique}, {\em open}
and {\em fixed} tags all denote tables where it is
guaranteed that every key belongs to one of the {\em key
types} $K_i$. We restrict key types to literal types,
base types, and the top type to make the system simpler
for the user, as our survey of Lua programs showed that
this restriction reflects the way Lua tables are commonly used.

Fields are assignable by default, but can be marked
as non-assignable with the {\bf const} qualifier. Having
a field be {\bf const} is not a guarantee that its
value cannot change, as the table may have aliases with
a non-{\bf const} type for that field. Non-assignable
fields enable {\em depth subtyping} between table types.

The difference between {\em unique}, {\em open} and
{\em fixed} tables is the guarantees that the type system
gives about the reference to a value of that type. A reference
to an {\em unique} table is guaranteed to have no aliases,
so it allows greater flexibility in reinterpreting its type;
a reference to an {\em open} table is guaranteed to have
only {\em closed} aliases (we will explain the meaning of the {\em closed} tag shortly), which still lets the type system
reinterpret the type of a reference, but with more
restrictions; a {\em fixed} table can have any number of {\em fixed} or {\em closed} aliases, so its type cannot change
anymore.

Table types with the {\em fixed} tag are suitable for typing tables that are used as maps, lists, or even a mixture of those. The guarantee that there are no keys with a type that is not
one of the key types allows type-safe iteration on these
tables.

This guarantee forbids width subtyping, which is a necessity
for object-oriented programming, so we have the {\em closed}
tag, which removes the guarantee and allows width subtyping
between other table types and {\em closed} table types. A {\em closed} table type is akin to an object-oriented {\em interface}.

Any table type has to be \emph{well-formed}.
Informally, a table type is well-formed if key types do not overlap. A formal definition of this relation depends on
the consistent-subtyping relation which we present in the
next section, so we delay the definition until Section~\ref{sec:tables}, where the typing rules for
table types are explained.

The type $\Any$ is the dynamic type, and allows
interaction between statically and dynamically typed
portions of a program. It is neither a top nor a bottom
type, although it can work as either, as a value of
any type can be coerced to $\Any$ and vice-versa.
Gradual type systems augment these coercions with
information that can be used to blame the dynamically
typed of the program for type errors that may occur in the
statically typed part. Currently Typed Lua only 
warns the programmer that coercions to and from $\Any$
may be unsafe.

Second-level types are either tuple types or unions of tuple types, and represent sequences of values that appear as arguments, return values, and the left and right sides of
assignments. Tuple types are heterogeneous lists of first-class
types that end with a {\em variadic type}.
A variadic type $F{*}$ represents an unbounded sequence of values of type $F \cup \Nil$. Lua pads sequences with {\tt nil} to
have as many values as needed, and in Typed Lua sequences
where the number of values is statically known have a $\Nil{*}$
tail to reflect this semantics.

For clarity, we use the symbol $\sqcup$ to represent the union between two different tuple types, and reserve $\cup$ for the
union of two first-class types.

\section{Subtyping and Consistent-Subtyping}
\label{sec:subtyping}

Typed Lua's type system uses subtyping to order
types and  consistent-subtyping~\cite{siek2007objects,siek2013mutable}
to model compatibility between types in a way that allows
the interaction between statically and dynamically typed
parts of the program without collapsing the subtyping
relation.

The consistent-subtyping relation is defined in terms
of subtyping, so we focus the discussion in this section
on characterising the subtyping relation.

The subtyping rules are a deduction system for the
subtyping relation $\senv \vdash t_{1} \subtype t_{2}$.
The variable $\senv$ is a set of subtyping assumptions used
by the subtyping relation between recursive types. 
Most of the subtyping rules are standard, so we will
focus on the interesting cases.

\begin{figure}[t]
\label{fig:subtuples}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-Pair}\\
\dfrac{\senv \vdash F_{1} \subtype F_{2} \;\;\;
	\senv \vdash P_{1} \subtype P_{2}}
{\senv \vdash F_{1} \times P_{1} \subtype F_{2} \times P_{2}}
\end{array}
\begin{array}{c}
\mylabel{S-Variadic}\\
\dfrac{\senv \vdash F_{1} \cup \Nil \subtype F_{2} \cup \Nil}
{\senv \vdash F_{1}{*} \subtype F_{2}{*}}
\end{array}\\\\
\begin{array}{c}
\mylabel{S-VarExpand}\\
\dfrac{\senv \vdash F_{1} \cup \Nil \subtype F_{2} \;\;\;
	\senv \vdash F_{1}{*} \subtype P_{2}}
{\senv \vdash F_{1}{*} \subtype F_{2} \times P_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-VarDrop}\\
\dfrac{\senv \vdash F_{1} \subtype F_{2} \cup \Nil \;\;\;
	\senv \vdash P_{1} \subtype F_{2}{*}}
{\senv \vdash F_{1} \times P_{1} \subtype F_{2}{*}}
\end{array}
\end{array}
\]
\caption{Subtyping for second-level types}	
\end{figure}

Figure~\ref{fig:subtuples} shows the subtyping rules for
second-level types. 
Tuple types are covariant, so the subtyping rule {\sc S-Pair} for pair types  is straightforward.

The semantics of Lua lets the right-hand side of an assignment
produce more values than l-values in the left-hand side,
with extra values silently dropped. It also lets the
right-hand side produce fewer values than l-values in the
left-hand side, using {\tt nil} to plug the holes. The
same behavior applies for lists of arguments vs. parameters.

Typed Lua preserves this behavior in assignment by synthesizing
tuple types that have a $\Value{*}$ tail for the left side
of an assignment. Non-variadic functions have a stricter
behavior: their parameter lists have a $\Nil{*}$ tail, so
a function can be passed any number of extra arguments
as long as they are literal {\tt nil}, but the type system will
reject extra arguments of any other type. Missing arguments
are also fine if the corresponding parameters have {\tt nil}
as a subtype: this is the Lua idiom for optional parameters.

Functions that want to keep the Lua behavior of just ignoring
any extra arguments can be variadic with type $\Value{*}$ as
the tail of their parameter tuple.

The remaining subtyping rules for second-level types
reflect this semantics. Rule {\sc S-Variadic} states
that variadic types are covariant (just having $F_1{*} \subtype F_2{*}$ iff $F_1 \subtype F_2$ would be too restrictive,
as $\Nil{*}$ would not be a subtype of $\Number{*}$).
Rules {\sc S-VarExpand} and {\sc S-VarDrop} state the
conditions when variadic tuples of different length are
compatible.

We could have the axioms $\senv \vdash F{*} \subtype F \cup \Nil \times F{*}$ and $\senv \vdash F \cup \Nil \times F{*}  \subtype F{*}$ instead of the two rules above, which can be derived
from these axioms by transitivity, but having the rules makes
the subtyping relation easier to implement.

\begin{figure}[t]
\label{fig:subtable}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-TableFCtoC}\\
\dfrac{\begin{array}{c}
	\forall i \in 1..n \; \exists j \in 1..m \\
	\senv \vdash K_{j} \subtype K_{i}' \;\;\;
	\senv \vdash K_{i}' \subtype K_{j} \;\;\;
	\senv \vdash V_{j} \subtype_{c} V_{i}'
	\end{array}}
{\begin{array}{c}
	\senv \vdash \{K_{1}{:}V_{1}, ..., K_{m}{:}V_{m}\}_{fixed|closed} \subtype\\
	\{K_{1}'{:}V_{1}', ..., K_{n}'{:}V_{n}'\}_{closed}
	\end{array}} \; m \ge n
\end{array}\\\\
\begin{array}{c}
\mylabel{S-TableUtoC}\\
\dfrac{\begin{array}{c}
	\forall i \in 1..m \; \forall j \in 1..n \;
	\senv \vdash K_{i} \subtype K_{j}' \to \senv \vdash V_{i} \subtype_{u} V_{j}' \\
	\forall j \in 1..n \; \not\exists i \in 1..m \;
	\senv \vdash K_{i} \subtype K_{j}' \to \senv \vdash \Nil \subtype_{o} V_{j}'
	\end{array}}
{\senv \vdash \{K_{1}{:}V_{1}, ..., K_{m}{:}V_{m}\}_{unique} \subtype
	\{K_{1}'{:}V_{1}', ..., K_{n}'{:}V_{n}'\}_{closed}}
\end{array}\\\\
\begin{array}{c}
\mylabel{S-TableOtoC}\\
\dfrac{\begin{array}{c}
	\forall i \in 1..m \; \forall j \in 1..n \;
	\senv \vdash K_{i} \subtype K_{j}' \to \senv \vdash V_{i} \subtype_{c} V_{j}' \\
	\forall j \in 1..n \; \not\exists i \in 1..m \;
	\senv \vdash K_{i} \subtype K_{j}' \to \senv \vdash \Nil \subtype_{o} V_{j}'
	\end{array}}
{\senv \vdash \{K_{1}{:}V_{1}, ..., K_{m}{:}V_{m}\}_{open} \subtype
	\{K_{1}'{:}V_{1}', ..., K_{n}'{:}V_{n}'\}_{closed}}
\end{array}\\\\
\begin{array}{c}
\mylabel{S-TableUtoUOF}\\
\dfrac{\begin{array}{c}
	\forall i \in 1..m \\
	\exists j \in 1..n \;
	\senv \vdash K_{i} \subtype K_{j}' \land \senv \vdash V_{i} \subtype_{u} V_{j}' \\
	\forall j \in 1..n \; \not\exists i \in 1..m \;
	\senv \vdash K_{i} \subtype K_{j}' \to \senv \vdash \Nil \subtype_{o} V_{j}'
	\end{array}}
{\begin{array}{c}
	\senv \vdash \{K_{1}{:}V_{1}, ..., K_{m}{:}V_{m}\}_{unique} \subtype\\
	\{K_{1}'{:}V_{1}', ..., K_{n}'{:}V_{n}'\}_{unique|open|fixed}
	\end{array}}
\end{array}\\\\
\begin{array}{c}
\mylabel{S-TableOtoOF}\\
\dfrac{\begin{array}{c}
	\forall i \in 1..m \\
	\exists j \in 1..n \;
	\senv \vdash K_{i} \subtype K_{j}' \land \senv \vdash V_{i} \subtype_{c} V_{j}' \\
	\forall j \in 1..n \; \not\exists i \in 1..m \;
	\senv \vdash K_{i} \subtype K_{j}' \to \senv \vdash \Nil \subtype_{o} V_{j}'
	\end{array}}
{\begin{array}{c}
	\senv \vdash \{K_{1}{:}V_{1}, ..., K_{m}{:}V_{m}\}_{open} \subtype\\
	\{K_{1}'{:}V_{1}', ..., K_{n}'{:}V_{n}'\}_{open|fixed}
	\end{array}}
\end{array}\\\\
\begin{array}{c}
\mylabel{S-TableFtoF}\\
\dfrac{\begin{array}{c}
	\forall i \in 1..n \; \exists j \in 1..n \\
	\senv \vdash K_{j} \subtype K_{i}' \;\;\;
	\senv \vdash K_{i}' \subtype K_{j} \;\;\;
	\senv \vdash V_{j} \subtype_{c} V_{i}'
	\end{array}}
{\senv \vdash \{K_{1}{:}V_{1}, ..., K_{n}{:}V_{n}\}_{fixed} \subtype
	\{K_{1}'{:}V_{1}', ..., K_{n}'{:}V_{n}'\}_{fixed}}
\end{array}
\end{array}
\]
\caption{Subtyping for table types}
\end{figure}

\begin{figure}[t]
\label{fig:subfield}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-FieldClsMtoM}\\
\dfrac{\senv \vdash V_{1} \subtype V_{2} \;\;\;
	\senv \vdash V_{2} \subtype V_{1}}
{\senv \vdash V_{1} \subtype_{c} V_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FieldClsItoI}\\
\dfrac{\senv \vdash V_{1} \subtype V_{2}}
{\senv \vdash \Const \; V_{1} \subtype_{c} \Const \; V_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FieldClsMtoI}\\
\dfrac{\senv \vdash V_{1} \subtype V_{2}}
{\senv \vdash V_{1} \subtype_{c} \Const \; V_{2}}
\end{array}\\\\
\begin{array}{c}
\mylabel{S-FieldUnqMtoM}\\
\dfrac{\senv \vdash V_{1} \subtype V_{2}}
{\senv \vdash V_{1} \subtype_{u} V_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FieldUnqItoM}\\
\dfrac{\senv \vdash V_{1} \subtype V_{2}}
{\senv \vdash \Const \; V_{1} \subtype_{u} V_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FieldUnqItoI}\\
\dfrac{\senv \vdash V_{1} \subtype V_{2}}
{\senv \vdash \Const \; V_{1} \subtype_{u} \Const \; V_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FieldUnqMtoI}\\
\dfrac{\senv \vdash V_{1} \subtype V_{2}}
{\senv \vdash V_{1} \subtype_{u} \Const \; V_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{S-FieldOpnNtoM}\\
\dfrac{\senv \vdash \Nil \subtype V}
{\senv \vdash \Nil \subtype_{o} V}
\end{array}
\;
\begin{array}{c}
\mylabel{S-FieldOpnNtoI}\\
\dfrac{\senv \vdash \Nil \subtype V}
{\senv \vdash \Nil \subtype_{o} \Const \; V}
\end{array}
\end{array}
\]
\caption{Subtyping for fields}
\end{figure}

Figure~\ref{fig:subtable} shows the subtyping rules for
table types. These rules use the auxiliary relations
$\subtype_{c}$, $\subtype_{u}$, and $\subtype_{o}$
shown in Figure~\ref{fig:subfield} to handle depth
subtyping where applicable.

Rule {\sc S-TableFCtoC} for subtyping
between a {\em fixed} or {\em closed}
table type and a {\em closed} table type resembles the
standard subtyping rule between mutable records, with
width subtyping plus depth subtyping from a mutable
or immutable field to an immutable field.

Rule {\sc S-TableUtoC} for subtyping between {\em unique} and {\em closed} table types is more permissive, as the typing rules of Section~\ref{sec:tables} guarantee that a {\em unique}
table type can only appear on the left side of a subtyping
judgment if the reference to the table with the {\em unique}
tag is being destroyed. This rule allows with subtyping, depth subtyping on any field, not only immutable fields, as well as the addition of new fields and the merging of existing fields, as long as the types of the values of new and merged fields include $\Nil$. 

The rationale for the permissiveness of rule {\sc S-TableUtoC} derives from the fact that reading a non-existing key just yields $\Nil$ instead of being an error in Lua semantics, plus the fact
that the type system guarantees that a table with a
{\em unique} type has no keys with a value that does not
belong to one of its key types, and does not have any
aliases. With these guarantess, a table with type $\{1{:}\String, 2{:}\String,
``x"{:}\Integer, ``y"{:}\Value\}_{unique}$ can be safely recast as a table with type 
$\{\Number{:}\String \cup \Nil, ``x"{:}\Number, ``z"{:}
\Number \cup \Nil\}_{closed}$ as long as it becomes
inaccessible with the original type, which Section~\ref{sec:tables} will show that is the case
for any type judgement where this subtyping rule is used.

Rule {\sc S-TableOtoC} for subtyping from an {\em open} table type to a {\em closed} table type also allows width subtyping, merging fields, and adding new fields, but forbids depth subtyping between mutable fields or an immutable and a mutable field, as the typing rules guarantee that the {\em open} reference
is destroyed, but the {\em open} table may already have {\em closed} aliases.

Rule {\sc S-TableUtoUOF} for subtyping from {\em unique} to {\em unique}, {\em open} or {\em fixed} table types is still permissive, but forbids standard width subtyping, as all these table types keep the guarantee that the values of all keys in tables of these types belong to one of their key types. Merging fields and adding new fields are still allowed.

Rule {\sc S-TableOtoOF} for subtyping from {\em open} to {\em open} or {\em fixed} table types mixes the depth subtyping restrictions of rule {\sc S-TableOtoC} with the width subtyping restrictions of rule {\sc S-TableUtoUOF}, but still allows merging fields and adding new fields.

Finally, rule {\sc S-TableFtoF} for subtyping between {\em fixed} table types is the most restrictive, and does not allow width
subtyping, merging fields, or adding fields, just standard
depth subtyping.

We will revisit the subtyping rules among table types on
Section~\ref{sec:tables}.

\begin{figure}[t]
\label{fig:subrec}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{S-Amber}\\
\dfrac{\senv[x_{1} \subtype x_{2}] \vdash T_{1} \subtype T_{2}}
{\senv \vdash \mu x_{1}.T_{1} \subtype \mu x_{2}.T_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-Assumption}\\
\dfrac{x_{1} \subtype x_{2} \in \senv}
{\senv \vdash x_{1} \subtype x_{2}}
\end{array}\\\\
\begin{array}{c}
\mylabel{S-UnfoldRight}\\
\dfrac{\senv \vdash T_{1} \subtype [x \mapsto \mu x.T_{2}]T_{2}}
{\senv \vdash T_{1} \subtype \mu x.T_{2}}
\end{array}
\;
\begin{array}{c}
\mylabel{S-UnfoldLeft}\\
\dfrac{\senv \vdash [x \mapsto \mu x.T_{1}]T_{1} \subtype T_{2}}
{\senv \vdash \mu x.T_{1} \subtype T_{2}}
\end{array}
\end{array}
\]
\caption{Subtyping for recursive types}
\end{figure}

Figure~\ref{fig:subrec} shows the subtyping rules for
recursive types. Rule {\sc S-Amber} is the \emph{Amber rule}~\cite{cardelli1986amber} for subtyping between
two recursive types. Rules {\sc S-UnfoldRight} and {\sc S-UnfoldLeft} unfold the recursive type for establishing
subtyping between a non-recursive and a recursive type,
or vice-versa.

The dynamic type $\Any$ is only a subtype of itself and of
$\Value$, and no type except $\Any$ is a subtype of $\Any$.
The type $\Any$ interacts with other types through the
{\em consistency} and {\em consistent-subtyping} 
relations~\cite{siek2007objects}. We use the symbol $\sim$ for
the consistency, and $\lesssim$ for consistent-subtyping.

The type $\Any$ is trivially consistent with all types, and all types
are consistent with $\Any$. A type is also consistent with
itself. Two union types $F_1 \cup F_2$ and $F_3 \cup F_4$ are
consistent if either $F_1 \sim F_3$ and $F_2 \sim F_4$ or
$F_1 \sim F_4$ and $F_2 \sim F_3$. Two function types
$S_1 \rightarrow S_2$ and $S_3 \rightarrow S_4$ are consistent
if and only if $S_1 \rightarrow S_3$ and $S_2 \rightarrow S_4$. Two table types are consistent if and only if they have the same key types, and the value types of each key type are consistent. Two recursive types are consistent if and only if their contents are consistent assuming that their type variables are consistent. Unions of tuple types follow the same rules as unions of first-class types. Variadic types are consistent if and only if their base types are consistent. 
Finally, pair types $F_1 \times P_1$ and $F_2 \times P_2$ are
consistent if and only if $F_1 \sim F_2$ and $P_1 \sim P_2$.

In a language with subtyping, the consistency relation is
too restrictive. We need to combine it with subtyping into a
{\em consistent-subtyping} relation. The definition is
straightforward: a type is a consistent-subtype
of another if the first type is a subtype of a type
that is consistent with the other, or if the first type
is consistent with a type that is a subtype of the other.

In the implementation of Typed Lua, we also use consistent-subtyping to normalize and simplify union types.
For instance, the union type $\Boolean \cup \Any$ simplifies
to $\Any$, because $\Boolean$ is a consistent-subtype
of $\Any$. Another example is the union type
$\Number \cup \Nil \cup 1$, that simplifies to
$\Number \cup \Nil$, because $1$ is a consistent-subtype of $\Number$.

\section{Typing rules}
\label{sec:rules}

\begin{figure*}[!ht]
	$$
	\begin{array}{rlr}
	s ::= & & \textsc{statements:}\\
	& \;\; \mathbf{skip} & \textit{skip}\\
	& | \; s_{1} \; ; \; s_{2} & \textit{sequence}\\
	& | \; \overline{l} = el & \textit{multiple assignment}\\
	& | \; \mathbf{while} \; e \; \mathbf{do} \; s \;
	| \; \mathbf{if} \; e \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2} & \textit{control flow}\\
	& | \; \mathbf{local} \; \overline{id{:}T} = el \; \mathbf{in} \; s & \textit{variable declaration}\\
	& | \; \mathbf{local} \; \overline{id} = el \; \mathbf{in} \; s & \textit{variable declaration}\\
	& | \; \mathbf{rec} \; id{:}T = f \; \mathbf{in} \; s & \textit{recursive function} \\
	& | \; \mathbf{return} \; el & \textit{return} \\
	& | \; \lfloor a \rfloor_{0} & \textit{application with no results}\\
	& | \; \mathbf{fun} \; id_{1}{:}id_{2} \; (pl){:}S \; s \;;\; \mathbf{return} \; el & \textit{method declaration}\\
	e ::= & & \textsc{expressions:}\\
	& \;\; \mathbf{nil} & \textit{nil}\\
	& | \; k & \textit{other literals}\\
	& | \; id & \textit{variable access}\\
	& | \; e_{1}[e_{2}] & \textit{table access}\\
	& | \; {<}T{>} \; id & \textit{type coercion}\\
	& | \; f & \textit{function declaration}\\
	& | \; \{ \; \overline{[e_{1}] = e_{2}} \; \} \;
	| \; \{ \; \overline{[e_{1}] = e_{2}},me \; \} & \textit{table constructor}\\
	& | \; e_{1} + e_{2} \;
	| \; e_{1} \; {..} \; e_{2} \;
	| \; e_{1} == e_{2} \;
	| \; e_{1} < e_{2} & \textit{binary operations}\\
	& | \; e_{1} \;\&\; e_{2} \;
	| \; e_{1} \; \mathbf{and} \; e_{2} \;
	| \; e_{1} \; \mathbf{or} \; e_{2} & \textit{binary operations}\\
	& | \; \mathbf{not} \; e \;
	| \; \# \; e & \textit{unary operations} \\
	& | \; \lfloor me \rfloor_{1} & \textit{expressions with one result}\\
	l ::= & & \textsc{left-hand values:}\\
	& \;\; id_{l} & \textit{variable assignment}\\
	& | \; e_{1}[e_{2}] & \textit{table assignment}\\
	& | \; id[k] \; {<}T{>} & \textit{type coercion}\\
	k ::= & & \textsc{literal constants:}\\
	& \;\; \mathbf{false} \; | \;
	\mathbf{true} \; | \;
	{\it int} \; | \;
	{\it float} \; | \;
	{\it string} & \\
	el ::= & & \textsc{expression lists:}\\
	& \;\; \overline{e} \; | \;
	\overline{e}, me & \\
	me ::= & & \textsc{multiple results:}\\
	& \;\; a & \textit{application}\\
	& | \; {...} & \textit{vararg expression}\\
	a ::= & & \textsc{applications:}\\
	& \;\; e(el) & \textit{function application}\\
	& | \; e{:}n(el) & \textit{method application}\\
	f ::= & & \textsc{function declarations:}\\
	& \;\; \mathbf{fun} \; (pl){:}S \; s \;;\; \mathbf{return} \; el & \\
	pl ::= & & \textsc{parameter lists:}\\
	& \;\; \overline{id{:}T} \; | \;
	\overline{id{:}T},{...}{:}T & \\
	\end{array}
	$$
	\caption{Abstract Syntax}
	\label{fig:syntax}
\end{figure*}

Figure \ref{fig:syntax} presents the abstract syntax of 
Core Typed Lua, a large subset of concrete syntax
that the Typed Lua compiler handles. We use this abstract
syntax in the presentation of the typing rules
for tables and evolution of table types (Section~\ref{sec:tables})
and for functions with overloaded multiple returns and
projection types (Section~\ref{sec:projections}).
Core Typed Lua simplifies the presentation of typing rules
without sacrificing expressiveness.

The main differences between Core Typed Lua and the concrete
syntax are:
\begin{itemize}
\item lack of labels and goto statements, as they are incompatible
with the {\em flow typing} of Typed Lua's type system;
\item local variable declarations have an explicit block,
instead of being just statements;
\item no {\bf elseif} clause in {\bf if} statements;
\item no {\bf repeat} and {\bf for} loops, just {\bf while};
\item the only arithmetic operator is $+$, the only relational
operators are $==$ and $<$, and the only bitwise operator
is $\&$, as all other operators have typing rules identical to
one of these;
\item type coercion for evolution of table types is explicit,
with two coercion terms, the l-value $id[k] \; {<}T{>}$ for adding a field to 
a table through assignment, and the r-value ${<}T{>} \;id$ for reinterpreting
a table type to a compatible type that is expected by the context;
\item all function declarations are anonymous, so there is a
statement for declaring recursive functions;
\item function or method applications that throw away all
results or all but the first result are explicitly annotated
as such, instead this being implicit in their syntactic context;
\item identifiers that appear in l-value position are explicitly
annotated as such with an $l$ subscript.
\end{itemize}

We present the typing rules as a deduction system for two typing relations, one for typing statements and another for typing expressions. Typing judgments for statements have the form $\env_{1}, \penv \vdash s, \env_{2}$, meaning that
given a type environment $\env_{1}$ and a {\em projection environment} $\penv$ we can prove that a statement $s$ produces a new type environment $\env_{2}$. Typing judgements for
expressions have the form $\env_{1}, \penv \vdash e : T, \env_{2}$, meaning that given a type environment $\env_{1}$
and a projection environment $\penv$ we can prove that an expression $e$ has type $T$ and produces a new type environment $\env_{2}$.

The type environment is standard, and maps
identifiers to first-level types. Some typing rules of
Section~\ref{sec:tables} can change the type of an identifier,
so the typing relation has both an input and an output type
environment. The {\em projection environment} $\Pi$ maps projection labels to second-level types, and we explain
its use in Section~\ref{sec:projections}.

\subsection{Tables and Evolution of Table Types}
\label{sec:tables}

The simplest expression involving tables is the empty
table constructor $\{\}$. The empty table constructor always
has type $\{\}_{unique}$. A more interesting example is $\{ [``x"] = 1, [``y"] = 2 \}$, which has type $\{ ``x":1 , ``y": 2 \}_{unique}$. The subtyping rule for {\em unique} tables lets
us assign this table to a variable with a more general
type such as $\{ ``x":\Number , ``y": \Number \}_{unique}$ or
even $\{ \String:\Number \cup \Nil \}_{unique}$. We give
the typing rule for table constructors of this form below: 
\[
\begin{array}{c}
\mylabel{T-CONSTRUCTOR-FIELDS}\\
\dfrac{\begin{array}{c}
	\overline{\env_1, \penv \vdash e_2: fix(V), \env_v}
	\;\;\;
	\overline{\env_v, \penv \vdash e_1: K, \env_f}
	\\
	T = \{\overline{K{:}V}\}_{unique} \;\;\;
	\env_{2} = merge(\overline{\env_{f}}) \;\;\; wf(T)
	\end{array}}
{\env_{1}, \penv \vdash \{\;\overline{[e_{1}] = e_{2}}\;\}:T, \env_{2}}
\end{array}
%\dfrac{\begin{array}{c}
%	\env_{1}, \penv \vdash ([e_{1}] = e_{2})_{i}:(K_{i},V_{i}), \env_{i+1} \\
%	T = \{K_{1}{:}V_{1}, ..., K_{n}{:}V_{n}\}_{unique} \;\;\;
%	wf(T) \;\;\;
%	n = |\;\overline{[e_{1}] = e_{2}}\;| \\
%	\env_{f} = merge(\env_{1}, ..., \env_{n+1})
%	\end{array}}
%{\env_{1}, \penv \vdash \{\;\overline{[e_{1}] = e_{2}}\;\}:T, \env_{f}}
%\end{array}
\]

Due to the system for changing the table type of variables that
we will explain in this section, any expression can potentially
change the type environment. Lua semantics does not dictate
an order of evaluation among the pairs of field initializers,
so all of them are typed in the same input type environment.
The $merge$ auxiliary function then combines their output
environments, diverging in case of conflicting changes.

The rule also checks if the resulting type is {\em well-formed}
with the predicate $wf$. Formally, we define this predicate
for table types with the following formula:
\[
\begin{array}{c}
\forall i \; ((\nexists j \; i \not= j \,\wedge\, K_{i} \lesssim K_{j}) \,\wedge\, wf(V_{i}) \,\wedge\,\\ \lnot isunique(V_{i}) \,\wedge\, \lnot isopen(V_{i}))
\end{array}
\]

Well-formed table types avoid ambiguity.
For instance, this rule detects that the table type
$\{1:\Number, \Integer:\String, \Any:\Boolean\}$ is ambiguous,
because indexing it with a key of type $\Integer$ could
yield either a number, a string or a boolean at runtime.

Well-formed table types also do not allow \emph{unique} and
\emph{open} table types to appear in the type of the values,
and they must be well-formed. Our type system currently cannot
track aliases of table fields, so this restriction is
necessary. 

This restriction is the reason rule {\sc T-CONSTRUCTOR-FIELDS}
uses the auxiliary function $fix$ to change any {\em open}
and {\em unique} table types used in the field initializer
to {\em fixed}. As an example, the table constructor $\{[``x"] = 1, [``y"] = \{[``z"] = 2\}\}$
has type $\{``x":1, ``y":\{``z":2\}_{fixed}\}_{unique}$.

After presenting some typing rules of the table constructor,
we start the discussion of the rules that define the most
unusual feature of our type system: the refinement of table types.
The first kind of refinement allows programmers to add new
fields to \emph{unique} or \emph{open} table types through
field assignment.
As an example, we can translate
\begin{verbatim}
    local person = {}
    person.firstname = "Lou"
    person.lastname = "Reed"
\end{verbatim}
to our reduced core as follows:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{$\mathbf{local} \; person = \{\} \; \mathbf{in}$}\\
& \multicolumn{1}{l}{$person[``firstname"] \; {<}\String{>} = ``Lou";$}\\
& \multicolumn{1}{l}{$person[``lastname"] \; {<}\String{>} = ``Reed"$}
\end{tabular}
\end{center}

In this example, we assign the type $\{\}_{unique}$ to the variable
$person$, then we refine its type to $\{``firstname":\String\}_{unique}$,
and then to $\{``firstname":\String, ``lastname":\String\}_{unique}$.
Rule \textsc{T-NEWFIELD} type checks this use of refinement:
\[
\begin{array}{c}
\mylabel{T-NEWFIELD}\\
\dfrac{\begin{array}{c}
       \env_{1}(id) = \{ K_{1}{:}V_{1}, ..., K_{n}{:}V_{n} \}_{open|unique}\\
       \env_{1}, \penv \vdash k:K, \env_{2} \;\;\;
       \not \exists i \in 1..n \; K \lesssim K_{i} \;\;\;
       V = close(T)
       \end{array}}
      {\begin{array}{l}
       \env_{1}, \penv \vdash id[k] {<}T{>}:V, \\
       \env_{2}[id \mapsto \{ K_{1}{:}V_{1}, ..., K_{n}{:}V_{n}, K{:}V\}_{open|unique}]
       \end{array}}
\end{array}
\]

We restricted the refinement of table types to include only literal
keys, because its purpose is to make it easier the construction of
table types that represent records.

We use the refinement of table types to handle the declaration of
new global variables.
In Lua, the assignment \texttt{v = v + 1} translates to
\texttt{\string_ENV["v"] = \string_ENV["v"] + 1} when \texttt{v}
is not a local variable, where \texttt{\string_ENV} is a table
that stores the global environment.
For this reason, Typed Lua treats accesses to global variables as field accesses
to an \emph{open} table in the top-level scope.
In the following examples we assume that $\string_ENV$ is in the
environment and has type $\{\}_{open}$.

As an example,
\begin{align*}
& \string_ENV[``x"] \; {<}\String{>} = ``foo" \;; \\
& \string_ENV[``y"] \; {<}\Integer{>} = 1
\end{align*}
uses field assignment to add fields $``x"$ and $``y"$ to $\string_ENV$.
Therefore, after these field assignments $\string_ENV$ has type
$\{``x":\String, ``y":\Integer\}_{open}$.

We do not allow the refinement of table types to add a field if it is
already present in the table's type.
For instance,
\begin{align*}
& \string_ENV[``x"] \; {<}\String{>} = ``foo" \;; \\
& \string_ENV[``x"] \; {<}\Integer{>} = 1
\end{align*}
does not type check, as we are trying to add $``x"$ twice.

We also do not allow the refinement of table types to introduce
fields with table types that are not \emph{closed}.
For instance,
\begin{center}
\begin{tabular}{l}
$\string_ENV[``x"] \; {<}\{\}_{unique}{>} = \{\}$
\end{tabular}
\end{center}
refines the type of $\string_ENV$ from $\{\}_{open}$ to $\{``x":\{\}_{closed}\}_{open}$.
Currently, our type system can only track \emph{unique} and
\emph{open} table types that are bound to local variables.

We can also use multiple assignment to refine table types:
\[
\string_ENV[``x"] \; {<}\String{>}, \string_ENV[``y"] \; {<}\Integer{>} = ``foo", 1
\]

This example type checks because all the environment changes are consistent, and
$``foo" \times 1 \times \Nil{*} \lesssim \String \times \Integer \times \Value{*}$.
By consistent we mean that we are only adding new fields.
Nevertheless, the next example does not type check because it tries to add
the same field to $\string_ENV$, but with different types:
\[
\string_ENV[``x"] \; {<}\String{>}, \string_ENV[``x"] \; {<}\Integer{>} = ``foo", 1
\]

Aliasing an \emph{unique} or an \emph{open} table type can produce
either a \emph{closed} or a \emph{fixed} table type, depending on
the context that we are using a variable.
We need \emph{fixed} table types to type classes in object-oriented programming.
In the implementation we fix the aliasing of \emph{unique} and \emph{open}
table types that appear in a top-level return statement, and in other cases we
close the aliasing of \emph{unique} and \emph{open} table types.
However, in the formalization we chose to define this behavior in
a not deterministic way, as it makes easier the presentation of this behavior.

As an example,
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = a \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
does not type check, as aliasing $a$ produces the type $\{\}_{closed}$
that is not a subtype of $\{\}_{open}$, the type of $b$.
Our type system has this behavior to warn programmers about
potential unsafe behaviors after this kind of alias.
In this example, it is unsafe to add the field $``x"$ to $b$,
as it changes the value that is stored in the field $``x"$ of $a$.

The rules \textsc{T-ID-R-CLOSE} and \textsc{T-ID-R-FIX} define this non-deterministic behavior.
Rule \textsc{T-ID-R-CLOSE} uses the auxiliary function \emph{close} to
produce a \emph{closed} alias.
It also uses the auxiliary function \emph{open} to change the type of
the original reference from \emph{unique} to \emph{open},
because aliasing an \emph{unique} table type while keeping the original
reference \emph{unique} can be unsafe.
Rule \textsc{T-ID-R-FIX} uses the auxiliary function \emph{fix} to
produce a \emph{fixed} alias.
It also uses \emph{fix} to change the type of the original reference
to \emph{fixed}, because a \emph{fixed} table type does not allow
width subtyping.
We define these rules as follows:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-ID-R-CLOSE}\\
\dfrac{\env_{1}(id) = T_{1} \;\;\; T_{2} = read(\penv, T_{1})}
      {\env_{1}, \penv \vdash id:close(T_{2}), \env_{1}[id \mapsto open(T_{1})]}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-ID-R-FIX}\\
\dfrac{\env_{1}(id) = T_{1} \;\;\; T_{2} = read(\penv, T_{1})}
      {\env_{1}, \penv \vdash id:fix(T_{2}), \env_{1}[id \mapsto fix(T_{1})]}
\end{array}
\end{array}
\]

Both rules use the auxiliary function \emph{read} because they may be
accessing an identifier that is bound to a filter or projection type.
As we presented in our previous design of Typed Lua \cite{maidl2014tl},
our type system includes a small set of \texttt{type} predicates that allow
programmers to discriminate union types, and our type system uses filter and
projection types in the definition of these predicates to handle the discrimination
of unions types.
While filter types discriminate unions of first-level types, projection
types discriminate unions of second-level types and project unions of
second-level types into unions of first-level types.
We can define \emph{read} as follows:
\begin{align*}
read(\penv, \phi(T_{1},T_{2})) & = T_{2}\\
read(\penv, \pi_{i}^{x}) & = proj(\penv(x), i)\\
read(\penv, T) & = T
\end{align*}

The function \emph{read} uses the auxiliary function \emph{proj}
to project a union of first-level types, based on an union of
second-level types and an index from a projection type.
In Section \ref{sec:projections} we will discuss how our type system uses
projection types to handle overloaded return types.
We can define \emph{proj} as follows:
\begin{align*}
proj(T_{1} \times ... \times T_{n} \times T{*}, i) & =  T_{i} \;\;\; \text{if $i <= n$}\\
proj(S_{1} \sqcup S_{2}, i) & = proj(S_{1}, i) \cup proj(S_{2}, i)
\end{align*}

We also need to close \emph{unique} and \emph{open} tables that
appear in the left-hand side of assignments, as leaving them
\emph{unique} and \emph{open} would allow the creation of
unsafe references.

As an example,
\begin{center}
\begin{tabular}{lll}
\multicolumn{3}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{\} \; \mathbf{in}$}\\
& \multicolumn{2}{l}{$\mathbf{local} \; b:\{\}_{open} = \{\} \; \mathbf{in}$}\\
& & \multicolumn{1}{l}{$b = a;$}\\
& & \multicolumn{1}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& & \multicolumn{1}{l}{$b[``x"] \; {<}\Integer{>} = 1$}\\
\end{tabular}
\end{center}
does not type check because we cannot add the field $``x"$ to $b$,
as its type is \emph{closed}.
Aliasing $a$ changes the type of $a$ from $\emph{unique}$ to
$\emph{open}$, and that is the reason why we can add the field
$``x"$ to the type of $a$.
Aliasing $a$ also produces the type $\{\}_{closed}$, which is
the same type that $b$ has in left-hand side of the assignment.
After the assignment, the type of $b$ is \emph{closed} and thus
does not allow changing the value that is stored in the field
$``x"$ of $a$.

Rule \textsc{T-ID-L} defines this behavior:
\[
\begin{array}{c}
\mylabel{T-ID-L}\\
\dfrac{\env_{1}(id) = T_{1} \;\;\; T_{2} = write(T_{1})}
      {\env_{1}, \penv \vdash id_{l}:close(T_{2}), \env_{1}[id \mapsto close(T_{2})]}
\end{array}
\]

This rule uses the auxiliary function \emph{write} because it may be
accessing an identifier that is bound to a filter type.
In Typed Lua, assignments restore discriminated union types to their original types,
and function \emph{write} works in this purpose.
We can define \emph{write} as follows:
\begin{align*}
write(\phi(T_{1},T_{2})) & = T_{1}\\
write(T) & = T
\end{align*}

Our type system also has different rules for type checking table indexing to avoid
changing table types in these operations, as they cannot create aliases:
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-INDEX-ID}\\
\dfrac{\begin{array}{c}
       \env_{1}(id) = T \;\;\;
       read(\penv, T) = \{K_{1}{:}V_{1}, ..., K_{n}{:}V_{n}\}\\
       \env_{1}, \penv \vdash e_{2}:K, \env_{2} \;\;\;
       \exists i \in 1{..}n \; K \lesssim K_{i}
       \end{array}}
      {\env_{1}, \penv \vdash id[e_{2}]:V_{i}, \env_{2}}
\end{array}
\\ \\
\begin{array}{c}
\mylabel{T-INDEX-EXP}\\
\dfrac{\begin{array}{c}
       \env_{1}, \penv \vdash e_{1}:\{K_{1}{:}V_{1}, ..., K_{n}{:}V_{n}\}, \env_{2}\\
       \env_{2}, \penv \vdash e_{2}:K, \env_{3} \;\;\;
       \exists i \in 1{..}n \; K \lesssim K_{i}
       \end{array}}
      {\env_{1}, \penv \vdash e_{1}[e_{2}]:V_{i}, \env_{3}}
\end{array}
\end{array}
\]

A second form of refinement happens when we want to use an
\emph{unique} or \emph{open} table type in a context that expects a
\emph{fixed} or \emph{closed} table type with a different shape.
This kind of refinement allows programmers to add optional fields
or merge existing fields.
To do that, Typed Lua includes a type coercion expression ${<}T{>} \; id$.
For instance, we can use this type coercion expression to make the following
example type check:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; a:\{\}_{unique} = \{ \} \; \mathbf{in}$}\\
& \multicolumn{3}{l}{$a[``x"] \; {<}\String{>} = ``foo";$}\\
& \multicolumn{3}{l}{$a[``y"] \; {<}\String{>} = ``bar";$}\\
& \multicolumn{3}{l}{$\mathbf{local} \; b:\{``x":\String, ``y":\String \cup \Nil \}_{closed} =$}\\
& & \multicolumn{2}{l}{${<}\{``x":\String, ``y":\String \cup \Nil\}_{open}{>} \; a \; \mathbf{in}$}\\
& & & \multicolumn{1}{l}{$a[``z"] \; {<}\Integer{>} = 1$}
\end{tabular}
\end{center}

We can use $a$ to initialize $b$ because the coercion converts
the type of $a$ from $\{``x":\String, ``y":\String\}_{unique}$ to
$\{``x":\String, ``y":\String \cup \Nil\}_{open}$, and results in
$\{``x":\String, ``y":\String \cup \Nil\}_{closed}$,
which is a subtype of
$\{``x":\String, ``y":\String \cup \Nil\}_{closed}$, the type of $b$.
We can continue to refine the type of $a$ after aliasing it to $b$,
as it still holds an \emph{open} table.
At the end of this example, $a$ has type
$\{``x":\String, ``y":\String \cup \Nil, ``z":\Integer\}_{open}$.

Rule \textsc{T-COERCE} defines the behavior of the type coercion expression:
\[
\begin{array}{c}
\mylabel{T-COERCE}\\
\dfrac{\env_{1}(id) \subtype T \;\;\;
       \env_{1}[id \mapsto T], \penv \vdash id:T_{1}, \env_{2}}
      {\env_{1}, \penv \vdash {<}T{>} \; id:T_{1}, \env_{2}}
\end{array}
\]

Note that rule \textsc{T-COERCE} only allows changing the type
of a variable if the new type is a supertype of the previous type,
and the resulting type is always \emph{fixed} or \emph{closed}
to prevent the creation of unsafe aliases.

Lua has first-class functions, so another way of aliasing
an {\em unique} and {\em open} references is by closing
over them in a function body. In the environment used for
typing the function body, all {\em unique} and {\em open}
tables are {\em closed} with the auxiliary function $closeall$.
This is not enough, as assignment
to a closed-over variable can be unsafe. In the following
example, assume that the $g$ receives a parameter of type
$\{ ``x": \String \cup \Nil\}$:
\begin{center}
	\begin{tabular}{llll}
		\multicolumn{4}{l}{$\mathbf{local} \; a:\{\}_{open}
			= \{\} \; \mathbf{in}$}\\
		& \multicolumn{3}{l}{$\mathbf{local} \; f:\Void \rightarrow \Void =$}\\
		& & \multicolumn{2}{l}{$\mathbf{fun} \; ():\Void$}\\
		& & & \multicolumn{1}{l}{$a = \{[``x"]=5\} $}\\
		& \multicolumn{3}{l}{$\mathbf{in} \; g({<}\{``x":
			 \String \cup \Nil\}{>} \; a)$}
	\end{tabular}
\end{center}

The type of $a$ on line 3 is $\{\}_{closed}$, so the assignment
would type-check. But then the function call on the last line
would also type-check, as $\{\}_{open}$ can be coerced to
$\{ ``x": \String \cup \Nil\}$. A solution is to change the
type of $a$ from {\em unique} to {\em closed} after the function
declaration. In order to do that, we use the auxiliary function
$fav$ ({\em free assigned-to variables}) to collect this
set of identifiers, and then function $closeset$ changes
the type environment to so any of these variables that
has an {\em unique} or {\em open} table type becomes {\em closed}.

Closed-over variables that are not assigned still may
change their type if they have a {\em unique} table type
and are aliased inside the function body. We use the auxiliary
function $frv$ ({\em free referenced variables}) to collect
this set, and then function $openset$ changes any variables
with a {\em unique} table type in the environment to {\em open}.

Rule {\sc T-FUNCTION} types non-variadic function declarations,
and shows how these auxiliary functions work together:
\[
\begin{array}{c}
\mylabel{T-FUNCTION}\\
\dfrac{\begin{array}{c}
	closeall(\env_{1})[\overline{id \mapsto T}], \penv[\ret \mapsto S] \vdash s, \env_{2}\\
	\env_{3} = openset(\env_{1}, frv(\mathbf{fun} \; (\overline{id{:}T}){:}S \; s)) \\
	\env_{4} = closeset(\env_{3}, fav(\mathbf{fun} \; (\overline{id{:}T}){:}S \; s))
	\end{array}}
{\env_{1}, \penv \vdash \mathbf{fun} \; (\overline{id{:}T}){:}S \; s:\overline{T} \times \Void \rightarrow S, \env_{3}}
\end{array}
%\begin{array}{c}
%\mylabel{T-FUNCTION}\\
%\dfrac{\begin{array}{c}
%	crall(\env_{1}[\overline{id} \mapsto \overline{T}]), \penv[\ret \mapsto S] \vdash s, \env_{2}\\
%	\env_{3} = crset(\env_{1}, fav(\mathbf{fun} \; (\overline{id{:}T}){:}S \; s))\\
%	\env_{4} = openset(\env_{3}, rv(\mathbf{fun} \; (\overline{id{:}T}){:}S \; s))
%	\end{array}}
%{\env_{1}, \penv \vdash \mathbf{fun} \; (\overline{id{:}T}){:}S \; s:\overline{T} \times \Void \rightarrow S, \env_{4}}
%\end{array}
\]

Notice that the environment $\env_{2}$ resulting from
typing the function body is just ignored.

The following example typechecks, and uses all the parts of {\sc T-FUNCTION}:
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{$\mathbf{local} \; a:\{\}_{unique}, b:\{\}_{unique} = \{\}, \{\} \; \mathbf{in}$}\\
& \multicolumn{3}{l}{$\mathbf{local} \; f:\Integer \times \Void \rightarrow \Integer \times \Void =$}\\
& & \multicolumn{2}{l}{$\mathbf{fun} \; (x:\Integer):\Integer \times \Void$}\\
& & & \multicolumn{1}{l}{$b = a \;;\; \mathbf{return} \; x + 1$}\\
& \multicolumn{3}{l}{$\mathbf{in} \; a[``x"] \; {<}\Integer{>} = 1 \;;\; f(a[``x"])$}\\
%& & \multicolumn{2}{l}{$b[``x"] \; {<}\String{>} = ``foo" \;;\;
%	 f(a[``x"])$}
\end{tabular}
\end{center}

The assignment $b=a$ typechecks because, at that point, 
both $b$ and $a$ have type $\{\}_{closed}$ due to $closeall$.
The set $fav$ is $\{b\}$, and the set $frv$ is $\{a\}$.
This causes the type of $b$ to also be $\{\}_{closed}$
in the body of the inner {\bf local} statement, due to $closeset$, and the type of $a$ to be $\{\}_{open}$ due
to $openset$. Being $\{\}_{open}$, adding a new field
is allowed, changing the type of $a$ to $\{``x": \Integer\}_{open}$ after the semicolon. After the call to
$f$, the variable $b$ is an alias to $a$ but this is not
an issue, as $\{\}_{closed}$ is a supertype of $\{``x": \Integer\}_{open}$.

\subsection{Projection Types}
\label{sec:projections}

\begin{figure*}[t]
\label{fig:projtypes}
\[
\begin{array}{c}
\begin{array}{c}
\mylabel{T-LocalProj}\\
\dfrac{\begin{array}{c}
	\env_{1}, \penv \vdash el:T_1 \times \ldots T_n \times P, \env_{2}, (x,S)\\
	\env_{3} = \env_{2}[id_{1} \mapsto T_1, \ldots, id_{n} \mapsto T_n]\\
	\env_{3}, \penv[x \mapsto S] \vdash s, \env_{4} \;\;\;
	n = |\;\overline{id}\;|  
	\end{array}}
{\env_{1}, \penv \vdash \mathbf{local} \; \overline{id} = el \; \mathbf{in} \; s, (\env_{4}-\{\overline{id}\})[\overline{id \mapsto \env_2(id)}]}
\end{array}
\begin{array}{c}
\mylabel{T-ExpListProj}\\
\dfrac{\begin{array}{c}
	\env_{1}, \penv \vdash e_{i}:T_{i}, \env_{i+1} \;\;\;
	\env_{1}, \penv \vdash me:S, \env_{n+2} \;\;\; n=|\overline{e}|\\
	S = S_1 \sqcup S_2 \;\;\;m = max(|S_1|, |S_2|) \;\;\; x \notin \Pi\\
	\env_{f} = merge(\env_{1}, ..., \env_{n+2})
	\end{array}}
{\env_{1}, \penv \vdash \overline{e},me:}\\ {T_{1} \times ... \times T_{n} \times \pi_{1}^{x} \times ... \times \pi_{m}^{x}{*}, \env_{f}, (x,S)}
\end{array}\\\\
\begin{array}{c}
\mylabel{T-IfFilterProjThen}\\
\dfrac{\begin{array}{c}
	\env_{1}(id) = \pi_{i}^{x} \\ S_t = fonilpt(\Pi(x), i)\\ 
	finil(proj(\Pi(x), i)) = {\bf void} \\
	\env_{1}, \penv[x \mapsto S_t] \vdash s_{1}, \env_{2} 
	\end{array}}
{\env_{1}, \penv \vdash \mathbf{if} \; id \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}, \env_{2}}
\end{array}
\begin{array}{c}
\mylabel{T-IfFilterProjElse}\\
\dfrac{\begin{array}{c}
	\env_{1}(id) = \pi_{i}^{x} \\
	 S_e = finilpt(\Pi(x), i)\\
	fonil(proj(\Pi(x), i)) = {\bf void} \\
	\env_{1}, \penv[x \mapsto S_e] \vdash s_{2}, \env_{2} 
	\end{array}}
{\env_{1}, \penv \vdash \mathbf{if} \; id \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}, \env_{2}}
\end{array}
\begin{array}{c}
\mylabel{T-IfFilterProjBoth}\\
\dfrac{\begin{array}{c}
	\env_{1}(id) = \pi_{i}^{x} \\ S_t = fonilpt(\Pi(x), i) \; S_e = finilpt(\Pi(x), i)\\
	\env_{1}, \penv[x \mapsto S_t] \vdash s_{1}, \env_{2} \\
	\env_{1}, \penv[x \mapsto S_e] \vdash s_{2}, \env_{3} \\
	\env_{4} = join(\env_{2}, \env_{3}) 
	\end{array}}
{\env_{1}, \penv \vdash \mathbf{if} \; id \; \mathbf{then} \; s_{1} \; \mathbf{else} \; s_{2}, \env_{4}}
\end{array}\\\\
%\begin{array}{rcll}
%last(F_1{*} \sqcup F_2{*}) & = & F_1{*} & \mathrm{if} \; F_2{*} \subtype F_1{*}\\
%last(F_1{*} \sqcup F_2{*}) & = & F_2{*} & \mathrm{if} \; F_1{*} \subtype F_2{*}\\
%last(F_1{*} \sqcup F_2{*}) & = & (F_1 \cup F_2){*} & \mathrm{otherwise}\\
%last(F{*} \sqcup T \times P) & = & last(\Nil{*} \sqcup P) \\
%last(T \times P \sqcup F{*}) & = & last(P \sqcup \Nil{*}) \\
%last(P \sqcup S) & = & last(P \sqcup last(S)) \\
%last(S \sqcup P) & = & last(last(S) \sqcup P) \\
%last(S_1 \sqcup S_2) & = & last(last(S_1) \sqcup last(S_2))
%\end{array}\\\\
\begin{array}{rcll}
proj(S_1 \sqcup S_2, i) & = & proj(S_1, i) \cup proj(S_2, i) \\
proj(F{*}, i) & = & F \cup \Nil \\
proj(T \times P, 1) & = & T \\
proj(T \times P, i) & = & proj(P, i-1)
\end{array}\\\\
\begin{array}{rcll}
fonilpt(P_1 \sqcup P_2) & = & P_2 & \mathrm{if} \; fonil(proj(P_1, i)) = {\bf void} \\
fonilpt(P_1 \sqcup P_2) & = & P_1 & \mathrm{if} \; fonil(proj(P_2, i)) = {\bf void} \\
fonilpt(P_1 \sqcup P_2) & = & P_1 \sqcup P_2 & \mathrm{otherwise}\\
fonilpt(P \sqcup S) & = & fonilpt(S) & \mathrm{if} \; fonil(proj(P, i)) = {\bf void} \\
fonilpt(P \sqcup S) & = & P \sqcup fonilpt(S) & \mathrm{otherwise}\\
fonilpt(S \sqcup P_2) & = & fonilpt(S) & \mathrm{if} \; fonil(proj(P, i)) = {\bf void} \\
fonilpt(S \sqcup P) & = & fonilpt(S) \sqcup P & \mathrm{otherwise}\\
fonilpt(S_1 \sqcup S_2) & = & fonilpt(S_1) \sqcup fonilpt(S_2)
\end{array}\\\\
\begin{array}{rcll}
fonil(F_1 \cup F_2) & = & fonil(F_1) \cup fonil(F_2) \\
fonil(F) & = & {\bf void} & \mathrm{if} \; F \subtype \Nil \; \mathrm{and} \; \Nil \subtype F\\
fonil(F) & = & F & \mathrm{otherwise}
\end{array}
\end{array}
\]
\caption{Rules for Projection Types}
\end{figure*}

As we have seen in Section~\ref{sec:statistics}, Lua
programmers often overload the return type of functions
to denote errors, returning a {\tt nil} result and
an error message in case of an error instead of the
usual return values.

As an example, consider again the {\tt idiv} function
from Figure~\ref{fig:over}, which returns the quotient and rest of integer division, or a division by zero error. In Typed Lua, we can give a return type $(\Integer \times \Integer \times \Nil*) \sqcup (\Nil \times \String \times \Nil{*})$ to that function. 

As is also shown in Figure~\ref{fig:over}, the idiom for using such
a function is to test the first returned value. We
can translate that code to the abstract syntax of
Figure~\ref{fig:syntax}, leaving placeholders for
the body of the {\bf then} and {\bf else} branches:
\begin{center}
	\begin{tabular}{ll}
		\multicolumn{2}{l}{$\mathbf{local} \, q, r = idiv(a, b) \, \mathbf{in} \, \mathbf{if} \, q \, \mathbf{then} \, s_1 \, \mathbf{else} \, s_2$}
	\end{tabular}
\end{center}

A standard way of decomposing the union in the assignment
would let the type of {\tt q} be $\Integer \times \Nil$ and
the type of {\tt r} be $\Integer \times \String$. Flow typing
would narrow the type of {\tt q} to $\Integer$ in the {\tt then}
branch and to $\Nil$ in the {\tt else} branch, but would
leave the type of {\tt r} unchanged.

{\em Projection types}
are a general way to make the dependency between the types
of {\tt q} and {\tt r} survive the decomposition of the tuple,
so flow typing can narrow all of the components by testing
just one of them.

Intuitively, a projection type $\pi_{i}^{x}$ denotes the union of
the i-th components of all the tuples in the union of tuple types
denoted by the label $x$. Unions of tuple types referenced by projections are kept in their own {\em projection environment} $\Pi$. A fresh label is generated whenever the last term
in an expression list has a union of tuple types as its type.
Figure~\ref{fig:projtypes} presents the rules for introducing and filtering projection types.

Notice that in the above example the local variables $q$ and $r$ are declared without an explicit type. 
 The rule for typing this {\bf local} statement,
{\sc T-LocalProj}, introduces a new label in the projection
environment used for typing the {\bf if} statement.
The first judgement above the bar of rule {\sc T-LocalProj} uses the auxiliary typing relation $\env_{1}, \penv \vdash el : S_{1}, \env_{2}, (x,S_{2})$.

Rule {\sc T-ExpListProj} is the typing rule for this auxiliary
relation. It does the work of generating a fresh projection label,
and projection types associated with it, if the last term of
the expression list has a union of tuple types as its type.
The rule generates as many projection types as the the length
of the longest tuple.

In the above example, the combination of these two rules binds $x$ to
$(\Integer \times \Integer \times \Nil{*}) \sqcup (\Nil \times \String \times \Nil{*})$ in the projection environment $\Pi$,
and $q$ and $r$ respectively to $\pi_{1}^{x}$ and $\pi_{2}^{x}$
in the type environment used for typing the {\bf if} statement.

At this point, using $q$ or $r$ as an r-value will project
their types into either $\Integer \cup \Nil$ or $\Integer \cup \String$. The more interesting cases are inside the
branches of the {\bf if} statement, where rule {\sc T-IfFilterNilProj} filters the whole union of tuples referenced
by the projection type.

Rule \textsc{T-IfFilterNilProj} uses the auxiliary functions \emph{fonilpt} ({\em filter-out nil in projection type}) and \emph{finilpt} ({\em filter-in nil in projection type}) to
filter the union referenced by $\pi_{i}^{x}$, respectively
filtering $\Nil$ out at every i-th component (removing
the entire tuple if it is $\Nil$) and filtering $\Nil$ in at every i-th component (removing the entire tuple if it is not $\Nil$). These functions respectively use the functions $fonil$ and $finil$ to filter regular unions, plus $proj$ to test projected components. The definitions of $finilpt$ and $finil$ are analogous to the definitions of $finilpt$ and $finil$.

In our example, $x$ would be bound to $\Integer \times \Integer \times \Nil{*}$ in the {\bf then} branch, and would be bound
to $\Nil \times \String \times \Nil{*}$ inside the {\bf else}
branch. Now $q$ and $r$ project to $\Integer$ and $\Integer$
in the {\bf then} branch, and to $\Nil$ and $\String$ in the
{\bf else} branch. 

Rules {\sc T-IfFilterProjThen} and {\sc T-IfFilterProjElse}
respectively cover the case where the {\bf else} branch is unreachable and the case where the {\bf then} branch is unreacheable, because either the projected type of $\pi_i^x$
is not a supertype of $\Nil$ or is $\Nil$.

Assignment to an l-value with a projection type is forbidden. Allowing assignment is unsound, as it can break the dependency among the components of the union. In the example below,
the projected type of $r$ outside of the {\bf if} statement
is $\Integer \cup \String$, so the assignment seems correct,
but inside $s_1$ the projected type of $r$ would still be
$\Integer$:
\begin{center}
	\begin{tabular}{ll}
		\multicolumn{2}{l}{$\mathbf{local} \, q, r = idiv(a, b) \, \mathbf{in}$} \\
		&  $r = ``foo" ;\; \mathbf{if} \, q \, \mathbf{then} \, s_1 \, \mathbf{else} \, s_2$
	\end{tabular}
\end{center}

\section{Related Work}
\label{sec:related}

Tidal Lock~\cite{tidallock} is a prototype of another optional type system for Lua. It covers just a small subset of Lua
in its current form. Its most remarkable feature is
how it structures its table types to support a form of type
evolution through imperative assignment. Typed Lua uses
the same general idea of letting the type of a table evolve
through assignment, but the structure of both the table types
and the typing rules that support this are completely different.

Sol~\cite{sol} is another experimental optional type system
for Lua. While it has some similarities to Typed Lua, it
has more limited table types: Sol tables can only be lists,
maps, and objects that follow a specific object-oriented
idiom that Sol introduces. There is no evolution of table
types.

Lua Analyzer~\cite{luaanalyzer} is another optional type
system for Lua that is specially designed to work with
LÃ¶ve Studio, an IDE for game development using Lua.
It is unsound by design, and primarily for supporting
IDE autocompletion. There is no evolution of table types.

Ravi~\cite{ravi} is an experimental Lua dialect
with an LLVM-based JIT compiler. It has a basic
optional type system to improve performance
of numerical code. This type system only supports
numbers (integers and floating point) and arrays.

Typed Racket~\cite{tobin-hochstadt2008ts} is a statically typed version of the Racket language, which is a Scheme dialect.
The main purpose of Typed Racket is to allow programmers to combine untyped modules, which are written in Racket, with typed modules, which are written in Typed Racket. Typed Racket tracks
values that cross the boundary between the typed and
untyped parts to be able to correctly assign blame to type
errors that occur in the typed parts, so is a gradual type
system.

Typed Racket introduced {\em occurrence typing}, a form of
flow typing~\cite{tobin-hochstadt2010ltu}, where type
predicates are used to refining union types.
As this use of type predicates is common in other
dynamically-typed languages, related systems
have appeared~\cite{guha2011tlc,winther2011gtp,pearce2013ccf}.

Gradualtalk~\cite{allende2013gts} is a Smalltalk dialect 
with a gradual type system. Its type system combines
nominal and structural typing.
It includes function types, union types, structural object types,
nominal object types types, a self type, and parametric polymorphism. Like Typed Lua, Gradualtalk formalizes the
interaction between typed and untyped code with consistent-subtyping. Due to the performance impact of
the runtime checks that ensure the gradual typing guarantees,
Gradualtalk can be downgraded into an optional type system
through a configuration switch~\cite{allende2013cis}.

Reticulated Python~\cite{vitousek2014deg} is a
gradual type system for Python. It is structural, based on subtyping, and includes list types,
dictionary types, tuple types, function types, set types,
object types, class types, and recursive types.
Besides static type checking, Reticulated Python also introduces
three different approaches for inserting runtime assertions
that preserve the gradual typing guarantee.

Several dynamically typed languages now have optional
type systems: Clojure~\cite{bonnaire-sergeant2012typed-clojure},
JavaScript~\cite{typescript}, Python~\cite{mypy}, 
and PHP~\cite{hack}. While Lua has some similarities to
all of these languages, none of these optional type
systems have the features described in this paper.
Most of these languages do not have idioms
that inspired these features; JavaScript has the
idiom of adding fields to an initially empty
record through assignment, but TypeScript sidesteps
the issue by having allowing an empty record to
have any record or object type, as the type of
missing fields is the bottom type of its type system.

Dart~\cite{dart} and Grace~\cite{black2013sg} are
two languages that have been designed from scratch
to have an optional type system, instead of being
existing dynamically typed languages with a retrofitted 
type system. 

\section{Conclusions}
\label{sec:conclusion}

We have presented a formalization of Typed Lua,
an optional type system for Lua, with a focus on rules
for two novel features of the system that type unusual
idioms present in Lua programs.

In the first idiom, records and objects are
defined through assignment to an initially empty
table. In Typed Lua's type system the type of a
table can change, either by assignment
or by using the table in a context that expects
a different (but compatible) type from its current one.
The system tracks aliasing of table references
in order to do this type evolution in a type-safe
way.

In the second idiom, a function that can return different
kinds of tuples of return values (for example, one
tuple for its usual path, another for error conditions)
is modeled by having a union of tuple types as its return
type. A destructuring assignment on a union of tuple types
decomposes the tuple in a way that the dependencies between
the types of each member of the union can be tracked.
Narrowing the type of one of the tuple's components with
a type predicate can narrow the types of the other
components.

Usability has been a concern in the design of Typed Lua since the beginning. We realized that a design based solely on what
is possible by the semantics of Lua could lead to a 
complex type system. For this reason, we surveyed a large
corpus of Lua code to identify important idioms that
our type system should support.

We performed several
case studies to evaluate how successful we were in our goal of
providing an usable type system.
We evaluated 29 modules from 8 different case studies,
and we could give precise static types to 83\% of the 449
values that these modules export.
For half of the modules, we could give precise static types to
at least 89\% of the exports from each module.

Our evaluation results show that our type system can statically
type check several Lua idioms and features, though the evaluation
also exposed several limitations.
We found that the three main limitations are
the lack of full support for overloaded functions, the lack
of parametric polymorphism, and operator overloading.
Overcoming these limitations is one major target for future work,
as it will allow us to statically type check more programs.

Unlike some optional type systems, such as the type systems
of the Typescript and Dart languages, we designed Typed Lua without deliberately unsound parts.
However, we still do not have proofs that the novel features of
our type system are sound. We are working on a generalization
of the typing rules for evolution of table types where tagged
types can be attached to arbitrary references instead of
just local variables, and expect that a proof of soundness
will come out of this effort.

Typed Lua has a working implementation\footnote{Available
at \url{http://github.com/andremm/typelua}.} that
Lua programmers can already use as a framework to
document, test, and structure their applications.
Even applications where a full conversion to static
type checking is unfeasible in the current state
of the type system, or too much work, can use Typed
Lua to document the external interfaces of its
libraries, giving the benefits of static typing
checking to the users of those libraries.

We already have feedback from Lua projects
that are evaluating the use of Typed Lua, such
as the LuaRocks package manager, which is a key
piece of infrastructure for the Lua library ecosystem,
and ZeroBrane Studio, an IDE for Lua programs that is itself
written in Lua.

\bibliographystyle{abbrvnat}
\bibliography{paper}

\end{document}
